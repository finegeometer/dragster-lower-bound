<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Iris Logic Setup</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.18.0+0.18.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="iris-logic-setup">
<h1 class="title">Iris Logic Setup</h1>

<p>How does one reason about the behavior of imperative code?</p>
<p>A standard method is <em>Hoare logic</em>. The idea is as follows:</p>
<ul class="simple">
<li>Before and after every line of code,
we describe a condition that must hold.</li>
<li>We can then <em>locally</em> check that everything is consistent.
If the precondition holds before running a statement,
then the statement must run without crashing,
and the postcondition must hold afterwards.</li>
</ul>
<p>Hoare logic has a refinement called <em>separation logic</em>.
It adds a new logical operator, called the separating conjunction.
Roughly, while <tt class="docutils literal">(addr1 ‚Ü¶ val1) ‚àß (addr2 ‚Ü¶ val2)</tt>
allows the two addresses to be the same,
<tt class="docutils literal">(addr1 ‚Ü¶ val1) ‚àó (addr2 ‚Ü¶ val2)</tt> does not.
You can also vew this as tracking ownership of memory;
if I own the value at <tt class="docutils literal">addr1</tt>, and you own the value at <tt class="docutils literal">addr2</tt>,
then they can't be the same address.</p>
<p>This vastly simplifies the specification of writing to memory.
It also helps analyze concurrent code,
but I don't care about that right now.</p>
<p>Coq has a nice separation logic implementation,
called <a class="reference external" href="https://iris-project.org/">Iris</a>. So let's use it!</p>
<p>An important point: While Iris is a big part of the proof,
it is <em>not</em> part of the claim I'm proving. So, since Coq verifies
that the proof is correct, it is <em>not necessary</em> to trust
the authors of the Iris library! If they did something wrong,
Coq would either reject their proofs, reject <em>my</em> proof,
or turn up something suspicious when I run <tt class="docutils literal">Print Assumptions</tt>
in <tt class="docutils literal">main.v</tt>.</p>
<div class="section" id="language">
<h1>Language</h1>
<p>Iris is designed to be used for programming languages,
which have statements and expressions and so forth.
But I want to use it for a machine language. What do I do?</p>
<p>Here's a cool trick. Imagine an expression-based language
with a single expression. Attempting to reduce that expression
will return that same expression, with the side-effect of running
one machine instruction. Then trying to run the program to completion
will repeatedly run machine instructions. In other words,
it will simulate the behavior of the Atari.</p>
<p>I implement this strategy, with one tweak.
If the machine state says that the Dragster has been beaten in
less than 5.57 seconds, reducing the expression will crash.
This means that if the program cannot crash,
the game cannot be beaten in less than 5.57 seconds!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk0"><span class="kn">From</span> iris.program_logic <span class="kn">Require Import</span> language.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ssrmatching_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ssreflect_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> theories <span class="kn">Require Import</span> spec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* There is exactly one expression. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">expr</span> := Expr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* The expression never finishes reducing, so there are no values. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">val</span> :=.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* I don&#39;t actually know what this does, but it&#39;s required. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">observation</span> :=.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">of_val</span> (<span class="nv">v</span> : val) : expr := Expr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">to_val</span> (<span class="nv">e</span> : expr) : option val := None.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">claim</span> (<span class="nv">s</span> : state) : <span class="kt">Prop</span> :=
    <span class="kr">forall</span> <span class="nv">p</span>, player_has_won s p -&gt;
    <span class="kr">exists</span> <span class="nv">t</span>, timer_in_hundredths s p t /\ (t &gt;=? <span class="mi">557</span>)%Z.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Allow the unique expression to reduce to itself if</span>
<span class="c">the game has not been beaten in less than 5.57 seconds.</span>
<span class="c">Reduction causes the state to be updated by running</span>
<span class="c">one machine instruction, and does not fork off any new threads.</span>
<span class="c">|*)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prim_step</span> (<span class="nv">e</span> : expr) (<span class="nv">s</span> : state) (<span class="nv">Œ∫s</span> : list observation)
    (<span class="nv">e&#39;</span> : expr) (<span class="nv">s&#39;</span> : state) (<span class="nv">efs</span> : list expr) : <span class="kt">Prop</span> :=
    claim s /\ step s s&#39; /\ efs = [].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk1"><span class="kn">Lemma</span> <span class="nf">lang_mixin</span> : LanguageMixin of_val to_val prim_step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">LanguageMixin of_val to_val prim_step</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">LanguageMixin of_val to_val prim_step</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Canonical Structure</span> <span class="nf">lang</span> := Language lang_mixin.</span></span></pre><p>I claimed above that if evaluating the expression cannot crash,
Dragster cannot be beaten in less than 5.57 seconds. Let's prove this.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> unstable.bitvector_tactics.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk3"><span class="kn">Lemma</span> <span class="nf">initial_claim</span> <span class="nv">s</span> : initial s -&gt; claim s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">initial s ‚Üí claim s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">initial s ‚Üí claim s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk5"><span class="nb">rewrite</span> /claim /player_has_won /someone_has_won.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">initial s
‚Üí <span class="kr">‚àÄ</span> <span class="nv">p</span> : Player,
    player_active s p
    ‚àß trunc <span class="mi">11</span> (PC s) = <span class="mi">926</span>%bv ‚àß ¬¨ ¬¨ Flag s spec.Z
    ‚Üí <span class="kr">‚àÉ</span> <span class="nv">t</span> : Z,
        timer_in_hundredths s p t ‚àß (t &gt;=? <span class="mi">557</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk6"><span class="nb">move</span>=&gt; [_ [? [? [-&gt; [-&gt; -&gt;]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_x_, _x1_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">p</span> : Player,
  player_active s p
  ‚àß trunc <span class="mi">11</span>
      (spec.bv_concat <span class="mi">16</span> (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65532</span>))
         (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65533</span>))) = <span class="mi">926</span>%bv
    ‚àß ¬¨ ¬¨ Flag s spec.Z
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">t</span> : Z, timer_in_hundredths s p t ‚àß (t &gt;=? <span class="mi">557</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk7"><span class="nb">move</span>=&gt; ? [_ [contra _]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_x_, _x1_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>_p_</var><span class="hyp-type"><b>: </b><span>Player</span></span></span><br><span><var>contra</var><span class="hyp-type"><b>: </b><span>trunc <span class="mi">11</span>
  (spec.bv_concat <span class="mi">16</span>
     (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65532</span>))
     (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65533</span>))) = <span class="mi">926</span>%bv</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">t</span> : Z, timer_in_hundredths s _p_ t ‚àß (t &gt;=? <span class="mi">557</span>)%Z</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk8"><span class="nb">exfalso</span>; <span class="nb">move</span>: contra.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_x_, _x1_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>_p_</var><span class="hyp-type"><b>: </b><span>Player</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">trunc <span class="mi">11</span>
  (spec.bv_concat <span class="mi">16</span> (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65532</span>))
     (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65533</span>))) = <span class="mi">926</span>%bv ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk9"><span class="nb">clear</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">trunc <span class="mi">11</span>
  (spec.bv_concat <span class="mi">16</span> (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65532</span>))
     (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65533</span>))) = <span class="mi">926</span>%bv ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chka"><span class="nb">have</span> -&gt;: (trunc <span class="mi">11</span> (<span class="mi">0</span>xfffc : bv <span class="mi">16</span>) = <span class="mi">0</span>x7fc)%bv <span class="bp">by</span> bv_simplify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">trunc <span class="mi">11</span>
  (spec.bv_concat <span class="mi">16</span> (rom.ROM <span class="mi">2044</span>)
     (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65533</span>))) = <span class="mi">926</span>%bv ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkb"><span class="nb">have</span> -&gt;: (trunc <span class="mi">11</span> (<span class="mi">0</span>xfffd : bv <span class="mi">16</span>) = <span class="mi">0</span>x7fd)%bv <span class="bp">by</span> bv_simplify.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">trunc <span class="mi">11</span>
  (spec.bv_concat <span class="mi">16</span> (rom.ROM <span class="mi">2044</span>) (rom.ROM <span class="mi">2045</span>)) =
<span class="mi">926</span>%bv ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">compute</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkc"><span class="kn">Theorem</span> <span class="nf">no_crash_implies_goal</span> :
    (<span class="kr">forall</span> <span class="nv">s0</span>, initial s0 -&gt;
        <span class="kr">forall</span> <span class="nv">s</span>, rtc erased_step ([Expr], s0) ([Expr], s) -&gt;
            not_stuck Expr s) -&gt;
    <span class="kn">Goal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÄ</span> <span class="nv">s0</span> : state,
   initial s0
   ‚Üí <span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
       rtc erased_step ([Expr], s0) ([Expr], s)
       ‚Üí not_stuck Expr s) ‚Üí <span class="kn">Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÄ</span> <span class="nv">s0</span> : state,
   initial s0
   ‚Üí <span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
       rtc erased_step ([Expr], s0) ([Expr], s)
       ‚Üí not_stuck Expr s) ‚Üí <span class="kn">Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chke"><span class="nb">move</span>=&gt; H s0 s0_initial s reachable; <span class="nb">fold</span> (claim s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s0</span> : state,
  initial s0
  ‚Üí <span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
      rtc erased_step ([Expr], s0) ([Expr], s)
      ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">claim s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkf"><span class="nb">specialize</span> (H s0 s0_initial).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">claim s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk10"><span class="nb">eapply</span> (rtc_ind_r
        (<span class="kr">fun</span> <span class="nv">s</span> =&gt; claim s /\ rtc erased_step ([Expr], s0) ([Expr], s))
    ); <span class="nb">last</span> <span class="bp">exact</span> reachable.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">claim s0 ‚àß rtc erased_step ([Expr], s0) ([Expr], s0)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s</span></span></span><br></div><label class="goal-separator" for="iris-v-chk11"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">y</span> <span class="nv">z</span> : state,
  rtc step s0 y
  ‚Üí step y z
    ‚Üí claim y
      ‚àß rtc erased_step ([Expr], s0) ([Expr], y)
      ‚Üí claim z
        ‚àß rtc erased_step ([Expr], s0) ([Expr], z)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk12">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">claim s0 ‚àß rtc erased_step ([Expr], s0) ([Expr], s0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk13"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">claim s0</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s</span></span></span><br></div><label class="goal-separator" for="iris-v-chk14"><hr></label><div class="goal-conclusion">rtc erased_step ([Expr], s0) ([Expr], s0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk15">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">claim s0</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> initial_claim.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk16">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rtc erased_step ([Expr], s0) ([Expr], s0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk17">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">y</span> <span class="nv">z</span> : state,
  rtc step s0 y
  ‚Üí step y z
    ‚Üí claim y
      ‚àß rtc erased_step ([Expr], s0) ([Expr], y)
      ‚Üí claim z
        ‚àß rtc erased_step ([Expr], s0) ([Expr], z)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk18"><span class="nb">clear</span> reachable =&gt; s1 s2 reachable œÉ [IH1 IH2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">claim s2 ‚àß rtc erased_step ([Expr], s0) ([Expr], s2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk19"><span class="nb">suff</span>: rtc erased_step ([Expr], s0) ([Expr], s2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rtc erased_step ([Expr], s0) ([Expr], s2)
‚Üí claim s2 ‚àß rtc erased_step ([Expr], s0) ([Expr], s2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br></div><label class="goal-separator" for="iris-v-chk1a"><hr></label><div class="goal-conclusion">rtc erased_step ([Expr], s0) ([Expr], s2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk1b">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rtc erased_step ([Expr], s0) ([Expr], s2)
‚Üí claim s2 ‚àß rtc erased_step ([Expr], s0) ([Expr], s2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk1c"><span class="nb">split</span>; <span class="nb">last</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">claim s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk1d"><span class="nb">suff</span>: not_stuck Expr s2
                <span class="bp">by</span> <span class="nb">case</span> =&gt; [[_ //]|[_ [[] [_ [_ [// _]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">not_stuck Expr s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk1e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rtc erased_step ([Expr], s0) ([Expr], s2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk1f"><span class="nb">eapply</span> rtc_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rtc erased_step ([Expr], s0) <span class="nl">?y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br></div><label class="goal-separator" for="iris-v-chk20"><hr></label><div class="goal-conclusion">erased_step <span class="nl">?y</span> ([Expr], s2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk21">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rtc erased_step ([Expr], s0) <span class="nl">?y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> IH2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk22">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">erased_step ([Expr], s1) ([Expr], s2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk23"><span class="kr">exists</span> [].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s0</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">s</span> : language.state lang,
  rtc erased_step ([Expr], s0) ([Expr], s)
  ‚Üí not_stuck Expr s</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s, s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc step s0 s1</span></span></span><br><span><var>œÉ</var><span class="hyp-type"><b>: </b><span>step s1 s2</span></span></span><br><span><var>IH1</var><span class="hyp-type"><b>: </b><span>claim s1</span></span></span><br><span><var>IH2</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s1)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">language.step ([Expr], s1) [] ([Expr], s2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> (step_atomic _ _ _ _ [] [] [] eq_refl eq_refl).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="logic">
<h1>Logic</h1>
<p>Now that the language has been created,
let's connect it to the Iris logic.</p>
<p>I find this difficult to explain, possibly because I don't
fully understand it myself. But I'll do my best.</p>
<p>Here's the idea.</p>
<p>Iris has a concept of &quot;ghost state&quot;, which is an abstract ... thing ...
that you can own. After describing some available ghost state,
we split it into two parts; one owned by the state,
and one owned by the user of the logic.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> finite.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> iris.algebra <span class="kn">Require Export</span> excl_auth functions.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk24"><span class="kn">From</span> iris.base_logic.lib <span class="kn">Require Import</span> own.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ltac2_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small></span></pre><p>To begin, I define a type of places values can be stored,
along with the type of value stored there.
I also explain to Coq how to tell if two places are the same or not.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">byte_place</span> := 
| RAM (addr : bv <span class="mi">7</span>)
| Reg (r : reg)
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">place</span> :=
| BytePlace of byte_place
| PC
| Flag of flag
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Coercion</span> <span class="nf">BytePlace</span> : byte_place &gt;-&gt; place.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">place_data</span> (<span class="nv">p</span> : place) : <span class="kt">Set</span> :=
    <span class="kr">match</span> p <span class="kr">with</span>
    | BytePlace _ =&gt; bv <span class="mi">8</span>
    | PC =&gt; bv <span class="mi">16</span>
    | Flag _ =&gt; bool
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk25"><span class="kn">Global Instance</span> <span class="nf">byte_place_eq_def</span> : EqDecision byte_place.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDecision byte_place</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk26"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDecision byte_place</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk27"><span class="nb">case</span>=&gt; [a1|r1]; <span class="nb">case</span>=&gt; [a2|r2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (RAM a1 = RAM a2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><label class="goal-separator" for="iris-v-chk28"><hr></label><div class="goal-conclusion">Decision (RAM a1 = Reg r2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chk29" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><label class="goal-separator" for="iris-v-chk29"><hr></label><div class="goal-conclusion">Decision (Reg r1 = RAM a2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><label class="goal-separator" for="iris-v-chk2a"><hr></label><div class="goal-conclusion">Decision (Reg r1 = Reg r2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk2b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (RAM a1 = RAM a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk2c"><span class="nb">case</span> (decide (a1 = a2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a1 = a2 ‚Üí Decision (RAM a1 = RAM a2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><label class="goal-separator" for="iris-v-chk2d"><hr></label><div class="goal-conclusion">a1 ‚â† a2 ‚Üí Decision (RAM a1 = RAM a2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk2e">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a1 = a2 ‚Üí Decision (RAM a1 = RAM a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>; <span class="nb">apply</span> <span class="nb">f_equal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk2f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1, a2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a1 ‚â† a2 ‚Üí Decision (RAM a1 = RAM a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>=&gt; eq; <span class="nb">inversion</span> eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk30">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a1</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br><span><var>r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (RAM a1 = Reg r2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk31">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>a2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (Reg r1 = RAM a2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk32">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (Reg r1 = Reg r2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk33"><span class="nb">case</span> (decide (r1 = r2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 = r2 ‚Üí Decision (Reg r1 = Reg r2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><label class="goal-separator" for="iris-v-chk34"><hr></label><div class="goal-conclusion">r1 ‚â† r2 ‚Üí Decision (Reg r1 = Reg r2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk35">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 = r2 ‚Üí Decision (Reg r1 = Reg r2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>; <span class="nb">apply</span> <span class="nb">f_equal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk36">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">r1 ‚â† r2 ‚Üí Decision (Reg r1 = Reg r2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>=&gt; eq; <span class="nb">inversion</span> eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk37"><span class="kn">Global Instance</span> <span class="nf">place_eq_def</span> : EqDecision place.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDecision place</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">EqDecision place</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk39"><span class="nb">case</span>=&gt; [b1||f1]; <span class="nb">case</span>=&gt; [b2||f2].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (b1 = b2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><label class="goal-separator" for="iris-v-chk3a"><hr></label><div class="goal-conclusion">Decision (b1 = PC)</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><label class="goal-separator" for="iris-v-chk3b"><hr></label><div class="goal-conclusion">Decision (b1 = Flag f2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b2</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><label class="goal-separator" for="iris-v-chk3c"><hr></label><div class="goal-conclusion">Decision (PC = b2)</div></blockquote><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (PC = PC)</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f2</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><label class="goal-separator" for="iris-v-chk3d"><hr></label><div class="goal-conclusion">Decision (PC = Flag f2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>b2</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><label class="goal-separator" for="iris-v-chk3e"><hr></label><div class="goal-conclusion">Decision (Flag f1 = b2)</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><label class="goal-separator" for="iris-v-chk3f"><hr></label><div class="goal-conclusion">Decision (Flag f1 = PC)</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><label class="goal-separator" for="iris-v-chk40"><hr></label><div class="goal-conclusion">Decision (Flag f1 = Flag f2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk41">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (b1 = b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk42"><span class="nb">case</span> (decide (b1 = b2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b1 = b2 ‚Üí Decision (b1 = b2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk43" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><label class="goal-separator" for="iris-v-chk43"><hr></label><div class="goal-conclusion">b1 ‚â† b2 ‚Üí Decision (b1 = b2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk44">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b1 = b2 ‚Üí Decision (b1 = b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>; <span class="nb">apply</span> <span class="nb">f_equal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk45">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1, b2</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b1 ‚â† b2 ‚Üí Decision (b1 = b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>=&gt; eq; <span class="nb">inversion</span> eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (b1 = PC)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk47">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b1</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br><span><var>f2</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (b1 = Flag f2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk48">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b2</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (PC = b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk49">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (PC = PC)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk4a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f2</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (PC = Flag f2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk4b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>b2</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (Flag f1 = b2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk4c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (Flag f1 = PC)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk4d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Decision (Flag f1 = Flag f2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk4e"><span class="nb">case</span> (decide (f1 = f2)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f1 = f2 ‚Üí Decision (Flag f1 = Flag f2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><label class="goal-separator" for="iris-v-chk4f"><hr></label><div class="goal-conclusion">f1 ‚â† f2 ‚Üí Decision (Flag f1 = Flag f2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk50">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f1 = f2 ‚Üí Decision (Flag f1 = Flag f2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">left</span>; <span class="nb">apply</span> <span class="nb">f_equal</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk51">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f1, f2</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f1 ‚â† f2 ‚Üí Decision (Flag f1 = Flag f2)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">right</span>=&gt; eq; <span class="nb">inversion</span> eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Program Instance</span> <span class="nf">byte_place_finite</span> : Finite byte_place := {|
    enum := Reg X :: Reg Y :: Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>));
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk52"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Reg X
   :: Reg Y
      :: Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk53"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Reg X
   :: Reg Y
      :: Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk54"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg X
‚àâ Reg Y :: Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Reg Y :: Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk55">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg X
‚àâ Reg Y :: Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk56"><span class="kp">do</span> <span class="mi">3</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg X ‚àà RAM &lt;$&gt; enum (bv <span class="mi">7</span>) ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk57"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">7</span>, Reg X = RAM y ‚àß y ‚àà enum (bv <span class="mi">7</span>)) ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk58">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Reg Y :: Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk59"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg Y ‚àâ Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk5a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg Y ‚àâ Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk5b"><span class="kp">do</span> <span class="mi">2</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg Y ‚àà RAM &lt;$&gt; enum (bv <span class="mi">7</span>) ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk5c"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">7</span>, Reg Y = RAM y ‚àß y ‚àà enum (bv <span class="mi">7</span>)) ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk5d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk5e"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg A ‚àâ Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk5f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg A ‚àâ Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk60"><span class="kp">do</span> <span class="mi">1</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg A ‚àà RAM &lt;$&gt; enum (bv <span class="mi">7</span>) ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk61"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">7</span>, Reg A = RAM y ‚àß y ‚àà enum (bv <span class="mi">7</span>)) ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk62">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk63"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg SP ‚àâ RAM &lt;$&gt; enum (bv <span class="mi">7</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk64">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg SP ‚àâ RAM &lt;$&gt; enum (bv <span class="mi">7</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk65"><span class="kp">do</span> <span class="mi">0</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Reg SP ‚àâ RAM &lt;$&gt; enum (bv <span class="mi">7</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk66"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">7</span>, Reg SP = RAM y ‚àß y ‚àà enum (bv <span class="mi">7</span>)) ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk67">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk68"><span class="nb">apply</span> NoDup_fmap_2; <span class="nb">last</span> <span class="nb">apply</span> NoDup_enum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Inj eq eq RAM</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x y eq; <span class="nb">inversion</span> eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk69"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">x</span> : byte_place,
  x
  ‚àà Reg X
    :: Reg Y
       :: Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk6a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">x</span> : byte_place,
  x
  ‚àà Reg X
    :: Reg Y
       :: Reg A :: Reg SP :: (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk6b"><span class="nb">case</span>; <span class="nb">last</span> <span class="nb">case</span>; <span class="kp">do</span> <span class="mi">4</span> <span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RAM addr ‚àà RAM &lt;$&gt; enum (bv <span class="mi">7</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk6c"><span class="nb">apply</span> elem_of_list_fmap_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">addr ‚àà enum (bv <span class="mi">7</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> elem_of_enum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Program Instance</span> <span class="nf">place_finite</span> : Finite place := {|
    enum := PC
        :: Flag spec.N 
        :: Flag spec.B 
        :: Flag spec.V 
        :: Flag spec.D 
        :: Flag spec.I 
        :: Flag spec.Z 
        :: Flag spec.C
        :: (BytePlace &lt;$&gt; enum byte_place);
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk6d"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (PC
   :: Flag spec.N
      :: Flag B
         :: Flag V
            :: Flag D
               :: Flag I
                  :: Flag spec.Z
                     :: Flag C
                        :: (BytePlace &lt;$&gt;
                            enum byte_place))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk6e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (PC
   :: Flag spec.N
      :: Flag B
         :: Flag V
            :: Flag D
               :: Flag I
                  :: Flag spec.Z
                     :: Flag C
                        :: (BytePlace &lt;$&gt;
                            enum byte_place))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk6f"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">PC
‚àâ Flag spec.N
  :: Flag B
     :: Flag V
        :: Flag D
           :: Flag I
              :: Flag spec.Z
                 :: Flag C
                    :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag spec.N
   :: Flag B
      :: Flag V
         :: Flag D
            :: Flag I
               :: Flag spec.Z
                  :: Flag C
                     :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk70">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">PC
‚àâ Flag spec.N
  :: Flag B
     :: Flag V
        :: Flag D
           :: Flag I
              :: Flag spec.Z
                 :: Flag C
                    :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk71"><span class="kp">do</span> <span class="mi">7</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">PC ‚àà BytePlace &lt;$&gt; enum byte_place ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk72"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : byte_place, PC = y ‚àß y ‚àà enum byte_place)
‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk73">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag spec.N
   :: Flag B
      :: Flag V
         :: Flag D
            :: Flag I
               :: Flag spec.Z
                  :: Flag C
                     :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk74"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag spec.N
‚àâ Flag B
  :: Flag V
     :: Flag D
        :: Flag I
           :: Flag spec.Z
              :: Flag C
                 :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag B
   :: Flag V
      :: Flag D
         :: Flag I
            :: Flag spec.Z
               :: Flag C
                  :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk75">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag spec.N
‚àâ Flag B
  :: Flag V
     :: Flag D
        :: Flag I
           :: Flag spec.Z
              :: Flag C
                 :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk76"><span class="kp">do</span> <span class="mi">6</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag spec.N ‚àà BytePlace &lt;$&gt; enum byte_place ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk77"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : byte_place,
   Flag spec.N = y ‚àß y ‚àà enum byte_place) ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk78">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag B
   :: Flag V
      :: Flag D
         :: Flag I
            :: Flag spec.Z
               :: Flag C
                  :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk79"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag B
‚àâ Flag V
  :: Flag D
     :: Flag I
        :: Flag spec.Z
           :: Flag C
              :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag V
   :: Flag D
      :: Flag I
         :: Flag spec.Z
            :: Flag C
               :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk7a">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag B
‚àâ Flag V
  :: Flag D
     :: Flag I
        :: Flag spec.Z
           :: Flag C
              :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk7b"><span class="kp">do</span> <span class="mi">5</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag B ‚àà BytePlace &lt;$&gt; enum byte_place ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk7c"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : byte_place, Flag B = y ‚àß y ‚àà enum byte_place)
‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk7d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag V
   :: Flag D
      :: Flag I
         :: Flag spec.Z
            :: Flag C
               :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk7e"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag V
‚àâ Flag D
  :: Flag I
     :: Flag spec.Z
        :: Flag C :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag D
   :: Flag I
      :: Flag spec.Z
         :: Flag C :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk7f">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag V
‚àâ Flag D
  :: Flag I
     :: Flag spec.Z
        :: Flag C :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk80"><span class="kp">do</span> <span class="mi">4</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag V ‚àà BytePlace &lt;$&gt; enum byte_place ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk81"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : byte_place, Flag V = y ‚àß y ‚àà enum byte_place)
‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk82">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag D
   :: Flag I
      :: Flag spec.Z
         :: Flag C :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk83"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag D
‚àâ Flag I
  :: Flag spec.Z
     :: Flag C :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag I
   :: Flag spec.Z
      :: Flag C :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk84">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag D
‚àâ Flag I
  :: Flag spec.Z
     :: Flag C :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk85"><span class="kp">do</span> <span class="mi">3</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag D ‚àà BytePlace &lt;$&gt; enum byte_place ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk86"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : byte_place, Flag D = y ‚àß y ‚àà enum byte_place)
‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk87">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag I
   :: Flag spec.Z
      :: Flag C :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk88"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag I
‚àâ Flag spec.Z
  :: Flag C :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag spec.Z
   :: Flag C :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk89">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag I
‚àâ Flag spec.Z
  :: Flag C :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk8a"><span class="kp">do</span> <span class="mi">2</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag I ‚àà BytePlace &lt;$&gt; enum byte_place ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk8b"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : byte_place, Flag I = y ‚àß y ‚àà enum byte_place)
‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk8c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup
  (Flag spec.Z
   :: Flag C :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk8d"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag spec.Z
‚àâ Flag C :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (Flag C :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk8e">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag spec.Z
‚àâ Flag C :: (BytePlace &lt;$&gt; enum byte_place)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk8f"><span class="kp">do</span> <span class="mi">1</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag spec.Z ‚àà BytePlace &lt;$&gt; enum byte_place ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk90"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : byte_place,
   Flag spec.Z = y ‚àß y ‚àà enum byte_place) ‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk91">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (Flag C :: (BytePlace &lt;$&gt; enum byte_place))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk92"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag C ‚àâ BytePlace &lt;$&gt; enum byte_place</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (BytePlace &lt;$&gt; enum byte_place)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk93">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag C ‚àâ BytePlace &lt;$&gt; enum byte_place</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk94"><span class="kp">do</span> <span class="mi">0</span> (<span class="nb">case</span> /elem_of_cons; <span class="kp">first</span> <span class="bp">done</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag C ‚àâ BytePlace &lt;$&gt; enum byte_place</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk95"><span class="nb">move</span>=&gt; tmp; <span class="nb">apply</span> elem_of_list_fmap_2 <span class="kr">in</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">y</span> : byte_place, Flag C = y ‚àß y ‚àà enum byte_place)
‚Üí <span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; [_ [// _]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk96">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (BytePlace &lt;$&gt; enum byte_place)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk97"><span class="nb">apply</span> NoDup_fmap_2; <span class="nb">last</span> <span class="nb">apply</span> NoDup_enum.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">Inj eq eq BytePlace</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; x y eq; <span class="nb">inversion</span> eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk98"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">x</span> : place,
  x
  ‚àà PC
    :: Flag spec.N
       :: Flag B
          :: Flag V
             :: Flag D
                :: Flag I
                   :: Flag spec.Z
                      :: Flag C
                         :: (BytePlace &lt;$&gt;
                             enum byte_place)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">x</span> : place,
  x
  ‚àà PC
    :: Flag spec.N
       :: Flag B
          :: Flag V
             :: Flag D
                :: Flag I
                   :: Flag spec.Z
                      :: Flag C
                         :: (BytePlace &lt;$&gt;
                             enum byte_place)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk9a"><span class="nb">case</span>; <span class="nb">last</span> <span class="nb">case</span>; <span class="kp">do</span> <span class="mi">8</span> <span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b ‚àà BytePlace &lt;$&gt; enum byte_place</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk9b"><span class="nb">apply</span> elem_of_list_fmap_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>byte_place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b ‚àà enum byte_place</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> elem_of_enum.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Now, I define the relevant ghost state.</p>
<p>I use a very specific, but useful, type of ghost state.
Iris calls it &quot;ExclAuth&quot;. The idea is as follows:</p>
<ul class="simple">
<li>The state is a pair of propositions, <tt class="docutils literal">‚óØE x</tt> and <tt class="docutils literal">‚óèE x</tt>.</li>
<li>These propositions are &quot;entangled&quot;, in the sense that
if you own <tt class="docutils literal">‚óØE x</tt>, and someone else owns <tt class="docutils literal">‚óèE y</tt>, then <tt class="docutils literal">x = y</tt>.</li>
</ul>
<p>I define one such pair for each place a value can be stored.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">atari_camera</span> :=
    discrete_funR (<span class="kr">fun</span> <span class="nv">p</span> =&gt; excl_authUR (leibnizO (place_data p))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">atariGpreS</span> (<span class="nv">Œ£</span> : gFunctors) := {
    atari_data :: inG Œ£ atari_camera;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">atariGS</span> (<span class="nv">Œ£</span> : gFunctors) := {
    atari_inG :: atariGpreS Œ£;
    atari_name : gname;
}.</span></span></pre><p>I now let the state own the <tt class="docutils literal">‚óè</tt> part, and the user own the <tt class="docutils literal">‚óØ</tt> part.
The entanglement then allows the user's assertions
to talk about the Atari's state.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">state_interp_help</span> `{!atariGS Œ£} (s : state) : atari_camera :=
    <span class="kr">fun</span> <span class="nv">p</span> =&gt; ‚óèE <span class="kr">match</span> p <span class="kr">return</span> leibnizO (place_data p) <span class="kr">with</span>
    | RAM a =&gt; spec.RAM s a
    | Reg r =&gt; spec.Reg s r
    | PC =&gt; spec.PC s
    | Flag f =&gt; spec.Flag s f
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">state_interp</span> `{!atariGS Œ£} (s : state) : iProp Œ£ :=
    own atari_name (state_interp_help s).</span></span></pre><p>The user will want to discuss the state in terms of assertions like
<tt class="docutils literal">Reg X ‚Ü¶ 0x00%bv</tt>. Let's implement that.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">pointsto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Context</span> `{!atariGS Œ£}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk9c"><span class="kn">Definition</span> <span class="nf">pointsto_fun</span> (<span class="nv">l</span> : place) (<span class="nv">v</span> : place_data l) :
        atari_camera.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>place_data l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">atari_camera</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk9d"><span class="nb">eapply</span> discrete_fun_singleton.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>place_data l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">excl_authUR (leibnizO (place_data <span class="nl">?x</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk9e"><span class="nb">refine</span> (‚óØE _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>place_data l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">leibnizO (place_data <span class="nl">?x</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> v.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pointsto_def</span> (<span class="nv">l</span> : place) (<span class="nv">v</span> : place_data l) : iProp Œ£ :=
        own atari_name (pointsto_fun l v).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk9f"><span class="kn">Definition</span> <span class="nf">pointsto_aux</span> : seal (@pointsto_def).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">seal pointsto_def</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eexists</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pointsto</span> := pointsto_aux.(unseal).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pointsto_eq</span> : @pointsto = @pointsto_def :=
        pointsto_aux.(seal_eq).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">pointsto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;l ‚Ü¶ v&quot;</span> := (pointsto l v)
  (<span class="kn">at level</span> <span class="mi">20</span>, <span class="kn">format</span> <span class="s2">&quot;l  ‚Ü¶  v&quot;</span>) : bi_scope.</span></span></pre><p>Or sometimes you just want ownership of the location, without caring what's stored there.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Notation</span> <span class="s2">&quot;l ‚Ü¶ ?&quot;</span> := (<span class="kr">‚àÉ</span> <span class="nv">v</span>, l ‚Ü¶ v)%I
  (<span class="kn">at level</span> <span class="mi">20</span>, <span class="kn">format</span> <span class="s2">&quot;l  ‚Ü¶ ?&quot;</span>) : bi_scope.</span></span></pre></div>
<div class="section" id="startup">
<h1>Startup</h1>
<p>When the Atari boots up, what do we know?</p>
<ul class="simple">
<li>The program counter points to the value stored at 0xFFFC and 0xFFFD,
which happens to be 0xF000.</li>
<li>The interrupt disable flag is set.</li>
<li>Everything else points to <em>something</em>, but we don't know what.</li>
</ul>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">init</span> `{!atariGS Œ£} : iProp Œ£ :=
    PC ‚Ü¶ <span class="mi">0</span>xf000%bv
    ‚àó Reg X ‚Ü¶ ?
    ‚àó Reg Y ‚Ü¶ ?
    ‚àó Reg A ‚Ü¶ ?
    ‚àó Reg SP ‚Ü¶ ?
    ‚àó Flag spec.N ‚Ü¶ ?
    ‚àó Flag spec.B ‚Ü¶ ?
    ‚àó Flag spec.V ‚Ü¶ ?
    ‚àó Flag spec.D ‚Ü¶ ?
    ‚àó Flag spec.I ‚Ü¶ true
    ‚àó Flag spec.Z ‚Ü¶ ?
    ‚àó Flag spec.C ‚Ü¶ ?
    ‚àó [‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶ ?
    .</span></span></pre><p>A few lemmas, for the correctness proof.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chka0"><span class="kn">Lemma</span> <span class="nf">discrete_fun_lookup_big_opL</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">B</span> : A ‚Üí ucmra} {<span class="nv">X</span> : <span class="kt">Type</span>}
    (<span class="nv">f</span> : X -&gt; discrete_fun B) (<span class="nv">l</span> : list X) (<span class="nv">a</span> : A) :
    ([^op list] x ‚àà l, f x) a = ([^op list] x ‚àà l, f x a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A ‚Üí ucmra</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X ‚Üí discrete_fun (<span class="kr">Œª</span> <span class="nv">x</span> : A, B x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([^op list] x ‚àà l, f x) a = ([^op list] x ‚àà l, f x a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chka1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A ‚Üí ucmra</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X ‚Üí discrete_fun (<span class="kr">Œª</span> <span class="nv">x</span> : A, B x)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([^op list] x ‚àà l, f x) a = ([^op list] x ‚àà l, f x a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chka2"><span class="nb">induction</span> l <span class="kr">as</span> [|x l IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A ‚Üí ucmra</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X ‚Üí discrete_fun (<span class="kr">Œª</span> <span class="nv">x</span> : A, B x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([^op list] x ‚àà [], f x) a =
([^op list] x ‚àà [], f x a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chka3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A ‚Üí ucmra</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X ‚Üí discrete_fun (<span class="kr">Œª</span> <span class="nv">x</span> : A, B x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>([^op list] x ‚àà l, f x) a =
([^op list] x ‚àà l, f x a)</span></span></span><br></div><label class="goal-separator" for="iris-v-chka3"><hr></label><div class="goal-conclusion">([^op list] x ‚àà (x :: l), f x) a =
([^op list] x ‚àà (x :: l), f x a)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chka4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A ‚Üí ucmra</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X ‚Üí discrete_fun (<span class="kr">Œª</span> <span class="nv">x</span> : A, B x)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([^op list] x ‚àà [], f x) a =
([^op list] x ‚àà [], f x a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chka5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A ‚Üí ucmra</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X ‚Üí discrete_fun (<span class="kr">Œª</span> <span class="nv">x</span> : A, B x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>([^op list] x ‚àà l, f x) a =
([^op list] x ‚àà l, f x a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([^op list] x ‚àà (x :: l), f x) a =
([^op list] x ‚àà (x :: l), f x a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chka6"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>B</var><span class="hyp-type"><b>: </b><span>A ‚Üí ucmra</span></span></span><br><span><var>X</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>X ‚Üí discrete_fun (<span class="kr">Œª</span> <span class="nv">x</span> : A, B x)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>X</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list X</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>([^op list] x ‚àà l, f x) a =
([^op list] x ‚àà l, f x a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f x ‚ãÖ ([^op list] x ‚àà l, f x)) a =
f x a ‚ãÖ ([^op list] x ‚àà l, f x a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> discrete_fun_lookup_op IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chka7"><span class="kn">Lemma</span> <span class="nf">split_into_pointers</span> `{!atariGS Œ£}
    (f : <span class="kr">forall</span> <span class="nv">p</span>, leibnizO (place_data p)) :
    own atari_name ((<span class="kr">fun</span> <span class="nv">p</span> =&gt; ‚óØE (f p)) : atari_camera) ‚ä£‚ä¢
    [‚àó list] p ‚àà enum place, p ‚Ü¶ f p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">own atari_name
  ((<span class="kr">Œª</span> <span class="nv">p</span> : place, ‚óØE (f p)) : atari_camera)
‚ä£‚ä¢ ([‚àó list] p ‚àà enum place, p ‚Ü¶ f p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chka8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">own atari_name
  ((<span class="kr">Œª</span> <span class="nv">p</span> : place, ‚óØE (f p)) : atari_camera)
‚ä£‚ä¢ ([‚àó list] p ‚àà enum place, p ‚Ü¶ f p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chka9"><span class="nb">rewrite</span> pointsto_eq -big_opL_own; <span class="nb">last</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">own atari_name (<span class="kr">Œª</span> <span class="nv">p</span> : place, ‚óØE (f p))
‚ä£‚ä¢ own atari_name
     ([^op list] x ‚àà enum place, pointsto_fun x (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkaa"><span class="nb">apply</span> own_proper.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">Œª</span> <span class="nv">p</span> : place, ‚óØE (f p))
‚â° ([^op list] x ‚àà enum place, pointsto_fun x (f x))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkab"><span class="nb">move</span>=&gt; p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚óØE (f p)
‚â° ([^op list] x ‚àà enum place, pointsto_fun x (f x)) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkac"><span class="nb">rewrite</span> discrete_fun_lookup_big_opL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚óØE (f p)
‚â° ([^op list] x ‚àà enum place, pointsto_fun x (f x) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* Well, this is an annoying proof. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkad"><span class="nb">pose</span> (NoDup_enum place) <span class="kr">as</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (enum place)
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà enum place, 
     pointsto_fun x (f x) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkae"><span class="nb">induction</span> (elem_of_enum p) <span class="kr">as</span> [p l|p q l elem IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (p :: l)
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà (p :: l), pointsto_fun x (f x) p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chkaf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>elem</var><span class="hyp-type"><b>: </b><span>p ‚àà l</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup l
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br></div><label class="goal-separator" for="iris-v-chkaf"><hr></label><div class="goal-conclusion">NoDup (q :: l)
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà (q :: l), pointsto_fun x (f x) p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkb0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (p :: l)
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà (p :: l), pointsto_fun x (f x) p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkb1"><span class="nb">rewrite</span> NoDup_cons big_opL_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(p ‚àâ l) ‚àß NoDup l
‚Üí ‚óØE (f p)
  ‚â° pointsto_fun p (f p) p
    ‚ãÖ ([^op list] y ‚àà l, pointsto_fun y (f y) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkb2"><span class="nb">move</span>=&gt; [notin nodup].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ l</span></span></span><br><span><var>nodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚óØE (f p)
‚â° pointsto_fun p (f p) p
  ‚ãÖ ([^op list] y ‚àà l, pointsto_fun y (f y) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkb3"><span class="nb">have</span> &lt;-: (Œµ = [^op list] x ‚àà l, pointsto_fun x (f x) p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ l</span></span></span><br><span><var>nodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chkb4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ l</span></span></span><br><span><var>nodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><label class="goal-separator" for="iris-v-chkb4"><hr></label><div class="goal-conclusion">‚óØE (f p) ‚â° pointsto_fun p (f p) p ‚ãÖ Œµ</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkb5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ l</span></span></span><br><span><var>nodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkb6"><span class="nb">move</span>: notin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>nodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p ‚àâ l ‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkb7"><span class="nb">clear</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p ‚àâ l ‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkb8"><span class="nb">induction</span> l <span class="kr">as</span> [|q l IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p ‚àâ []
‚Üí Œµ = ([^op list] x ‚àà [], pointsto_fun x (f x) p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>p ‚àâ l
‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br></div><label class="goal-separator" for="iris-v-chkb9"><hr></label><div class="goal-conclusion">p ‚àâ q :: l
‚Üí Œµ =
  ([^op list] x ‚àà (q :: l), pointsto_fun x (f x) p)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p ‚àâ []
‚Üí Œµ = ([^op list] x ‚àà [], pointsto_fun x (f x) p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; //.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkbb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>p ‚àâ l
‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p ‚àâ q :: l
‚Üí Œµ =
  ([^op list] x ‚àà (q :: l), pointsto_fun x (f x) p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkbc"><span class="nb">move</span>=&gt; notin.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>p ‚àâ l
‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ q :: l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œµ = ([^op list] x ‚àà (q :: l), pointsto_fun x (f x) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkbd"><span class="nb">rewrite</span> big_opL_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>p ‚àâ l
‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ q :: l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œµ =
pointsto_fun q (f q) p
‚ãÖ ([^op list] y ‚àà l, pointsto_fun y (f y) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkbe"><span class="nb">rewrite</span> /pointsto_fun discrete_fun_lookup_singleton_ne;
                    <span class="kp">first</span> <span class="nb">rewrite</span> -IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>p ‚àâ l
‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ q :: l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œµ = Œµ ‚ãÖ Œµ</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chkbf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>p ‚àâ l
‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ q :: l</span></span></span><br></div><label class="goal-separator" for="iris-v-chkbf"><hr></label><div class="goal-conclusion">p ‚àâ l</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chkc0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>p ‚àâ l
‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ q :: l</span></span></span><br></div><label class="goal-separator" for="iris-v-chkc0"><hr></label><div class="goal-conclusion">q ‚â† p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkc1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>p ‚àâ l
‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ q :: l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Œµ = Œµ ‚ãÖ Œµ</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkc2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>p ‚àâ l
‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ q :: l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p ‚àâ l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; elem; <span class="nb">apply</span> notin; <span class="bp">by</span> <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">                </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkc3">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>p ‚àâ l
‚Üí Œµ = ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ q :: l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q ‚â† p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>=&gt; eq; <span class="nb">apply</span> notin; <span class="nb">rewrite</span> eq; <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkc4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ l</span></span></span><br><span><var>nodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚óØE (f p) ‚â° pointsto_fun p (f p) p ‚ãÖ Œµ</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkc5"><span class="nb">rewrite</span> ucmra_unit_right_id.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ l</span></span></span><br><span><var>nodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚óØE (f p) ‚â° pointsto_fun p (f p) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkc6"><span class="nb">rewrite</span> /pointsto_fun.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>p ‚àâ l</span></span></span><br><span><var>nodup</var><span class="hyp-type"><b>: </b><span>NoDup l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚óØE (f p) ‚â° discrete_fun_singleton p (‚óØE (f p)) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> discrete_fun_lookup_singleton.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkc7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>elem</var><span class="hyp-type"><b>: </b><span>p ‚àà l</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup l
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NoDup (q :: l)
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà (q :: l), pointsto_fun x (f x) p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkc8"><span class="nb">rewrite</span> NoDup_cons big_opL_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>elem</var><span class="hyp-type"><b>: </b><span>p ‚àà l</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup l
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(q ‚àâ l) ‚àß NoDup l
‚Üí ‚óØE (f p)
  ‚â° pointsto_fun q (f q) p
    ‚ãÖ ([^op list] y ‚àà l, pointsto_fun y (f y) p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkc9"><span class="nb">move</span>=&gt; [notin /IH &lt;-].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>elem</var><span class="hyp-type"><b>: </b><span>p ‚àà l</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup l
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>q ‚àâ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚óØE (f p) ‚â° pointsto_fun q (f q) p ‚ãÖ ‚óØE (f p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkca"><span class="nb">rewrite</span> /pointsto_fun.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>elem</var><span class="hyp-type"><b>: </b><span>p ‚àà l</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup l
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>q ‚àâ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚óØE (f p)
‚â° discrete_fun_singleton q (‚óØE (f q)) p ‚ãÖ ‚óØE (f p)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkcb"><span class="nb">rewrite</span> discrete_fun_lookup_singleton_ne.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>elem</var><span class="hyp-type"><b>: </b><span>p ‚àà l</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup l
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>q ‚àâ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚óØE (f p) ‚â° Œµ ‚ãÖ ‚óØE (f p)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chkcc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>elem</var><span class="hyp-type"><b>: </b><span>p ‚àà l</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup l
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>q ‚àâ l</span></span></span><br></div><label class="goal-separator" for="iris-v-chkcc"><hr></label><div class="goal-conclusion">q ‚â† p</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkcd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>elem</var><span class="hyp-type"><b>: </b><span>p ‚àà l</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup l
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>q ‚àâ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚óØE (f p) ‚â° Œµ ‚ãÖ ‚óØE (f p)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> ucmra_unit_left_id.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkce">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGS0</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span><br><span><var>p, q</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list place</span></span></span><br><span><var>elem</var><span class="hyp-type"><b>: </b><span>p ‚àà l</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>NoDup l
‚Üí ‚óØE (f p)
  ‚â° ([^op list] x ‚àà l, pointsto_fun x (f x) p)</span></span></span><br><span><var>notin</var><span class="hyp-type"><b>: </b><span>q ‚àâ l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">q ‚â† p</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; eq; <span class="nb">rewrite</span> eq <span class="kr">in</span> notin.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The correctness statement is a bit more complicated
than you might expect. That's because we're booting up
not just the Atari, but the Iris machinery as well.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> iris.proofmode <span class="kn">Require Import</span> proofmode.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkcf"><span class="kn">Theorem</span> <span class="nf">atari_init</span> `{!atariGpreS Œ£} s (s_initial : initial s) :
    ‚ä¢ |==&gt; <span class="kr">‚àÉ</span> <span class="nv">_</span> : atariGS Œ£, state_interp s ‚àó init.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚ä¢ |==&gt; <span class="kr">‚àÉ</span> <span class="nv">H</span> : atariGS Œ£, state_interp s ‚àó init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkd0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚ä¢ |==&gt; <span class="kr">‚àÉ</span> <span class="nv">H</span> : atariGS Œ£, state_interp s ‚àó init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    <span class="c">(* Define a ghost resource. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkd1"><span class="nb">set</span> f : <span class="kr">forall</span> <span class="nv">p</span>, leibnizO (place_data p) := <span class="kr">fun</span> <span class="nv">p</span> =&gt;
        <span class="kr">match</span> p <span class="kr">return</span> leibnizO (place_data p) <span class="kr">with</span>
        | RAM a =&gt; spec.RAM s a
        | Reg r =&gt; spec.Reg s r
        | PC =&gt; spec.PC s
        | Flag f =&gt; spec.Flag s f
        <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚ä¢ |==&gt; <span class="kr">‚àÉ</span> <span class="nv">H</span> : atariGS Œ£, state_interp s ‚àó init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkd2"><span class="nb">set</span> ghost_resource : atari_camera := <span class="kr">fun</span> <span class="nv">l</span> =&gt; (‚óèE (f l) ‚ãÖ ‚óØE (f l)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚ä¢ |==&gt; <span class="kr">‚àÉ</span> <span class="nv">H</span> : atariGS Œ£, state_interp s ‚àó init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* Allocate the ghost resource. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkd3">iMod (own_alloc ghost_resource) <span class="kr">as</span> (name) <span class="s2">&quot;H&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚úì ghost_resource</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chkd4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br></div><label class="goal-separator" for="iris-v-chkd4"><hr></label><div class="goal-conclusion"><span class="s2">&quot;H&quot;</span> : own name ghost_resource
--------------------------------------‚àó
|==&gt; <span class="kr">‚àÉ</span> <span class="nv">H</span> : atariGS Œ£, state_interp s ‚àó init</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkd5">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚úì ghost_resource</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkd6"><span class="nb">move</span>=&gt; l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>place</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚úì ghost_resource l</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> auth_both_valid.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkd7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;H&quot;</span> : own name ghost_resource
--------------------------------------‚àó
|==&gt; <span class="kr">‚àÉ</span> <span class="nv">H</span> : atariGS Œ£, state_interp s ‚àó init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkd8">iModIntro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;H&quot;</span> : own name ghost_resource
--------------------------------------‚àó
<span class="kr">‚àÉ</span> <span class="nv">H</span> : atariGS Œ£, state_interp s ‚àó init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkd9"><span class="nb">set</span> atariGS0 := Build_atariGS Œ£ atariGpreS0 name.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;H&quot;</span> : own name ghost_resource
--------------------------------------‚àó
<span class="kr">‚àÉ</span> <span class="nv">H</span> : atariGS Œ£, state_interp s ‚àó init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkda">iExists (atariGS0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;H&quot;</span> : own name ghost_resource
--------------------------------------‚àó
state_interp s ‚àó init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* Half of the resource is given to the state interpretation. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkdb"><span class="nb">rewrite</span> own_op.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;H&quot;</span> : own name (<span class="kr">Œª</span> <span class="nv">x</span> : place, ‚óèE (f x)) ‚àó
      own name (<span class="kr">Œª</span> <span class="nv">x</span> : place, ‚óØE (f x))
--------------------------------------‚àó
state_interp s ‚àó init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkdc">iDestruct <span class="s2">&quot;H&quot;</span> <span class="kr">as</span> <span class="s2">&quot;[stateI H]&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;stateI&quot;</span> : own name (<span class="kr">Œª</span> <span class="nv">x</span> : place, ‚óèE (f x))
<span class="s2">&quot;H&quot;</span> : own name (<span class="kr">Œª</span> <span class="nv">x</span> : place, ‚óØE (f x))
--------------------------------------‚àó
state_interp s ‚àó init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkdd">iSplitL <span class="s2">&quot;stateI&quot;</span>; <span class="kp">first</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;H&quot;</span> : own name (<span class="kr">Œª</span> <span class="nv">x</span> : place, ‚óØE (f x))
--------------------------------------‚àó
init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* The other half needs to be split apart, to hand to the user. *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkde"><span class="nb">pose</span> (split_into_pointers f) <span class="kr">as</span> tmp;
        <span class="nb">unfold</span> atari_name, atariGS0 <span class="kr">in</span> tmp;
        iPoseProof (tmp <span class="kr">with</span> <span class="s2">&quot;H&quot;</span>) <span class="kr">as</span> <span class="s2">&quot;(PC&amp;N&amp;B&amp;V&amp;D&amp;I&amp;Z&amp;C&amp;Bytes)&quot;</span>;
        <span class="nb">clear</span> tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;PC&quot;</span> : PC ‚Ü¶ f PC
<span class="s2">&quot;N&quot;</span> : Flag spec.N ‚Ü¶ f (Flag spec.N)
<span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;Bytes&quot;</span> : [‚àó list] y ‚àà 
          (BytePlace &lt;$&gt; enum byte_place), y ‚Ü¶ 
          f y
--------------------------------------‚àó
init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkdf"><span class="kp">do</span> <span class="mi">4</span> <span class="nb">rewrite</span> fmap_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;PC&quot;</span> : PC ‚Ü¶ f PC
<span class="s2">&quot;N&quot;</span> : Flag spec.N ‚Ü¶ f (Flag spec.N)
<span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;Bytes&quot;</span> : [‚àó list] y ‚àà 
          (Reg X
           :: Reg Y
              :: Reg A
                 :: Reg SP
                    :: 
                    (BytePlace &lt;$&gt;
                    (RAM &lt;$&gt; enum (bv <span class="mi">7</span>)))), y ‚Ü¶ 
          f y
--------------------------------------‚àó
init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chke0">iDestruct <span class="s2">&quot;Bytes&quot;</span> <span class="kr">as</span> <span class="s2">&quot;(X&amp;Y&amp;A&amp;SP&amp;RAM)&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;PC&quot;</span> : PC ‚Ü¶ f PC
<span class="s2">&quot;N&quot;</span> : Flag spec.N ‚Ü¶ f (Flag spec.N)
<span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;X&quot;</span> : Reg X ‚Ü¶ f (Reg X)
<span class="s2">&quot;Y&quot;</span> : Reg Y ‚Ü¶ f (Reg Y)
<span class="s2">&quot;A&quot;</span> : Reg A ‚Ü¶ f (Reg A)
<span class="s2">&quot;SP&quot;</span> : Reg SP ‚Ü¶ f (Reg SP)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
init</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chke1"><span class="nb">rewrite</span> /init.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;PC&quot;</span> : PC ‚Ü¶ f PC
<span class="s2">&quot;N&quot;</span> : Flag spec.N ‚Ü¶ f (Flag spec.N)
<span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;X&quot;</span> : Reg X ‚Ü¶ f (Reg X)
<span class="s2">&quot;Y&quot;</span> : Reg Y ‚Ü¶ f (Reg Y)
<span class="s2">&quot;A&quot;</span> : Reg A ‚Ü¶ f (Reg A)
<span class="s2">&quot;SP&quot;</span> : Reg SP ‚Ü¶ f (Reg SP)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
PC ‚Ü¶ <span class="mi">61440</span>%bv ‚àó Reg X ‚Ü¶? ‚àó 
Reg Y ‚Ü¶? ‚àó Reg A ‚Ü¶? ‚àó 
Reg SP ‚Ü¶? ‚àó Flag spec.N ‚Ü¶? ‚àó 
Flag B ‚Ü¶? ‚àó Flag V ‚Ü¶? ‚àó 
Flag D ‚Ü¶? ‚àó Flag I ‚Ü¶ true ‚àó 
Flag spec.Z ‚Ü¶? ‚àó Flag C ‚Ü¶? ‚àó
([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chke2">iSplitL <span class="s2">&quot;PC&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;PC&quot;</span> : PC ‚Ü¶ f PC
--------------------------------------‚àó
PC ‚Ü¶ <span class="mi">61440</span>%bv</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chke3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><label class="goal-separator" for="iris-v-chke3"><hr></label><div class="goal-conclusion"><span class="s2">&quot;N&quot;</span> : Flag spec.N ‚Ü¶ f (Flag spec.N)
<span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;X&quot;</span> : Reg X ‚Ü¶ f (Reg X)
<span class="s2">&quot;Y&quot;</span> : Reg Y ‚Ü¶ f (Reg Y)
<span class="s2">&quot;A&quot;</span> : Reg A ‚Ü¶ f (Reg A)
<span class="s2">&quot;SP&quot;</span> : Reg SP ‚Ü¶ f (Reg SP)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Reg X ‚Ü¶? ‚àó Reg Y ‚Ü¶? ‚àó 
Reg A ‚Ü¶? ‚àó Reg SP ‚Ü¶? ‚àó 
Flag spec.N ‚Ü¶? ‚àó Flag B ‚Ü¶? ‚àó 
Flag V ‚Ü¶? ‚àó Flag D ‚Ü¶? ‚àó 
Flag I ‚Ü¶ true ‚àó Flag spec.Z ‚Ü¶? ‚àó 
Flag C ‚Ü¶? ‚àó ([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chke4">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;PC&quot;</span> : PC ‚Ü¶ f PC
--------------------------------------‚àó
PC ‚Ü¶ <span class="mi">61440</span>%bv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chke5"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;PC&quot;</span> : PC ‚Ü¶ spec.PC s
--------------------------------------‚àó
PC ‚Ü¶ <span class="mi">61440</span>%bv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chke6"><span class="nb">move</span>: (pc_init s s_initial) =&gt; [? [? [-&gt; [-&gt; -&gt;]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br><span><var>_x_, _x1_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;PC&quot;</span> : PC ‚Ü¶ spec.bv_concat <span class="mi">16</span>
              (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65532</span>))
              (rom.ROM (trunc <span class="mi">11</span> <span class="mi">65533</span>))
--------------------------------------‚àó
PC ‚Ü¶ <span class="mi">61440</span>%bv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chke7"><span class="nb">have</span> -&gt;: spec.bv_concat <span class="mi">16</span>
            (rom.ROM <span class="mi">0</span>x7fc) (rom.ROM <span class="mi">0</span>x7fd) = <span class="mi">0</span>xf000%bv
            <span class="bp">by</span> bv_simplify_arith.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br><span><var>_x_, _x1_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;PC&quot;</span> : PC ‚Ü¶ <span class="mi">61440</span>%bv
--------------------------------------‚àó
PC ‚Ü¶ <span class="mi">61440</span>%bv</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input">iExact <span class="s2">&quot;PC&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chke8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;N&quot;</span> : Flag spec.N ‚Ü¶ f (Flag spec.N)
<span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;X&quot;</span> : Reg X ‚Ü¶ f (Reg X)
<span class="s2">&quot;Y&quot;</span> : Reg Y ‚Ü¶ f (Reg Y)
<span class="s2">&quot;A&quot;</span> : Reg A ‚Ü¶ f (Reg A)
<span class="s2">&quot;SP&quot;</span> : Reg SP ‚Ü¶ f (Reg SP)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Reg X ‚Ü¶? ‚àó Reg Y ‚Ü¶? ‚àó 
Reg A ‚Ü¶? ‚àó Reg SP ‚Ü¶? ‚àó 
Flag spec.N ‚Ü¶? ‚àó Flag B ‚Ü¶? ‚àó 
Flag V ‚Ü¶? ‚àó Flag D ‚Ü¶? ‚àó 
Flag I ‚Ü¶ true ‚àó Flag spec.Z ‚Ü¶? ‚àó 
Flag C ‚Ü¶? ‚àó ([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chke9">iSplitL <span class="s2">&quot;X&quot;</span>; <span class="kp">first</span> (iExists _; iAssumption).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;N&quot;</span> : Flag spec.N ‚Ü¶ f (Flag spec.N)
<span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;Y&quot;</span> : Reg Y ‚Ü¶ f (Reg Y)
<span class="s2">&quot;A&quot;</span> : Reg A ‚Ü¶ f (Reg A)
<span class="s2">&quot;SP&quot;</span> : Reg SP ‚Ü¶ f (Reg SP)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Reg Y ‚Ü¶? ‚àó Reg A ‚Ü¶? ‚àó 
Reg SP ‚Ü¶? ‚àó Flag spec.N ‚Ü¶? ‚àó 
Flag B ‚Ü¶? ‚àó Flag V ‚Ü¶? ‚àó 
Flag D ‚Ü¶? ‚àó Flag I ‚Ü¶ true ‚àó 
Flag spec.Z ‚Ü¶? ‚àó Flag C ‚Ü¶? ‚àó
([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkea">iSplitL <span class="s2">&quot;Y&quot;</span>; <span class="kp">first</span> (iExists _; iAssumption).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;N&quot;</span> : Flag spec.N ‚Ü¶ f (Flag spec.N)
<span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;A&quot;</span> : Reg A ‚Ü¶ f (Reg A)
<span class="s2">&quot;SP&quot;</span> : Reg SP ‚Ü¶ f (Reg SP)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Reg A ‚Ü¶? ‚àó Reg SP ‚Ü¶? ‚àó 
Flag spec.N ‚Ü¶? ‚àó Flag B ‚Ü¶? ‚àó 
Flag V ‚Ü¶? ‚àó Flag D ‚Ü¶? ‚àó 
Flag I ‚Ü¶ true ‚àó Flag spec.Z ‚Ü¶? ‚àó 
Flag C ‚Ü¶? ‚àó ([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkeb">iSplitL <span class="s2">&quot;A&quot;</span>; <span class="kp">first</span> (iExists _; iAssumption).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;N&quot;</span> : Flag spec.N ‚Ü¶ f (Flag spec.N)
<span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;SP&quot;</span> : Reg SP ‚Ü¶ f (Reg SP)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Reg SP ‚Ü¶? ‚àó Flag spec.N ‚Ü¶? ‚àó 
Flag B ‚Ü¶? ‚àó Flag V ‚Ü¶? ‚àó 
Flag D ‚Ü¶? ‚àó Flag I ‚Ü¶ true ‚àó 
Flag spec.Z ‚Ü¶? ‚àó Flag C ‚Ü¶? ‚àó
([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkec">iSplitL <span class="s2">&quot;SP&quot;</span>; <span class="kp">first</span> (iExists _; iAssumption).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;N&quot;</span> : Flag spec.N ‚Ü¶ f (Flag spec.N)
<span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Flag spec.N ‚Ü¶? ‚àó Flag B ‚Ü¶? ‚àó 
Flag V ‚Ü¶? ‚àó Flag D ‚Ü¶? ‚àó 
Flag I ‚Ü¶ true ‚àó Flag spec.Z ‚Ü¶? ‚àó 
Flag C ‚Ü¶? ‚àó ([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chked">iSplitL <span class="s2">&quot;N&quot;</span>; <span class="kp">first</span> (iExists _; iAssumption).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;B&quot;</span> : Flag B ‚Ü¶ f (Flag B)
<span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Flag B ‚Ü¶? ‚àó Flag V ‚Ü¶? ‚àó 
Flag D ‚Ü¶? ‚àó Flag I ‚Ü¶ true ‚àó 
Flag spec.Z ‚Ü¶? ‚àó Flag C ‚Ü¶? ‚àó
([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkee">iSplitL <span class="s2">&quot;B&quot;</span>; <span class="kp">first</span> (iExists _; iAssumption).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;V&quot;</span> : Flag V ‚Ü¶ f (Flag V)
<span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Flag V ‚Ü¶? ‚àó Flag D ‚Ü¶? ‚àó 
Flag I ‚Ü¶ true ‚àó Flag spec.Z ‚Ü¶? ‚àó 
Flag C ‚Ü¶? ‚àó ([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkef">iSplitL <span class="s2">&quot;V&quot;</span>; <span class="kp">first</span> (iExists _; iAssumption).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;D&quot;</span> : Flag D ‚Ü¶ f (Flag D)
<span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Flag D ‚Ü¶? ‚àó Flag I ‚Ü¶ true ‚àó 
Flag spec.Z ‚Ü¶? ‚àó Flag C ‚Ü¶? ‚àó
([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkf0">iSplitL <span class="s2">&quot;D&quot;</span>; <span class="kp">first</span> (iExists _; iAssumption).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
<span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Flag I ‚Ü¶ true ‚àó Flag spec.Z ‚Ü¶? ‚àó 
Flag C ‚Ü¶? ‚àó ([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkf1">iSplitL <span class="s2">&quot;I&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
--------------------------------------‚àó
Flag I ‚Ü¶ true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chkf2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><label class="goal-separator" for="iris-v-chkf2"><hr></label><div class="goal-conclusion"><span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Flag spec.Z ‚Ü¶? ‚àó Flag C ‚Ü¶? ‚àó
([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkf3">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ f (Flag I)
--------------------------------------‚àó
Flag I ‚Ü¶ true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkf4"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ spec.Flag s I
--------------------------------------‚àó
Flag I ‚Ü¶ true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkf5"><span class="nb">pose</span> (init_interrupt_disable s s_initial) <span class="kr">as</span> tmp; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.Flag s I
‚Üí <span class="s2">&quot;I&quot;</span> : Flag I ‚Ü¶ spec.Flag s I
  --------------------------------------‚àó
  Flag I ‚Ü¶ true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span> (spec.Flag s I).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkf6">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;Z&quot;</span> : Flag spec.Z ‚Ü¶ f (Flag spec.Z)
<span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Flag spec.Z ‚Ü¶? ‚àó Flag C ‚Ü¶? ‚àó
([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkf7">iSplitL <span class="s2">&quot;Z&quot;</span>; <span class="kp">first</span> (iExists _; iAssumption).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;C&quot;</span> : Flag C ‚Ü¶ f (Flag C)
<span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
Flag C ‚Ü¶? ‚àó ([‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkf8">iSplitL <span class="s2">&quot;C&quot;</span>; <span class="kp">first</span> (iExists _; iAssumption).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;RAM&quot;</span> : [‚àó list] y ‚àà 
        (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
        f y
--------------------------------------‚àó
[‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), 
RAM addr ‚Ü¶?</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkf9">iStopProof.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([‚àó list] y ‚àà (BytePlace &lt;$&gt; (RAM &lt;$&gt; enum (bv <span class="mi">7</span>))), y ‚Ü¶ 
 f y) ‚ä¢ [‚àó list] addr ‚àà 
enum (bv <span class="mi">7</span>), RAM addr ‚Ü¶?</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkfa"><span class="kp">do</span> <span class="mi">2</span> <span class="nb">rewrite</span> big_sepL_fmap.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">([‚àó list] y ‚àà enum (bv <span class="mi">7</span>), RAM y ‚Ü¶ f (RAM y))
‚ä¢ [‚àó list] addr ‚àà enum (bv <span class="mi">7</span>), 
RAM addr ‚Ü¶?</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkfb"><span class="nb">apply</span> big_sepL_mono =&gt; _ a _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>atariGpreS0</var><span class="hyp-type"><b>: </b><span>atariGpreS Œ£</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>s_initial</var><span class="hyp-type"><b>: </b><span>initial s</span></span></span><br><span><var>f</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">p</span> : place,
  <span class="kr">match</span>
    p <span class="kr">as</span> p0 <span class="kr">return</span> (leibnizO (place_data p0))
  <span class="kr">with</span>
  | BytePlace b =&gt;
      <span class="kr">match</span>
        b <span class="kr">as</span> b0 <span class="kr">return</span> (leibnizO (place_data b0))
      <span class="kr">with</span>
      | RAM a =&gt; spec.RAM s a
      | Reg r =&gt; spec.Reg s r
      <span class="kr">end</span>
  | PC =&gt; spec.PC s
  | Flag f =&gt; spec.Flag s f
  <span class="kr">end</span></span></span><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">p</span> : place, leibnizO (place_data p)</span></span></span></span><br><span><var>ghost_resource</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">Œª</span> <span class="nv">l</span> : place, ‚óèE (f l) ‚ãÖ ‚óØE (f l)</span></span><span class="hyp-type"><b>: </b><span>atari_camera</span></span></span></span><br><span><var>name</var><span class="hyp-type"><b>: </b><span>gname</span></span></span><br><span><var>atariGS0</var><span><span class="hyp-body"><b>:= </b><span>{|
  atari_inG := atariGpreS0;
  atari_name := name
|}</span></span><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">RAM a ‚Ü¶ f (RAM a) ‚ä¢ RAM a ‚Ü¶?</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> iIntros; iExists _.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="adequacy">
<h1>Adequacy</h1>
<p>An <em>adequacy theorem</em> basically says
that proofs in the Iris logic are actually meaningful.</p>
<p>In our case, I'll prove that a specific Iris assertion implies
Dragster cannot be beaten in less than 5.57 seconds.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> iris.program_logic <span class="kn">Require Import</span> adequacy.</span></span></pre><p>Iris's adequacy machinery needs a bit more ghost state to function.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">langGS</span> <span class="nv">Œ£</span> := LangGS {
  lang_invGS : invGS Œ£;
  lang_atari :: atariGS Œ£;
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Global Instance</span> <span class="nf">langGS_irisGS</span> `{!langGS Œ£} : irisGS lang Œ£ := {
  iris_invGS := lang_invGS;
  state_interp s _ _ _ := iris.state_interp s;
  fork_post _ := <span class="kt">True</span>%I;
  num_laters_per_step _ := <span class="mi">0</span>;
  state_interp_mono _ _ _ _ := fupd_intro _ _
}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Class</span> <span class="nf">langGpreS</span> <span class="nv">Œ£</span> := LangPreG {
  lang_preG_iris :: invGpreS Œ£;
  lang_preG_atari :: atariGpreS Œ£;
}.</span></span></pre><p>I can now define <tt class="docutils literal">safe</tt>,
an Iris assertion saying the program will not crash.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">safe</span> `{!langGS Œ£} : iProp Œ£ :=
    wp NotStuck top Expr (<span class="kr">fun</span> <span class="nv">v</span> : iris.val =&gt; ‚åú<span class="kr">match</span> v <span class="kr">with</span> <span class="kr">end</span>‚åù)%I.</span></span></pre><p>And if the program cannot crash when started
at any valid initial state of the Atari,
then Dragster cannot be beaten in less than 5.57 seconds.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkfc"><span class="kn">Theorem</span> <span class="nf">iris_goal</span> <span class="nv">Œ£</span> `{!langGpreS Œ£} :
    (<span class="kr">forall</span> `{!langGS Œ£}, ‚ä¢ |={‚ä§}=&gt; init -‚àó safe) -&gt; <span class="kn">Goal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£, ‚ä¢ |={‚ä§}=&gt; init -‚àó safe) ‚Üí <span class="kn">Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkfd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£, ‚ä¢ |={‚ä§}=&gt; init -‚àó safe) ‚Üí <span class="kn">Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkfe"><span class="nb">move</span>=&gt; iris_proof.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kn">Goal</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chkff"><span class="nb">apply</span> no_crash_implies_goal =&gt; s0 s0_initial s reachable.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">not_stuck Expr s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk100"><span class="nb">suff</span>: adequate NotStuck Expr s0 (<span class="kr">fun</span> <span class="nv">v</span> <span class="nv">_</span> =&gt; <span class="kr">match</span> v <span class="kr">with</span> <span class="kr">end</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>) ‚Üí not_stuck Expr s</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk101" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br></div><label class="goal-separator" for="iris-v-chk101"><hr></label><div class="goal-conclusion">adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk102">{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>) ‚Üí not_stuck Expr s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk103"><span class="nb">move</span>=&gt; a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">not_stuck Expr s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk104"><span class="nb">eapply</span> adequate_not_stuck.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">adequate <span class="nl">?s</span> <span class="nl">?e1</span> <span class="nl">?œÉ1</span> <span class="nl">?œÜ</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="iris-v-chk105" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</span></span></span><br></div><label class="goal-separator" for="iris-v-chk105"><hr></label><div class="goal-conclusion"><span class="nl">?s</span> = NotStuck</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chk106" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</span></span></span><br></div><label class="goal-separator" for="iris-v-chk106"><hr></label><div class="goal-conclusion">rtc erased_step ([<span class="nl">?e1</span>], <span class="nl">?œÉ1</span>) (<span class="nl">?t2</span>, s)</div></blockquote><input class="alectryon-extra-goal-toggle" id="iris-v-chk107" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</span></span></span><br></div><label class="goal-separator" for="iris-v-chk107"><hr></label><div class="goal-conclusion">Expr ‚àà <span class="nl">?t2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk108">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">adequate <span class="nl">?s</span> <span class="nl">?e1</span> <span class="nl">?œÉ1</span> <span class="nl">?œÜ</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> a.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk109">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">NotStuck = NotStuck</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk10a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rtc erased_step ([Expr], s0) (<span class="nl">?t2</span>, s)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> reachable.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk10b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Expr ‚àà [Expr]</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk10c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">adequate NotStuck Expr s0
  (<span class="kr">Œª</span> (<span class="nv">v</span> : val lang) (<span class="nv">_</span> : state lang),
     <span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
     <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk10d"><span class="nb">refine</span> (wp_adequacy Œ£ lang NotStuck Expr s0 _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> (<span class="nv">Hinv</span> : invGS Œ£) (<span class="nv">Œ∫s</span> : list (observation lang)),
  ‚ä¢ |={‚ä§}=&gt;
      <span class="kr">‚àÉ</span> (<span class="nv">stateI</span> : state lang
                  ‚Üí list (observation lang) ‚Üí iProp Œ£) 
        (<span class="nv">fork_post</span> : val lang ‚Üí iProp Œ£),
        <span class="kr">let</span> <span class="nv">H</span> :=
          {|
            iris_invGS := Hinv;
            state_interp :=
              <span class="kr">Œª</span> (<span class="nv">œÉ</span> : state lang) 
                (<span class="nv">_</span> : nat) 
                (<span class="nv">Œ∫s0</span> : 
                 list (observation lang)) 
                (<span class="nv">_</span> : nat), 
                stateI œÉ Œ∫s0;
            fork_post := fork_post;
            num_laters_per_step := <span class="kr">Œª</span> <span class="nv">_</span> : nat, <span class="mi">0</span>;
            state_interp_mono :=
              <span class="kr">Œª</span> (<span class="nv">œÉ</span> : state lang) 
                (<span class="nv">_</span> : nat) 
                (<span class="nv">Œ∫s0</span> : 
                 list (observation lang)) 
                (<span class="nv">_</span> : nat), 
                fupd_intro ‚àÖ (stateI œÉ Œ∫s0)
          |} <span class="kr">in</span>
        stateI s0 Œ∫s ‚àó
        WP Expr
        {{ v, ‚åú<span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
               <span class="kr">end</span>‚åù }}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk10e"><span class="nb">move</span>=&gt; Hinv Œ∫s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>invGS Œ£</span></span></span><br><span><var>Œ∫s</var><span class="hyp-type"><b>: </b><span>list (observation lang)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">‚ä¢ |={‚ä§}=&gt;
    <span class="kr">‚àÉ</span> (<span class="nv">stateI</span> : state lang
                ‚Üí list (observation lang) ‚Üí iProp Œ£) 
      (<span class="nv">fork_post</span> : val lang ‚Üí iProp Œ£),
      <span class="kr">let</span> <span class="nv">H</span> :=
        {|
          iris_invGS := Hinv;
          state_interp :=
            <span class="kr">Œª</span> (<span class="nv">œÉ</span> : state lang) 
              (<span class="nv">_</span> : nat) 
              (<span class="nv">Œ∫s</span> : list (observation lang)) 
              (<span class="nv">_</span> : nat), 
              stateI œÉ Œ∫s;
          fork_post := fork_post;
          num_laters_per_step := <span class="kr">Œª</span> <span class="nv">_</span> : nat, <span class="mi">0</span>;
          state_interp_mono :=
            <span class="kr">Œª</span> (<span class="nv">œÉ</span> : state lang) 
              (<span class="nv">_</span> : nat) 
              (<span class="nv">Œ∫s</span> : list (observation lang)) 
              (<span class="nv">_</span> : nat), 
              fupd_intro ‚àÖ (stateI œÉ Œ∫s)
        |} <span class="kr">in</span>
      stateI s0 Œ∫s ‚àó
      WP Expr {{ v, ‚åú<span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
                     <span class="kr">end</span>‚åù }}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk10f">iMod (atari_init s0 s0_initial) <span class="kr">as</span> (atari) <span class="s2">&quot;[stateI init]&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>invGS Œ£</span></span></span><br><span><var>Œ∫s</var><span class="hyp-type"><b>: </b><span>list (observation lang)</span></span></span><br><span><var>atari</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;stateI&quot;</span> : iris.state_interp s0
<span class="s2">&quot;init&quot;</span> : init
--------------------------------------‚àó
|={‚ä§}=&gt;
  <span class="kr">‚àÉ</span> (<span class="nv">stateI</span> : state lang
              ‚Üí list (observation lang) ‚Üí iProp Œ£) 
    (<span class="nv">fork_post</span> : val lang ‚Üí iProp Œ£), 
    stateI s0 Œ∫s ‚àó
    WP Expr {{ v, ‚åú<span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
                   <span class="kr">end</span>‚åù }}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk110"><span class="nb">set</span> langGS0 := LangGS Œ£ Hinv atari.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>invGS Œ£</span></span></span><br><span><var>Œ∫s</var><span class="hyp-type"><b>: </b><span>list (observation lang)</span></span></span><br><span><var>atari</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>langGS0</var><span><span class="hyp-body"><b>:= </b><span>{| lang_invGS := Hinv; lang_atari := atari |}</span></span><span class="hyp-type"><b>: </b><span>langGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;stateI&quot;</span> : iris.state_interp s0
<span class="s2">&quot;init&quot;</span> : init
--------------------------------------‚àó
|={‚ä§}=&gt;
  <span class="kr">‚àÉ</span> (<span class="nv">stateI</span> : state lang
              ‚Üí list (observation lang) ‚Üí iProp Œ£) 
    (<span class="nv">fork_post</span> : val lang ‚Üí iProp Œ£), 
    stateI s0 Œ∫s ‚àó
    WP Expr {{ v, ‚åú<span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
                   <span class="kr">end</span>‚åù }}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk111">iMod (iris_proof _) <span class="kr">as</span> <span class="s2">&quot;iris_proof&quot;</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>invGS Œ£</span></span></span><br><span><var>Œ∫s</var><span class="hyp-type"><b>: </b><span>list (observation lang)</span></span></span><br><span><var>atari</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>langGS0</var><span><span class="hyp-body"><b>:= </b><span>{| lang_invGS := Hinv; lang_atari := atari |}</span></span><span class="hyp-type"><b>: </b><span>langGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;stateI&quot;</span> : iris.state_interp s0
<span class="s2">&quot;init&quot;</span> : init
<span class="s2">&quot;iris_proof&quot;</span> : init -‚àó safe
--------------------------------------‚àó
|={‚ä§}=&gt;
  <span class="kr">‚àÉ</span> (<span class="nv">stateI</span> : state lang
              ‚Üí list (observation lang) ‚Üí iProp Œ£) 
    (<span class="nv">fork_post</span> : val lang ‚Üí iProp Œ£), 
    stateI s0 Œ∫s ‚àó
    WP Expr {{ v, ‚åú<span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
                   <span class="kr">end</span>‚åù }}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk112">iModIntro.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>invGS Œ£</span></span></span><br><span><var>Œ∫s</var><span class="hyp-type"><b>: </b><span>list (observation lang)</span></span></span><br><span><var>atari</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>langGS0</var><span><span class="hyp-body"><b>:= </b><span>{| lang_invGS := Hinv; lang_atari := atari |}</span></span><span class="hyp-type"><b>: </b><span>langGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;stateI&quot;</span> : iris.state_interp s0
<span class="s2">&quot;init&quot;</span> : init
<span class="s2">&quot;iris_proof&quot;</span> : init -‚àó safe
--------------------------------------‚àó
<span class="kr">‚àÉ</span> (<span class="nv">stateI</span> : state lang
            ‚Üí list (observation lang) ‚Üí iProp Œ£) 
  (<span class="nv">fork_post</span> : val lang ‚Üí iProp Œ£), 
  stateI s0 Œ∫s ‚àó
  WP Expr {{ v, ‚åú<span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
                 <span class="kr">end</span>‚åù }}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk113">iExists (<span class="kr">fun</span> <span class="nv">s</span> <span class="nv">_</span> =&gt; iris.state_interp s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>invGS Œ£</span></span></span><br><span><var>Œ∫s</var><span class="hyp-type"><b>: </b><span>list (observation lang)</span></span></span><br><span><var>atari</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>langGS0</var><span><span class="hyp-body"><b>:= </b><span>{| lang_invGS := Hinv; lang_atari := atari |}</span></span><span class="hyp-type"><b>: </b><span>langGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;stateI&quot;</span> : iris.state_interp s0
<span class="s2">&quot;init&quot;</span> : init
<span class="s2">&quot;iris_proof&quot;</span> : init -‚àó safe
--------------------------------------‚àó
<span class="kr">‚àÉ</span> <span class="nv">fork_post</span> : val lang ‚Üí iProp Œ£,
  iris.state_interp s0 ‚àó
  WP Expr {{ v, ‚åú<span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
                 <span class="kr">end</span>‚åù }}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk114">iExists (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="kt">True</span>%I).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>invGS Œ£</span></span></span><br><span><var>Œ∫s</var><span class="hyp-type"><b>: </b><span>list (observation lang)</span></span></span><br><span><var>atari</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>langGS0</var><span><span class="hyp-body"><b>:= </b><span>{| lang_invGS := Hinv; lang_atari := atari |}</span></span><span class="hyp-type"><b>: </b><span>langGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;stateI&quot;</span> : iris.state_interp s0
<span class="s2">&quot;init&quot;</span> : init
<span class="s2">&quot;iris_proof&quot;</span> : init -‚àó safe
--------------------------------------‚àó
iris.state_interp s0 ‚àó
WP Expr {{ v, ‚åú<span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
               <span class="kr">end</span>‚åù }}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="iris-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="iris-v-chk115">iSplitL <span class="s2">&quot;stateI&quot;</span>; <span class="kp">first</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>Œ£</var><span class="hyp-type"><b>: </b><span>gFunctors</span></span></span><br><span><var>langGpreS0</var><span class="hyp-type"><b>: </b><span>langGpreS Œ£</span></span></span><br><span><var>iris_proof</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">langGS0</span> : langGS Œ£,
  ‚ä¢ |={‚ä§}=&gt; init -‚àó safe</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>spec.state</span></span></span><br><span><var>s0_initial</var><span class="hyp-type"><b>: </b><span>initial s0</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>state lang</span></span></span><br><span><var>reachable</var><span class="hyp-type"><b>: </b><span>rtc erased_step ([Expr], s0) ([Expr], s)</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>invGS Œ£</span></span></span><br><span><var>Œ∫s</var><span class="hyp-type"><b>: </b><span>list (observation lang)</span></span></span><br><span><var>atari</var><span class="hyp-type"><b>: </b><span>atariGS Œ£</span></span></span><br><span><var>langGS0</var><span><span class="hyp-body"><b>:= </b><span>{| lang_invGS := Hinv; lang_atari := atari |}</span></span><span class="hyp-type"><b>: </b><span>langGS Œ£</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="s2">&quot;init&quot;</span> : init
<span class="s2">&quot;iris_proof&quot;</span> : init -‚àó safe
--------------------------------------‚àó
WP Expr {{ v, ‚åú<span class="kr">match</span> v <span class="kr">return</span> <span class="kt">Prop</span> <span class="kr">with</span>
               <span class="kr">end</span>‚åù }}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> iApply <span class="s2">&quot;iris_proof&quot;</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>This is a crucial theorem. It says we can prove
the minimum Dragster time by proving the Iris assertion
<tt class="docutils literal"><span class="pre">|={‚ä§}=&gt;</span> init <span class="pre">-‚àó</span> safe</tt>.</p>
<p>But to do this, we will need ways to work with <tt class="docutils literal">safe</tt>.</p>
</div>
<div class="section" id="working-with-safe">
<h1>Working with Safe</h1>
<p>To be continued...</p>
</div>
</div>
</div></body>
</html>
