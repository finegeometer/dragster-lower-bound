<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Instruction</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.18.0+0.18.1. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="instruction">
<h1 class="title">Instruction</h1>

<p>The 6502 has a lot of opcodes.
About a hundred and thirty that I'm modeling, and a few I'm not.
In this file, I condense this down to something managable.</p>
<p>This file comes in three parts.
1. I define a language of instructions.
2. I define its behavior.
3. I prove its behavior matches the Atari's spec.</p>
<div class="section" id="part-1-language">
<h1>Part 1: Language</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk0"><span class="kn">From</span> theories <span class="kn">Require Import</span> spec.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">[Loading ML file ssrmatching_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ssreflect_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file ring_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file zify_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file micromega_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote><blockquote class="alectryon-message">[Loading ML file btauto_plugin.cmxs (<span class="nb">using</span> legacy method) ... <span class="bp">done</span>]</blockquote></div></div></small></span></pre><div class="section" id="addressing-modes">
<h2>Addressing Modes</h2>
<p>A hundred and thirty opcodes sounds scary.
But much of the variety comes from the proliferation of <em>addressing modes</em>;
places the instruction can find the value to operate on.</p>
<p>Most of these pick out a memory address. I'll call these &quot;memory addressing modes&quot;.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">mem_mode</span> :=
| Imm
| Abs (r : option reg)
| Zpg (r : option reg)
| XInd
| IndY
| Rel
.</span></span></pre><p>But an addressing mode can also pick out a register.</p>
<p>Only one addressing mode actually does this: the &quot;Accumulator&quot; mode.
Except that isn't entirely true.
While instructions like <tt class="docutils literal">INX</tt> and <tt class="docutils literal">INY</tt> technically don't use an addressing mode,
it's simpler to think of them as addressing the <code class="highlight coq"><span class="n">X</span></code> and <code class="highlight coq"><span class="n">Y</span></code> registers.</p>
<p>So I'll say there's an addressing mode for each register.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">mode</span> :=
| RegMode : reg -&gt; mode
| MemMode : mem_mode -&gt; mode
.</span></span></pre></div>
<div class="section" id="instructions">
<h2>Instructions</h2>
<p>Now that that's handled, what types of instructions are there?</p>
<p>First, there's the control flow instructions;
those where the program counter does something other than
simply proceed to the next instruction.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">control</span> :=
<span class="c">(* Branch if flag `f` is set to `val`. *)</span>
| Branch (f : flag) (val : bool)
| Jmp
| Jsr
| Rts
.</span></span></pre><p>Then, there are the rest. Most of these follow a simple pattern:</p>
<ul>
<li><p class="first">Use an addressing mode to determine a location, <tt class="docutils literal">l</tt>.</p>
<p>Note that this might not be the addressing mode you'd expect.
For an operation like <code class="highlight coq"><span class="n">ADC</span> <span class="o">$</span><span class="mi">0000</span></code>,
this is the accumulator rather than the memory address.</p>
<p>This is certainly a nonstandard way to think about this,
but it seems to work well.</p>
</li>
<li><p class="first">Reads a value from <code class="highlight coq"><span class="n">l</span></code>.</p>
</li>
<li><p class="first">Does some computation with that value.
This may involve doing more reads, and may set the C or V flags.</p>
</li>
<li><p class="first">Optionally, set the N and Z flags based on the result.</p>
</li>
<li><p class="first">Optionally, write the result back to <code class="highlight coq"><span class="n">l</span></code>.</p>
</li>
</ul>
<p>But there are also a few oddballs, like the flag-setting instructions, or <tt class="docutils literal">NOP</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">binop</span> := And | Or | Xor | Adc | Sbc | Cmp | Bit | Mov.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">operation</span> :=
| Binop (_ : binop) (_ : mode)
| Inc
| Dec
| ShiftL (roll : bool)
| ShiftR (roll : bool)
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">instr</span> :=
| Control (_ : control)
| Typical (_ : mode) (_ : operation) (setNZ : bool)
| SetFlag (_ : flag) (_ : bool)
| Nop
.</span></span></pre></div>
</div>
<div class="section" id="part-2-semantics">
<h1>Part 2: Semantics</h1>
<p>This is all well and good. But we need to explain
what the instructiond actually mean! Otherwise it's useless.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> stdpp <span class="kn">Require Import</span> ssreflect propset unstable.bitvector.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local</span> <span class="kn">Open Scope</span> bv_scope.</span></span></pre><p>For ease of programming, let's specify nondeterministic operations
as returning the set of things they might possibly output.</p>
<p>For example, fetching a value from memory can nondeterministic.
Sure, ROM and RAM are predictable, but address 0x0280 points to the joystick!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fetch</span> (<span class="nv">s</span> : state) (<span class="nv">addr</span> : bv <span class="mi">16</span>) : propset (bv <span class="mi">8</span>) :=
    {[ w | fetch s addr w ]}.</span></span></pre><p>After defining a helper for fetching 16-bit words,
it's easy to write down the behavior of all the memory addressing modes.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fetch16</span> (<span class="nv">s</span> : state) (<span class="nv">a1</span> <span class="nv">a2</span> : bv <span class="mi">16</span>) : propset (bv <span class="mi">16</span>) :=
    w1 ‚Üê fetch s a1;
    w2 ‚Üê fetch s a2;
    {[ spec.bv_concat <span class="mi">16</span> w1 w2 ]}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mem_mode_addr</span> (<span class="nv">s</span> : state) (<span class="nv">m</span> : mem_mode) : propset (bv <span class="mi">16</span>) :=
    <span class="kr">match</span> m <span class="kr">with</span>
    | Imm =&gt; {[ PC s `+Z` <span class="mi">1</span> ]}
    | Abs r =&gt;
        a ‚Üê fetch16 s (PC s `+Z` <span class="mi">1</span>) (PC s `+Z` <span class="mi">2</span>);
        {[ <span class="kr">if</span> r <span class="kr">is</span> Some r <span class="kr">then</span> a + bv_zero_extend <span class="mi">16</span> (Reg s r) <span class="kr">else</span> a ]}
    | Zpg r =&gt;
        a ‚Üê fetch s (PC s `+Z` <span class="mi">1</span>);
        {[ bv_zero_extend <span class="mi">16</span> (<span class="kr">if</span> r <span class="kr">is</span> Some r <span class="kr">then</span> a + Reg s r <span class="kr">else</span> a) ]}
    | XInd =&gt;
        a ‚Üê fetch s (PC s `+Z` <span class="mi">1</span>);
        <span class="kr">let</span> <span class="nv">b</span> := a + Reg s X <span class="kr">in</span>
        fetch16 s (bv_zero_extend <span class="mi">16</span> b) (bv_zero_extend <span class="mi">16</span> (b + <span class="mi">1</span>))
    | IndY =&gt;
        a ‚Üê fetch s (PC s `+Z` <span class="mi">1</span>);
        b ‚Üê fetch16 s (bv_zero_extend <span class="mi">16</span> a) (bv_zero_extend <span class="mi">16</span> (a + <span class="mi">1</span>));
        {[ b + bv_zero_extend <span class="mi">16</span> (Reg s Y) ]}
    | Rel =&gt; 
        a ‚Üê fetch s (PC s `+Z` <span class="mi">1</span>);
        {[ (PC s `+Z` <span class="mi">2</span>) + bv_sign_extend <span class="mi">16</span> a ]}
    <span class="kr">end</span>.</span></span></pre><p>General addressing modes are no harder; we just need the concept of a location that's either in a register or in memory.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">loc</span> := RegLoc : reg -&gt; loc | MemLoc : bv <span class="mi">16</span> -&gt; loc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mode_loc</span> (<span class="nv">s</span> : state) (<span class="nv">m</span> : mode) : propset loc :=
    <span class="kr">match</span> m <span class="kr">with</span>
    | RegMode r =&gt; {[ RegLoc r ]}
    | MemMode m =&gt; MemLoc &lt;$&gt; mem_mode_addr s m
    <span class="kr">end</span>.</span></span></pre><p>Now for the instructions.</p>
<p>Let's start with the control flow.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">run_control</span> (<span class="nv">Œπ</span> : control) (<span class="nv">s</span> : state) : propset state :=
    <span class="kr">match</span> Œπ <span class="kr">with</span>
    | Branch f v =&gt;
        <span class="kr">if</span> decide (Flag s f = v)
        <span class="kr">then</span>
            addr ‚Üê mem_mode_addr s Rel;
            {[ {|
                PC := addr;
                Reg := Reg s;
                Flag := Flag s;
                RAM := RAM s;
            |} ]}
        <span class="kr">else</span> {[ {|
            PC := PC s `+Z` <span class="mi">2</span>;
            Reg := Reg s;
            Flag := Flag s;
            RAM := RAM s;
        |} ]}
    | Jmp =&gt;
        addr ‚Üê mem_mode_addr s (Abs None);
        {[ {|
            PC := addr;
            Reg := Reg s;
            Flag := Flag s;
            RAM := RAM s;
        |} ]}
    | Jsr =&gt;
        addr ‚Üê mem_mode_addr s (Abs None);
        {[ {|
            PC := addr;
            Reg := <span class="kr">fun</span> <span class="nv">r</span> =&gt;
                <span class="kr">if</span> reg_eqb r SP
                <span class="kr">then</span> Reg s SP `-Z` <span class="mi">2</span>
                <span class="kr">else</span> Reg s r;
            Flag := Flag s;
            RAM :=
                <span class="kr">let</span> <span class="nv">pc</span> := PC s `-Z` <span class="mi">1</span> <span class="kr">in</span>
                write
                    (bv_zero_extend <span class="mi">16</span> (Reg s SP `-Z` <span class="mi">1</span>))
                    (bv_extract <span class="mi">0</span> <span class="mi">8</span> pc)
                    (write
                        (bv_zero_extend <span class="mi">16</span> (Reg s SP))
                        (bv_extract <span class="mi">0</span> <span class="mi">8</span> pc)
                        (RAM s));
        |} ]}
    | Rts =&gt;
        addr ‚Üê fetch16 s
            (bv_zero_extend <span class="mi">16</span> (Reg s SP `+Z` <span class="mi">1</span>))
            (bv_zero_extend <span class="mi">16</span> (Reg s SP `+Z` <span class="mi">2</span>));
        {[ {|
            PC := addr `+Z` <span class="mi">1</span>;
            Reg := <span class="kr">fun</span> <span class="nv">r</span> =&gt;
                <span class="kr">if</span> reg_eqb r SP
                <span class="kr">then</span> Reg s SP `+Z` <span class="mi">2</span>
                <span class="kr">else</span> Reg s r;
            Flag := Flag s;
            RAM := RAM s;
        |} ]}
    <span class="kr">end</span>.</span></span></pre><p>For the rest of the instructions, we need to know how much space
they take up, so we know where to find the next instruction.</p>
<p>Fortunately, that's simple to calculate.
The opcode itself takes one byte.
Then any remaining bytes are inputs to the addressing mode.</p>
<p>There is the question of which addressing mode,
since I'm nonstandardly treating e.g. <tt class="docutils literal">ADC $0000</tt>
as using both the accumulator and absolute modes.
The answer is that one of them will always have length zero, so use the other.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="c">(* How many bytes of input does the addressing mode take? *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Definition</span> <span class="nf">mode_len</span> (<span class="nv">l</span> : mode) : nat :=
    <span class="kr">match</span> l <span class="kr">with</span>
    | RegMode _ =&gt; <span class="mi">0</span>
    | MemMode Imm =&gt; <span class="mi">1</span>
    | MemMode (Abs _) =&gt; <span class="mi">2</span>
    | MemMode (Zpg _) =&gt; <span class="mi">1</span>
    | MemMode XInd =&gt; <span class="mi">1</span>
    | MemMode IndY =&gt; <span class="mi">1</span>
    | MemMode Rel =&gt; <span class="mi">1</span>
    <span class="kr">end</span>.</span></span></pre><p>Next, let's tackle the typical instructions.
We'll start with the operations.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">run_binop</span> (<span class="nv">op</span> : binop) (<span class="nv">s</span> : state)
    (<span class="nv">w1</span> <span class="nv">w2</span> : bv <span class="mi">8</span>) : propset ((bv <span class="mi">8</span> * bool) * bool) :=
    <span class="kr">match</span> op <span class="kr">with</span>
    | And =&gt; {[ ((bv_and w1 w2, Flag s C), Flag s V) ]}
    | Or  =&gt; {[ ((bv_or  w1 w2, Flag s C), Flag s V) ]}
    | Xor =&gt; {[ ((bv_xor w1 w2, Flag s C), Flag s V) ]}
    | Adc =&gt;
        <span class="kr">if</span> Flag s D
        <span class="kr">then</span>
            v ‚Üê ‚ä§;
            wc ‚Üê {[wc|ADC_decimal_relation (Flag s C) w1 w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span>]};
            {[ (wc, v) ]}
        <span class="kr">else</span> 
            <span class="kr">let</span> <span class="nv">wc</span> := spec.add_with_carry (Flag s C) w1 w2 <span class="kr">in</span>
            <span class="kr">let</span> <span class="nv">v</span>:=negb(bv_signed wc.<span class="mi">1</span> =? bv_signed w1 + bv_signed w2)%Z
            <span class="kr">in</span> {[ (wc, v) ]}
    | Sbc =&gt;
        <span class="kr">if</span> Flag s D
        <span class="kr">then</span>
            v ‚Üê ‚ä§;
            wc ‚Üê {[wc|SBC_decimal_relation (Flag s C) w1 w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span>]};
            {[ (wc, v) ]}
        <span class="kr">else</span> 
            <span class="kr">let</span> <span class="nv">wc</span> := spec.sub_with_inverted_borrow (Flag s C) w1 w2 <span class="kr">in</span>
            <span class="kr">let</span> <span class="nv">v</span>:=negb(bv_signed wc.<span class="mi">1</span> =? bv_signed w1 - bv_signed w2)%Z
            <span class="kr">in</span> {[ (wc, v) ]}
    | Cmp =&gt; {[ (spec.sub_with_inverted_borrow true w1 w2, Flag s V) ]}
    | Bit =&gt;
        <span class="kr">let</span> <span class="nv">w</span> := bv_and w1 w2 <span class="kr">in</span>
        {[ ((w, Flag s C), bit <span class="mi">6</span> w) ]}
    | Mov =&gt; {[ ((w2, Flag s C), Flag s V) ]}
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">read</span> (<span class="nv">s</span> : state) (<span class="nv">l</span> : loc) : propset (bv <span class="mi">8</span>) :=
    <span class="kr">match</span> l <span class="kr">with</span>
    | RegLoc r =&gt; {[ Reg s r ]}
    | MemLoc addr =&gt; fetch s addr
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">run_operation</span> (<span class="nv">op</span> : operation) (<span class="nv">s</span> : state)
    (<span class="nv">w</span> : bv <span class="mi">8</span>) : propset ((bv <span class="mi">8</span> * bool) * bool) :=
    <span class="kr">match</span> op <span class="kr">with</span>
    | Binop op m =&gt;
        l ‚Üê mode_loc s m;
        w2 ‚Üê read s l;
        run_binop op s w w2
    | Inc =&gt; {[ ((w `+Z` <span class="mi">1</span>, Flag s C), Flag s V) ]}
    | Dec =&gt; {[ ((w `-Z` <span class="mi">1</span>, Flag s C), Flag s V) ]}
    | ShiftL roll =&gt;
        <span class="kr">let</span> <span class="nv">shift_in</span> := <span class="kr">if</span> roll <span class="kr">then</span> Flag s C <span class="kr">else</span> false <span class="kr">in</span>
        wc ‚Üê
            {[ out
            | spec.bv_concat <span class="mi">9</span> out.<span class="mi">1</span> (bool_to_bv <span class="mi">1</span> out.<span class="mi">2</span>)
            = spec.bv_concat <span class="mi">9</span> (bool_to_bv <span class="mi">1</span> shift_in) w
            ]};
        {[ (wc, Flag s V) ]}
    | ShiftR roll =&gt;
        <span class="kr">let</span> <span class="nv">shift_in</span> := <span class="kr">if</span> roll <span class="kr">then</span> Flag s C <span class="kr">else</span> false <span class="kr">in</span>
        wc ‚Üê
            {[ out
            | spec.bv_concat <span class="mi">9</span> (bool_to_bv <span class="mi">1</span> out.<span class="mi">2</span>) out.<span class="mi">1</span>
            = spec.bv_concat <span class="mi">9</span> w (bool_to_bv <span class="mi">1</span> shift_in)
            ]};
        {[ (wc, Flag s V) ]}
    <span class="kr">end</span>.</span></span></pre><p>Finally, we implement <tt class="docutils literal">run_instr</tt>, which specifies exactly what it means to run an instruction.
* Control instructions were implemented above.
* SetFlag and Nop are simple.
* For typical instructions, this is rather long, but should mirror the descriptions I gave in Part 1.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">run_instr</span> (<span class="nv">i</span> : instr) (<span class="nv">s</span> : state) : propset state :=
    <span class="kr">match</span> i <span class="kr">with</span>
    | Control i =&gt; run_control i s
    | SetFlag f val =&gt;
        {[ {|
            PC := PC s `+Z` <span class="mi">1</span>;
            Reg := Reg s;
            Flag := <span class="kr">fun</span> <span class="nv">f&#39;</span> =&gt;
                <span class="kr">if</span> flag_eqb f f&#39;
                <span class="kr">then</span> val
                <span class="kr">else</span> Flag s f&#39;;
            RAM := RAM s;
        |} ]}
    | Nop =&gt;
        {[ {|
            PC := PC s `+Z` <span class="mi">1</span>;
            Reg := Reg s;
            Flag := Flag s;
            RAM := RAM s;
        |} ]}
    | Typical m op setNZ =&gt;
        l ‚Üê mode_loc s m;
        w ‚Üê read s l;
        computed ‚Üê run_operation op s w;
        <span class="kr">let</span>: ((w, c), v) := computed <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">len</span> :=
            Z.of_nat (S (Nat.max (mode_len m)
                <span class="kr">match</span> op <span class="kr">with</span>
                | Binop _ m&#39; =&gt; mode_len m&#39;
                | _ =&gt; <span class="mi">0</span>
                <span class="kr">end</span>))
        <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">write_back</span> :=
            <span class="kr">match</span> op <span class="kr">with</span>
            | Binop (Cmp | Bit) _ =&gt; false
            | _ =&gt; true
            <span class="kr">end</span>
        <span class="kr">in</span>
        {[ {|
            PC := PC s `+Z` len;
            Reg :=
                <span class="kr">match</span> write_back, l <span class="kr">with</span>
                | true, RegLoc r =&gt; <span class="kr">fun</span> <span class="nv">r&#39;</span> =&gt;
                    <span class="kr">if</span> reg_eqb r r&#39; <span class="kr">then</span> w <span class="kr">else</span> Reg s r&#39;
                | _, _ =&gt; Reg s
                <span class="kr">end</span>;
            RAM :=
                <span class="kr">match</span> write_back, l <span class="kr">with</span>
                | _, MemLoc a =&gt; write a w (RAM s)
                | _, _ =&gt; RAM s
                <span class="kr">end</span>;
            Flag := <span class="kr">fun</span> <span class="nv">f</span> =&gt;
                <span class="kr">match</span> setNZ, f <span class="kr">with</span>
                | true, spec.N =&gt; bit <span class="mi">7</span> w
                | true, spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | _, spec.C =&gt; c
                | _, spec.V =&gt; v
                | _, _ =&gt; Flag s f
                <span class="kr">end</span>;
        |} ]}
    <span class="kr">end</span>.</span></span></pre></div>
<div class="section" id="part-3-correctness">
<h1>Part 3: Correctness</h1>
<p>The language has been defined.
But for this to mean anything, we need to relate it back to the 6502.</p>
<p>To start, let's assign to each (valid) 6502 opcode its corresponding instruction in our language.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">Zpg0</span> := (Zpg None).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">ZpgX</span> := (Zpg (Some X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">ZpgY</span> := (Zpg (Some Y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">Abs0</span> := (Abs None).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">AbsX</span> := (Abs (Some X)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">AbsY</span> := (Abs (Some Y)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">RegA</span> := (RegMode A).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">RegX</span> := (RegMode X).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Notation</span> <span class="nf">RegY</span> := (RegMode Y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Local Coercion</span> <span class="nf">MemMode</span> : mem_mode &gt;-&gt; mode.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">parse_instr</span> (<span class="nv">opcode</span> : bv <span class="mi">8</span>) : option instr :=
    <span class="kr">match</span> opcode <span class="kr">with</span>
    <span class="c">(* ......01 *)</span>
    | <span class="mi">0</span>x01 =&gt; Some (Typical RegA (Binop Or XInd) true)
    | <span class="mi">0</span>x05 =&gt; Some (Typical RegA (Binop Or Zpg0) true)
    | <span class="mi">0</span>x09 =&gt; Some (Typical RegA (Binop Or Imm ) true)
    | <span class="mi">0</span>x0d =&gt; Some (Typical RegA (Binop Or Abs0) true)
    | <span class="mi">0</span>x11 =&gt; Some (Typical RegA (Binop Or IndY) true)
    | <span class="mi">0</span>x15 =&gt; Some (Typical RegA (Binop Or ZpgX) true)
    | <span class="mi">0</span>x19 =&gt; Some (Typical RegA (Binop Or AbsY) true)
    | <span class="mi">0</span>x1d =&gt; Some (Typical RegA (Binop Or AbsX) true)

    | <span class="mi">0</span>x21 =&gt; Some (Typical RegA (Binop And XInd) true)
    | <span class="mi">0</span>x25 =&gt; Some (Typical RegA (Binop And Zpg0) true)
    | <span class="mi">0</span>x29 =&gt; Some (Typical RegA (Binop And Imm ) true)
    | <span class="mi">0</span>x2d =&gt; Some (Typical RegA (Binop And Abs0) true)
    | <span class="mi">0</span>x31 =&gt; Some (Typical RegA (Binop And IndY) true)
    | <span class="mi">0</span>x35 =&gt; Some (Typical RegA (Binop And ZpgX) true)
    | <span class="mi">0</span>x39 =&gt; Some (Typical RegA (Binop And AbsY) true)
    | <span class="mi">0</span>x3d =&gt; Some (Typical RegA (Binop And AbsX) true)

    | <span class="mi">0</span>x41 =&gt; Some (Typical RegA (Binop Xor XInd) true)
    | <span class="mi">0</span>x45 =&gt; Some (Typical RegA (Binop Xor Zpg0) true)
    | <span class="mi">0</span>x49 =&gt; Some (Typical RegA (Binop Xor Imm ) true)
    | <span class="mi">0</span>x4d =&gt; Some (Typical RegA (Binop Xor Abs0) true)
    | <span class="mi">0</span>x51 =&gt; Some (Typical RegA (Binop Xor IndY) true)
    | <span class="mi">0</span>x55 =&gt; Some (Typical RegA (Binop Xor ZpgX) true)
    | <span class="mi">0</span>x59 =&gt; Some (Typical RegA (Binop Xor AbsY) true)
    | <span class="mi">0</span>x5d =&gt; Some (Typical RegA (Binop Xor AbsX) true)

    | <span class="mi">0</span>x61 =&gt; Some (Typical RegA (Binop Adc XInd) true)
    | <span class="mi">0</span>x65 =&gt; Some (Typical RegA (Binop Adc Zpg0) true)
    | <span class="mi">0</span>x69 =&gt; Some (Typical RegA (Binop Adc Imm ) true)
    | <span class="mi">0</span>x6d =&gt; Some (Typical RegA (Binop Adc Abs0) true)
    | <span class="mi">0</span>x71 =&gt; Some (Typical RegA (Binop Adc IndY) true)
    | <span class="mi">0</span>x75 =&gt; Some (Typical RegA (Binop Adc ZpgX) true)
    | <span class="mi">0</span>x79 =&gt; Some (Typical RegA (Binop Adc AbsY) true)
    | <span class="mi">0</span>x7d =&gt; Some (Typical RegA (Binop Adc AbsX) true)

    | <span class="mi">0</span>x81 =&gt; Some (Typical XInd (Binop Mov RegA) false)
    | <span class="mi">0</span>x85 =&gt; Some (Typical Zpg0 (Binop Mov RegA) false)
    | <span class="mi">0</span>x8d =&gt; Some (Typical Abs0 (Binop Mov RegA) false)
    | <span class="mi">0</span>x91 =&gt; Some (Typical IndY (Binop Mov RegA) false)
    | <span class="mi">0</span>x95 =&gt; Some (Typical ZpgX (Binop Mov RegA) false)
    | <span class="mi">0</span>x99 =&gt; Some (Typical AbsY (Binop Mov RegA) false)
    | <span class="mi">0</span>x9d =&gt; Some (Typical AbsX (Binop Mov RegA) false)

    | <span class="mi">0</span>xa1 =&gt; Some (Typical RegA (Binop Mov XInd) true)
    | <span class="mi">0</span>xa5 =&gt; Some (Typical RegA (Binop Mov Zpg0) true)
    | <span class="mi">0</span>xa9 =&gt; Some (Typical RegA (Binop Mov Imm ) true)
    | <span class="mi">0</span>xad =&gt; Some (Typical RegA (Binop Mov Abs0) true)
    | <span class="mi">0</span>xb1 =&gt; Some (Typical RegA (Binop Mov IndY) true)
    | <span class="mi">0</span>xb5 =&gt; Some (Typical RegA (Binop Mov ZpgX) true)
    | <span class="mi">0</span>xb9 =&gt; Some (Typical RegA (Binop Mov AbsY) true)
    | <span class="mi">0</span>xbd =&gt; Some (Typical RegA (Binop Mov AbsX) true)

    | <span class="mi">0</span>xc1 =&gt; Some (Typical RegA (Binop Cmp XInd) true)
    | <span class="mi">0</span>xc5 =&gt; Some (Typical RegA (Binop Cmp Zpg0) true)
    | <span class="mi">0</span>xc9 =&gt; Some (Typical RegA (Binop Cmp Imm ) true)
    | <span class="mi">0</span>xcd =&gt; Some (Typical RegA (Binop Cmp Abs0) true)
    | <span class="mi">0</span>xd1 =&gt; Some (Typical RegA (Binop Cmp IndY) true)
    | <span class="mi">0</span>xd5 =&gt; Some (Typical RegA (Binop Cmp ZpgX) true)
    | <span class="mi">0</span>xd9 =&gt; Some (Typical RegA (Binop Cmp AbsY) true)
    | <span class="mi">0</span>xdd =&gt; Some (Typical RegA (Binop Cmp AbsX) true)

    | <span class="mi">0</span>xe1 =&gt; Some (Typical RegA (Binop Sbc XInd) true)
    | <span class="mi">0</span>xe5 =&gt; Some (Typical RegA (Binop Sbc Zpg0) true)
    | <span class="mi">0</span>xe9 =&gt; Some (Typical RegA (Binop Sbc Imm ) true)
    | <span class="mi">0</span>xed =&gt; Some (Typical RegA (Binop Sbc Abs0) true)
    | <span class="mi">0</span>xf1 =&gt; Some (Typical RegA (Binop Sbc IndY) true)
    | <span class="mi">0</span>xf5 =&gt; Some (Typical RegA (Binop Sbc ZpgX) true)
    | <span class="mi">0</span>xf9 =&gt; Some (Typical RegA (Binop Sbc AbsY) true)
    | <span class="mi">0</span>xfd =&gt; Some (Typical RegA (Binop Sbc AbsX) true)

    <span class="c">(* ......10 *)</span>
    | <span class="mi">0</span>x06 =&gt; Some (Typical Zpg0 (ShiftL false) true)
    | <span class="mi">0</span>x0a =&gt; Some (Typical RegA (ShiftL false) true)
    | <span class="mi">0</span>x0e =&gt; Some (Typical Abs0 (ShiftL false) true)
    | <span class="mi">0</span>x16 =&gt; Some (Typical ZpgX (ShiftL false) true)
    | <span class="mi">0</span>x1e =&gt; Some (Typical AbsX (ShiftL false) true)

    | <span class="mi">0</span>x26 =&gt; Some (Typical Zpg0 (ShiftL true) true)
    | <span class="mi">0</span>x2a =&gt; Some (Typical RegA (ShiftL true) true)
    | <span class="mi">0</span>x2e =&gt; Some (Typical Abs0 (ShiftL true) true)
    | <span class="mi">0</span>x36 =&gt; Some (Typical ZpgX (ShiftL true) true)
    | <span class="mi">0</span>x3e =&gt; Some (Typical AbsX (ShiftL true) true)

    | <span class="mi">0</span>x46 =&gt; Some (Typical Zpg0 (ShiftR false) true)
    | <span class="mi">0</span>x4a =&gt; Some (Typical RegA (ShiftR false) true)
    | <span class="mi">0</span>x4e =&gt; Some (Typical Abs0 (ShiftR false) true)
    | <span class="mi">0</span>x56 =&gt; Some (Typical ZpgX (ShiftR false) true)
    | <span class="mi">0</span>x5e =&gt; Some (Typical AbsX (ShiftR false) true)

    | <span class="mi">0</span>x66 =&gt; Some (Typical Zpg0 (ShiftR true) true)
    | <span class="mi">0</span>x6a =&gt; Some (Typical RegA (ShiftR true) true)
    | <span class="mi">0</span>x6e =&gt; Some (Typical Abs0 (ShiftR true) true)
    | <span class="mi">0</span>x76 =&gt; Some (Typical ZpgX (ShiftR true) true)
    | <span class="mi">0</span>x7e =&gt; Some (Typical AbsX (ShiftR true) true)

    | <span class="mi">0</span>x86 =&gt; Some (Typical Zpg0 (Binop Mov RegX) false)
    | <span class="mi">0</span>x8a =&gt; Some (Typical RegA (Binop Mov RegX) true)
    | <span class="mi">0</span>x8e =&gt; Some (Typical Abs0 (Binop Mov RegX) false)
    | <span class="mi">0</span>x96 =&gt; Some (Typical ZpgY (Binop Mov RegX) false)
    | <span class="mi">0</span>x9a =&gt; Some (Typical (RegMode SP) (Binop Mov RegX) false)

    | <span class="mi">0</span>xa2 =&gt; Some (Typical RegX (Binop Mov Imm ) true)
    | <span class="mi">0</span>xa6 =&gt; Some (Typical RegX (Binop Mov Zpg0) true)
    | <span class="mi">0</span>xaa =&gt; Some (Typical RegX (Binop Mov RegA) true)
    | <span class="mi">0</span>xae =&gt; Some (Typical RegX (Binop Mov Abs0) true)
    | <span class="mi">0</span>xb6 =&gt; Some (Typical RegX (Binop Mov ZpgY) true)
    | <span class="mi">0</span>xba =&gt; Some (Typical RegX (Binop Mov (RegMode SP)) true)
    | <span class="mi">0</span>xbe =&gt; Some (Typical RegX (Binop Mov AbsY) true)

    | <span class="mi">0</span>xc6 =&gt; Some (Typical Zpg0 Dec true)
    | <span class="mi">0</span>xca =&gt; Some (Typical RegX Dec true)
    | <span class="mi">0</span>xce =&gt; Some (Typical Abs0 Dec true)
    | <span class="mi">0</span>xd6 =&gt; Some (Typical ZpgX Dec true)
    | <span class="mi">0</span>xde =&gt; Some (Typical AbsX Dec true)

    | <span class="mi">0</span>xe6 =&gt; Some (Typical Zpg0 Inc true)
    | <span class="mi">0</span>xea =&gt; Some Nop
    | <span class="mi">0</span>xee =&gt; Some (Typical Abs0 Inc true)
    | <span class="mi">0</span>xf6 =&gt; Some (Typical ZpgX Inc true)
    | <span class="mi">0</span>xfe =&gt; Some (Typical AbsX Inc true)

    <span class="c">(* .....100 *)</span>
    | <span class="mi">0</span>x24 =&gt; Some (Typical RegA (Binop Bit Zpg0) true)
    | <span class="mi">0</span>x2c =&gt; Some (Typical RegA (Binop Bit Abs0) true)

    | <span class="mi">0</span>x4c =&gt; Some (Control Jmp)

    | <span class="mi">0</span>x84 =&gt; Some (Typical Zpg0 (Binop Mov RegY) false)
    | <span class="mi">0</span>x8c =&gt; Some (Typical Abs0 (Binop Mov RegY) false)
    | <span class="mi">0</span>x94 =&gt; Some (Typical ZpgX (Binop Mov RegY) false)
    | <span class="mi">0</span>x98 =&gt; Some (Typical RegA (Binop Mov RegY) true)

    | <span class="mi">0</span>xa4 =&gt; Some (Typical RegY (Binop Mov Zpg0) true)
    | <span class="mi">0</span>xac =&gt; Some (Typical RegY (Binop Mov Abs0) true)
    | <span class="mi">0</span>xb4 =&gt; Some (Typical RegY (Binop Mov ZpgX) true)
    | <span class="mi">0</span>xbc =&gt; Some (Typical RegY (Binop Mov AbsX) true)

    | <span class="mi">0</span>xc4 =&gt; Some (Typical RegY (Binop Cmp Zpg0) true)
    | <span class="mi">0</span>xcc =&gt; Some (Typical RegY (Binop Cmp Abs0) true)

    | <span class="mi">0</span>xe4 =&gt; Some (Typical RegX (Binop Cmp Zpg0) true)
    | <span class="mi">0</span>xec =&gt; Some (Typical RegX (Binop Cmp Abs0) true)

    <span class="c">(* ...0.000 *)</span>
    | <span class="mi">0</span>x20 =&gt; Some (Control Jsr)

    | <span class="mi">0</span>x60 =&gt; Some (Control Rts)

    | <span class="mi">0</span>x88 =&gt; Some (Typical RegY Dec true)

    | <span class="mi">0</span>xa0 =&gt; Some (Typical RegY (Binop Mov Imm ) true)
    | <span class="mi">0</span>xa8 =&gt; Some (Typical RegY (Binop Mov RegA) true)

    | <span class="mi">0</span>xc0 =&gt; Some (Typical RegY (Binop Cmp Imm ) true)
    | <span class="mi">0</span>xc8 =&gt; Some (Typical RegY Inc true)

    | <span class="mi">0</span>xe0 =&gt; Some (Typical RegX (Binop Cmp Imm ) true)
    | <span class="mi">0</span>xe8 =&gt; Some (Typical RegX Inc true)

    <span class="c">(* ...11000 *)</span>
    | <span class="mi">0</span>x18 =&gt; Some (SetFlag spec.C false)
    | <span class="mi">0</span>x38 =&gt; Some (SetFlag spec.C true)
    | <span class="mi">0</span>x58 =&gt; Some (SetFlag spec.I false)
    | <span class="mi">0</span>x78 =&gt; Some (SetFlag spec.I true)
    | <span class="mi">0</span>xb8 =&gt; Some (SetFlag spec.V false)
    | <span class="mi">0</span>xd8 =&gt; Some (SetFlag spec.D false)
    | <span class="mi">0</span>xf8 =&gt; Some (SetFlag spec.D true)

    <span class="c">(* ...10000 *)</span>
    | <span class="mi">0</span>x10 =&gt; Some (Control (Branch spec.N false))
    | <span class="mi">0</span>x30 =&gt; Some (Control (Branch spec.N true))
    | <span class="mi">0</span>x50 =&gt; Some (Control (Branch spec.V false))
    | <span class="mi">0</span>x70 =&gt; Some (Control (Branch spec.V true))
    | <span class="mi">0</span>x90 =&gt; Some (Control (Branch spec.C false))
    | <span class="mi">0</span>xb0 =&gt; Some (Control (Branch spec.C true))
    | <span class="mi">0</span>xd0 =&gt; Some (Control (Branch spec.Z false))
    | <span class="mi">0</span>xf0 =&gt; Some (Control (Branch spec.Z true))

    | _ =&gt; None
    <span class="kr">end</span>.</span></span></pre><p>Now, I claim if an opcode corresponds to an instruction,
the instruction's behavior faithfully represents the opcode's.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">run_instr_claim</span> : <span class="kt">Prop</span> :=
    <span class="kr">forall</span> <span class="nv">opcode</span>,
    <span class="kr">match</span> parse_instr opcode <span class="kr">with</span>
    | None =&gt; <span class="kt">True</span>
    | Some i =&gt; <span class="kr">forall</span> <span class="nv">s1</span> <span class="nv">s2</span>,
        instruction s1 s2 opcode -&gt; s2 ‚àà run_instr i s1
    <span class="kr">end</span>.</span></span></pre><p>The last thousand lines of this file is a proof of this fact.</p>
<div class="section" id="lemmas">
<h2>Lemmas</h2>
<p>Before proving the theorem, it helps to prove a large number of lemmas.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> Coq <span class="kn">Require Import</span> FunctionalExtensionality.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk1"><span class="kn">Fact</span> <span class="nf">can_always_fetch</span> <span class="nv">s</span> <span class="nv">addr</span> : <span class="kr">exists</span> <span class="nv">w</span>, w ‚àà fetch s addr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">w</span> : bv <span class="mi">8</span>, w ‚àà fetch s addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">w</span> : bv <span class="mi">8</span>, w ‚àà fetch s addr</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk3">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">x</span> : bv <span class="mi">8</span>, spec.fetch s addr x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk4"><span class="nb">rewrite</span> /spec.fetch.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">x</span> : bv <span class="mi">8</span>,
  <span class="kr">if</span> bit <span class="mi">12</span> addr
  <span class="kr">then</span> x = rom.ROM (trunc <span class="mi">11</span> addr)
  <span class="kr">else</span>
   <span class="kr">if</span> negb (bit <span class="mi">7</span> addr) || bit <span class="mi">9</span> addr
   <span class="kr">then</span> <span class="kt">True</span>
   <span class="kr">else</span> x = RAM s (trunc <span class="mi">7</span> addr)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk5"><span class="nb">case</span> (bit <span class="mi">12</span> addr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">x</span> : bv <span class="mi">8</span>, x = rom.ROM (trunc <span class="mi">11</span> addr)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk6"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">x</span> : bv <span class="mi">8</span>,
  <span class="kr">if</span> negb (bit <span class="mi">7</span> addr) || bit <span class="mi">9</span> addr
  <span class="kr">then</span> <span class="kt">True</span>
  <span class="kr">else</span> x = RAM s (trunc <span class="mi">7</span> addr)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk7"><span class="bp">by</span> <span class="nb">eexists</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">x</span> : bv <span class="mi">8</span>,
  <span class="kr">if</span> negb (bit <span class="mi">7</span> addr) || bit <span class="mi">9</span> addr
  <span class="kr">then</span> <span class="kt">True</span>
  <span class="kr">else</span> x = RAM s (trunc <span class="mi">7</span> addr)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk8"><span class="nb">case</span> (negb (bit <span class="mi">7</span> addr) || bit <span class="mi">9</span> addr).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">_</span> : bv <span class="mi">8</span>, <span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk9"><hr></label><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">x</span> : bv <span class="mi">8</span>, x = RAM s (trunc <span class="mi">7</span> addr)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chka"><span class="bp">by</span> <span class="kr">exists</span> <span class="nv">inhabitant</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÉ</span> <span class="nv">x</span> : bv <span class="mi">8</span>, x = RAM s (trunc <span class="mi">7</span> addr)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">eexists</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Both the language and spec use the concept of addressing mode, though in different ways.</p>
<p>The following series of lemmas relates the two.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkb"><span class="kn">Lemma</span> <span class="nf">immediate_mode</span> <span class="nv">s</span> <span class="nv">addr</span> :
    spec.immediate s addr -&gt; MemLoc addr ‚àà mode_loc s Imm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">immediate s addr ‚Üí MemLoc addr ‚àà mode_loc s Imm</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkc"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">immediate s addr ‚Üí MemLoc addr ‚àà mode_loc s Imm</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkd"><span class="nb">move</span>=&gt;-&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MemLoc (PC s `+Z` <span class="mi">1</span>) ‚àà mode_loc s Imm</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chke"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MemLoc (PC s `+Z` <span class="mi">1</span>) = MemLoc (PC s `+Z` <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkf"><span class="kn">Lemma</span> <span class="nf">absolute_mode</span> <span class="nv">s</span> <span class="nv">addr</span> :
    spec.absolute s addr -&gt; MemLoc addr ‚àà mode_loc s Abs0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">absolute s addr ‚Üí MemLoc addr ‚àà mode_loc s Abs0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">absolute s addr ‚Üí MemLoc addr ‚àà mode_loc s Abs0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk11"><span class="nb">move</span>=&gt; [w1 [w2 [fetch_w1 [fetch_w2 -&gt;]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MemLoc (spec.bv_concat <span class="mi">16</span> w1 w2) ‚àà mode_loc s Abs0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk12"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 ‚àà mem_mode_addr s Abs0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk13"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2
‚àà fetch16 s (PC s `+Z` <span class="mi">1</span>) (PC s `+Z` <span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk14"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2
‚àà fetch s (PC s `+Z` <span class="mi">2</span>)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>, {[spec.bv_concat <span class="mi">16</span> w1 w2]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk15"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 ‚àà {[spec.bv_concat <span class="mi">16</span> w1 w2]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk16"><span class="kn">Lemma</span> <span class="nf">absolute_x_mode</span> <span class="nv">s</span> <span class="nv">addr</span> :
    spec.absolute_x s addr -&gt; MemLoc addr ‚àà mode_loc s AbsX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">absolute_x s addr ‚Üí MemLoc addr ‚àà mode_loc s AbsX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk17"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">absolute_x s addr ‚Üí MemLoc addr ‚àà mode_loc s AbsX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk18"><span class="nb">move</span>=&gt; [w1 [w2 [fetch_w1 [fetch_w2 -&gt;]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MemLoc
  (spec.bv_concat <span class="mi">16</span> w1 w2 +
   bv_zero_extend <span class="mi">16</span> (Reg s X)) ‚àà 
mode_loc s AbsX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk19"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 + bv_zero_extend <span class="mi">16</span> (Reg s X)
‚àà mem_mode_addr s AbsX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk1a"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2
‚àà fetch16 s (PC s `+Z` <span class="mi">1</span>) (PC s `+Z` <span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk1b"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2
‚àà fetch s (PC s `+Z` <span class="mi">2</span>)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>, {[spec.bv_concat <span class="mi">16</span> w1 w2]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk1c"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 ‚àà {[spec.bv_concat <span class="mi">16</span> w1 w2]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk1d"><span class="kn">Lemma</span> <span class="nf">absolute_y_mode</span> <span class="nv">s</span> <span class="nv">addr</span> :
    spec.absolute_y s addr -&gt; MemLoc addr ‚àà mode_loc s AbsY.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">absolute_y s addr ‚Üí MemLoc addr ‚àà mode_loc s AbsY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk1e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">absolute_y s addr ‚Üí MemLoc addr ‚àà mode_loc s AbsY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk1f"><span class="nb">move</span>=&gt; [w1 [w2 [fetch_w1 [fetch_w2 -&gt;]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MemLoc
  (spec.bv_concat <span class="mi">16</span> w1 w2 +
   bv_zero_extend <span class="mi">16</span> (Reg s Y)) ‚àà 
mode_loc s AbsY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk20"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 + bv_zero_extend <span class="mi">16</span> (Reg s Y)
‚àà mem_mode_addr s AbsY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk21"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2
‚àà fetch16 s (PC s `+Z` <span class="mi">1</span>) (PC s `+Z` <span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk22"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2
‚àà fetch s (PC s `+Z` <span class="mi">2</span>)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>, {[spec.bv_concat <span class="mi">16</span> w1 w2]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk23"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">2</span>) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 ‚àà {[spec.bv_concat <span class="mi">16</span> w1 w2]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk24"><span class="kn">Lemma</span> <span class="nf">zero_page_mode</span> <span class="nv">s</span> <span class="nv">addr</span> :
    spec.zero_page s addr -&gt; MemLoc addr ‚àà mode_loc s Zpg0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero_page s addr ‚Üí MemLoc addr ‚àà mode_loc s Zpg0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk25"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero_page s addr ‚Üí MemLoc addr ‚àà mode_loc s Zpg0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk26"><span class="nb">move</span>=&gt; [w [fetch_w -&gt;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MemLoc (bv_zero_extend <span class="mi">16</span> w) ‚àà mode_loc s Zpg0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk27"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bv_zero_extend <span class="mi">16</span> w ‚àà mem_mode_addr s Zpg0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk28"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">w ‚àà fetch s (PC s `+Z` <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> fetch_w.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk29"><span class="kn">Lemma</span> <span class="nf">zero_page_x_mode</span> <span class="nv">s</span> <span class="nv">addr</span> :
    spec.zero_page_x s addr -&gt; MemLoc addr ‚àà mode_loc s ZpgX.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero_page_x s addr ‚Üí MemLoc addr ‚àà mode_loc s ZpgX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero_page_x s addr ‚Üí MemLoc addr ‚àà mode_loc s ZpgX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b"><span class="nb">move</span>=&gt; [w [fetch_w -&gt;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MemLoc (bv_zero_extend <span class="mi">16</span> (w + Reg s X))
‚àà mode_loc s ZpgX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bv_zero_extend <span class="mi">16</span> (w + Reg s X) ‚àà mem_mode_addr s ZpgX</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">w ‚àà fetch s (PC s `+Z` <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> fetch_w.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2e"><span class="kn">Lemma</span> <span class="nf">zero_page_y_mode</span> <span class="nv">s</span> <span class="nv">addr</span> :
    spec.zero_page_y s addr -&gt; MemLoc addr ‚àà mode_loc s ZpgY.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero_page_y s addr ‚Üí MemLoc addr ‚àà mode_loc s ZpgY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">zero_page_y s addr ‚Üí MemLoc addr ‚àà mode_loc s ZpgY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk30"><span class="nb">move</span>=&gt; [w [fetch_w -&gt;]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MemLoc (bv_zero_extend <span class="mi">16</span> (w + Reg s Y))
‚àà mode_loc s ZpgY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk31"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bv_zero_extend <span class="mi">16</span> (w + Reg s Y) ‚àà mem_mode_addr s ZpgY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk32"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">w ‚àà fetch s (PC s `+Z` <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">exact</span> fetch_w.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk33"><span class="kn">Lemma</span> <span class="nf">indirect_x_mode</span> <span class="nv">s</span> <span class="nv">addr</span> :
    spec.indirect_x s addr -&gt; MemLoc addr ‚àà mode_loc s XInd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">indirect_x s addr ‚Üí MemLoc addr ‚àà mode_loc s XInd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk34"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">indirect_x s addr ‚Üí MemLoc addr ‚àà mode_loc s XInd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk35"><span class="nb">move</span>=&gt; [w [w1 [w2 [fetch_w [fetch_w1 [fetch_w2 -&gt;]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s
  (bv_zero_extend <span class="mi">16</span> (w + Reg s X)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s
  (bv_zero_extend <span class="mi">16</span> ((w + Reg s X) `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MemLoc (spec.bv_concat <span class="mi">16</span> w1 w2) ‚àà mode_loc s XInd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk36"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s
  (bv_zero_extend <span class="mi">16</span> (w + Reg s X)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s
  (bv_zero_extend <span class="mi">16</span> ((w + Reg s X) `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 ‚àà mem_mode_addr s XInd</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk37"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s
  (bv_zero_extend <span class="mi">16</span> (w + Reg s X)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s
  (bv_zero_extend <span class="mi">16</span> ((w + Reg s X) `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2
‚àà (<span class="kr">let</span> <span class="nv">b</span> := w + Reg s X <span class="kr">in</span>
   fetch16 s (bv_zero_extend <span class="mi">16</span> b)
     (bv_zero_extend <span class="mi">16</span> (b + <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk38"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s
  (bv_zero_extend <span class="mi">16</span> (w + Reg s X)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s
  (bv_zero_extend <span class="mi">16</span> ((w + Reg s X) `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2
‚àà fetch s (bv_zero_extend <span class="mi">16</span> (w + Reg s X + <span class="mi">1</span>))
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>, {[spec.bv_concat <span class="mi">16</span> w1 w2]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk39"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s
  (bv_zero_extend <span class="mi">16</span> (w + Reg s X)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s
  (bv_zero_extend <span class="mi">16</span> ((w + Reg s X) `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 ‚àà {[spec.bv_concat <span class="mi">16</span> w1 w2]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk3a"><span class="kn">Lemma</span> <span class="nf">indirect_y_mode</span> <span class="nv">s</span> <span class="nv">addr</span> :
    spec.indirect_y s addr -&gt; MemLoc addr ‚àà mode_loc s IndY.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">indirect_y s addr ‚Üí MemLoc addr ‚àà mode_loc s IndY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk3b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">indirect_y s addr ‚Üí MemLoc addr ‚àà mode_loc s IndY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk3c"><span class="nb">move</span>=&gt; [w [w1 [w2 [fetch_w [fetch_w1 [fetch_w2 -&gt;]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> w) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> (w `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">MemLoc
  (spec.bv_concat <span class="mi">16</span> w1 w2 +
   bv_zero_extend <span class="mi">16</span> (Reg s Y)) ‚àà 
mode_loc s IndY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk3d"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> w) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> (w `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 + bv_zero_extend <span class="mi">16</span> (Reg s Y)
‚àà mem_mode_addr s IndY</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk3e"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> w) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> (w `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 + bv_zero_extend <span class="mi">16</span> (Reg s Y)
‚àà fetch16 s (bv_zero_extend <span class="mi">16</span> w)
    (bv_zero_extend <span class="mi">16</span> (w + <span class="mi">1</span>))
  ‚â´= (<span class="kr">Œª</span> <span class="nv">b</span> : bv <span class="mi">16</span>, {[b + bv_zero_extend <span class="mi">16</span> (Reg s Y)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk3f"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> w) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> (w `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2
‚àà fetch16 s (bv_zero_extend <span class="mi">16</span> w)
    (bv_zero_extend <span class="mi">16</span> (w + <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk40"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> w) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> (w `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2
‚àà fetch s (bv_zero_extend <span class="mi">16</span> (w + <span class="mi">1</span>))
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>, {[spec.bv_concat <span class="mi">16</span> w1 w2]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk41"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w, w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s (PC s `+Z` <span class="mi">1</span>) w</span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> w) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s (bv_zero_extend <span class="mi">16</span> (w `+Z` <span class="mi">1</span>))
  w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.bv_concat <span class="mi">16</span> w1 w2 ‚àà {[spec.bv_concat <span class="mi">16</span> w1 w2]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p><tt class="docutils literal">spec.v</tt> defines a lot of helper functions, which help specify the behavior of certain groups of instructions.
The following sequence of lemmas relates each of them to the corresponding concept in the language.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk42"><span class="kn">Lemma</span> <span class="nf">run_SetFlag</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">f</span> <span class="nv">val</span> :
    spec.flag_instr s1 s2 f val -&gt; s2 ‚àà run_instr (SetFlag f val) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flag_instr s1 s2 f val
‚Üí s2 ‚àà run_instr (SetFlag f val) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk43"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">flag_instr s1 s2 f val
‚Üí s2 ‚àà run_instr (SetFlag f val) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk44"><span class="nb">rewrite</span> /flag_instr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC s2 = PC s1 `+Z` <span class="mi">1</span>
‚àß Reg s2 = Reg s1
  ‚àß Flag s2 =
    (<span class="kr">Œª</span> <span class="nv">f&#39;</span> : flag,
       <span class="kr">if</span> flag_eqb f f&#39; <span class="kr">then</span> val <span class="kr">else</span> Flag s1 f&#39;)
    ‚àß RAM s2 = RAM s1
‚Üí s2 ‚àà run_instr (SetFlag f val) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk45"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC = spec.PC s1 `+Z` <span class="mi">1</span>
‚àß Reg = spec.Reg s1
  ‚àß Flag =
    (<span class="kr">Œª</span> <span class="nv">f&#39;</span> : flag,
       <span class="kr">if</span> flag_eqb f f&#39; <span class="kr">then</span> val <span class="kr">else</span> spec.Flag s1 f&#39;)
    ‚àß RAM = spec.RAM s1
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[{|
        Reg := spec.Reg s1;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f&#39;</span> : flag,
            <span class="kr">if</span> flag_eqb f f&#39;
            <span class="kr">then</span> val
            <span class="kr">else</span> spec.Flag s1 f&#39;;
        PC := spec.PC s1 `+Z` <span class="mi">1</span>;
        RAM := spec.RAM s1
      |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>=&gt; [-&gt; [-&gt; [-&gt; -&gt;]]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk46"><span class="kn">Lemma</span> <span class="nf">run_transfer</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">r1</span> <span class="nv">r2</span> :
    spec.transfer_instr s1 s2 r1 r2 -&gt;
    s2 ‚àà run_instr
        (Typical (RegMode r2) (Binop Mov (RegMode r1)) true)
        s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transfer_instr s1 s2 r1 r2
‚Üí s2
  ‚àà run_instr
      (Typical (RegMode r2) (Binop Mov (RegMode r1))
         true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transfer_instr s1 s2 r1 r2
‚Üí s2
  ‚àà run_instr
      (Typical (RegMode r2) (Binop Mov (RegMode r1))
         true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk48"><span class="nb">rewrite</span> /transfer_instr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC s2 = PC s1 `+Z` <span class="mi">1</span>
‚àß Reg s2 = setReg s1 r2 (Reg s1 r1)
  ‚àß Flag s2 = setNZ s1 (Reg s1 r1) ‚àß RAM s2 = RAM s1
‚Üí s2
  ‚àà run_instr
      (Typical (RegMode r2) (Binop Mov (RegMode r1))
         true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk49"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC = spec.PC s1 `+Z` <span class="mi">1</span>
‚àß Reg = setReg s1 r2 (spec.Reg s1 r1)
  ‚àß Flag = setNZ s1 (spec.Reg s1 r1)
    ‚àß RAM = spec.RAM s1
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc r2]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">_</span> : bv <span class="mi">8</span>,
                ({[RegLoc r1]}
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                             {[(w2, spec.Flag s1 C,
                                spec.Flag s1 V)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
                      {[{|
                          Reg :=
                            <span class="kr">match</span> l <span class="kr">with</span>
                            | RegLoc r =&gt;
                                <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                                  <span class="kr">if</span> reg_eqb r r&#39;
                                  <span class="kr">then</span> w
                                  <span class="kr">else</span> spec.Reg s1 r&#39;
                            | MemLoc _ =&gt; spec.Reg s1
                            <span class="kr">end</span>;
                          Flag :=
                            <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                              <span class="kr">match</span> f <span class="kr">with</span>
                              | spec.N =&gt;
                                  <span class="kr">match</span>
                                    bv_unsigned w
                                  <span class="kr">with</span>
                                  | <span class="mi">0</span>%Z =&gt; false
                                  | Z.pos a =&gt;
                                      Pos.testbit a <span class="mi">7</span>
                                  | Z.neg a =&gt;
                                      negb
                                        (N.testbit
                                           (Pos.pred_N
                                              a) <span class="mi">7</span>)
                                  <span class="kr">end</span>
                              | V =&gt; v
                              | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                              | C =&gt; c
                              | _ =&gt; spec.Flag s1 f
                              <span class="kr">end</span>;
                          PC :=
                            spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
                          RAM :=
                            <span class="kr">match</span> l <span class="kr">with</span>
                            | RegLoc _ =&gt; spec.RAM s1
                            | MemLoc a =&gt;
                                write a w
                                  (spec.RAM s1)
                            <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk4a"><span class="nb">move</span>=&gt; [-&gt; [-&gt; [-&gt; -&gt;]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r2 (spec.Reg s1 r1);
  Flag := setNZ s1 (spec.Reg s1 r1);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà {[RegLoc r2]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">_</span> : bv <span class="mi">8</span>,
              ({[RegLoc r1]}
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk4b"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r2 (spec.Reg s1 r1);
  Flag := setNZ s1 (spec.Reg s1 r1);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc r2)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">_</span> : bv <span class="mi">8</span>,
        ({[RegLoc r1]}
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     {[(w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc r2 <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
                  RAM :=
                    <span class="kr">match</span> RegLoc r2 <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk4c"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r2 (spec.Reg s1 r1);
  Flag := setNZ s1 (spec.Reg s1 r1);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà ({[RegLoc r1]}
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               {[(w2, spec.Flag s1 C, spec.Flag s1 V)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb r2 r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk4d"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r2 (spec.Reg s1 r1);
  Flag := setNZ s1 (spec.Reg s1 r1);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb r2 r&#39;
          <span class="kr">then</span> <span class="nl">?Goal</span>
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned <span class="nl">?Goal</span> <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; <span class="nl">?Goal1</span>
          | spec.Z =&gt; bv_eqb <span class="nl">?Goal</span> <span class="mi">0</span>
          | C =&gt; <span class="nl">?Goal0</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
      RAM := spec.RAM s1
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk4e"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[RegLoc r1]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(w2, spec.Flag s1 C, spec.Flag s1 V)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk4f"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[RegLoc r1]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(w2, spec.Flag s1 C, spec.Flag s1 V)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk50"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà read s1 (RegLoc r1)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        {[(w2, spec.Flag s1 C, spec.Flag s1 V)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk51"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[(spec.Reg s1 r1, spec.Flag s1 C, spec.Flag s1 V)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk52">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r2 (spec.Reg s1 r1);
  Flag := setNZ s1 (spec.Reg s1 r1);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb r2 r&#39;
          <span class="kr">then</span> spec.Reg s1 r1
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned (spec.Reg s1 r1) <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; spec.Flag s1 V
          | spec.Z =&gt; bv_eqb (spec.Reg s1 r1) <span class="mi">0</span>
          | C =&gt; spec.Flag s1 C
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk53">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r2 (spec.Reg s1 r1);
  Flag := setNZ s1 (spec.Reg s1 r1);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|} =
{|
  Reg :=
    <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
      <span class="kr">if</span> reg_eqb r2 r&#39;
      <span class="kr">then</span> spec.Reg s1 r1
      <span class="kr">else</span> spec.Reg s1 r&#39;;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned (spec.Reg s1 r1) <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb (spec.Reg s1 r1) <span class="mi">0</span>
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk54"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r1, r2</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 (spec.Reg s1 r1) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned (spec.Reg s1 r1) <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb (spec.Reg s1 r1) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk55"><span class="kn">Lemma</span> <span class="nf">run_store</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">r</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.store_instr s1 s2 r mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical mode&#39; (Binop Mov (RegMode r)) false) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí store_instr s1 s2 r mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical mode&#39; (Binop Mov (RegMode r)) false)
          s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk56"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí store_instr s1 s2 r mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical mode&#39; (Binop Mov (RegMode r)) false)
          s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk57"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">store_instr s1 s2 r mode
  (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr
      (Typical mode&#39; (Binop Mov (RegMode r)) false) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk58"><span class="nb">rewrite</span> /store_instr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
   mode s1 addr
   ‚àß PC s2 = PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
     ‚àß Reg s2 = Reg s1
       ‚àß Flag s2 = Flag s1
         ‚àß RAM s2 = write addr (Reg s1 r) (RAM s1))
‚Üí s2
  ‚àà run_instr
      (Typical mode&#39; (Binop Mov (RegMode r)) false) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk59"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
   mode s1 addr
   ‚àß PC =
     spec.PC s1
     `+Z` Z.of_nat
            (S
               (<span class="kr">match</span>
                  mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                <span class="kr">with</span>
                | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                | Abs wildcard&#39; =&gt;
                    <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
                | Zpg wildcard&#39; =&gt;
                    <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
                | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                <span class="kr">end</span> eq_refl))
     ‚àß Reg = spec.Reg s1
       ‚àß Flag = spec.Flag s1
         ‚àß RAM =
           write addr (spec.Reg s1 r) (spec.RAM s1))
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">_</span> : bv <span class="mi">8</span>,
                ({[RegLoc r]}
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(
                        w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | V =&gt; v
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk5a"><span class="nb">move</span> =&gt; [addr [/mode_spec m [-&gt; [-&gt; [-&gt; -&gt;]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr (spec.Reg s1 r) (spec.RAM s1)
|}
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">_</span> : bv <span class="mi">8</span>,
              ({[RegLoc r]}
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | V =&gt; v
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk5b"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr (spec.Reg s1 r) (spec.RAM s1)
|}
‚àà read s1 (MemLoc addr)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">_</span> : bv <span class="mi">8</span>,
        ({[RegLoc r]}
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     {[(w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> MemLoc addr <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | V =&gt; v
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
                  RAM :=
                    <span class="kr">match</span> MemLoc addr <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk5c"><span class="nb">move</span>: (can_always_fetch s1 addr) =&gt; [? tmp];
        <span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà fetch s1 addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr (spec.Reg s1 r) (spec.RAM s1)
|}
‚àà ({[RegLoc r]}
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               {[(w2, spec.Flag s1 C, spec.Flag s1 V)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg := spec.Reg s1;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | V =&gt; v
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
            RAM := write addr w (spec.RAM s1)
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk5d"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà fetch s1 addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr (spec.Reg s1 r) (spec.RAM s1)
|}
‚àà {[{|
      Reg := spec.Reg s1;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | V =&gt; <span class="nl">?Goal1</span>
          | C =&gt; <span class="nl">?Goal0</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
      RAM := write addr <span class="nl">?Goal</span> (spec.RAM s1)
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà fetch s1 addr</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk5e"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[RegLoc r]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(w2, spec.Flag s1 C, spec.Flag s1 V)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk5f"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà fetch s1 addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[RegLoc r]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(w2, spec.Flag s1 C, spec.Flag s1 V)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk60"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà fetch s1 addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà read s1 (RegLoc r)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        {[(w2, spec.Flag s1 C, spec.Flag s1 V)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk61"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà fetch s1 addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[(spec.Reg s1 r, spec.Flag s1 C, spec.Flag s1 V)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk62">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà fetch s1 addr</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr (spec.Reg s1 r) (spec.RAM s1)
|}
‚àà {[{|
      Reg := spec.Reg s1;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | V =&gt; spec.Flag s1 V
          | C =&gt; spec.Flag s1 C
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
      RAM := write addr (spec.Reg s1 r) (spec.RAM s1)
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk63">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr _x_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr (spec.Reg s1 r) (spec.RAM s1)
|} =
{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | V =&gt; spec.Flag s1 V
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
  RAM := write addr (spec.Reg s1 r) (spec.RAM s1)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk64"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr _x_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.Flag s1 =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | V =&gt; spec.Flag s1 V
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr _x_</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk65"><hr></label><div class="goal-conclusion">spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl)) =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk66">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr _x_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.Flag s1 =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | V =&gt; spec.Flag s1 V
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk67">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>tmp</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr _x_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl)) =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span> mode&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk68"><span class="kn">Lemma</span> <span class="nf">run_load</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">r</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.load_instr s1 s2 r mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical (RegMode r) (Binop Mov mode&#39;) true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí load_instr s1 s2 r mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical (RegMode r) (Binop Mov mode&#39;) true)
          s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí load_instr s1 s2 r mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical (RegMode r) (Binop Mov mode&#39;) true)
          s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk6a"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">load_instr s1 s2 r mode
  (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr
      (Typical (RegMode r) (Binop Mov mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk6b"><span class="nb">rewrite</span> /load_instr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC s2 =
       PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
       ‚àß Reg s2 = setReg s1 r w
         ‚àß Flag s2 = setNZ s1 w ‚àß RAM s2 = RAM s1)
‚Üí s2
  ‚àà run_instr
      (Typical (RegMode r) (Binop Mov mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk6c"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC =
       spec.PC s1
       `+Z` Z.of_nat
              (S
                 (<span class="kr">match</span>
                    mode&#39; <span class="kr">as</span> m
                    <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                  <span class="kr">with</span>
                  | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                  | Abs wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                  | Zpg wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                  | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                  | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                  | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                  <span class="kr">end</span> eq_refl))
       ‚àß Reg = setReg s1 r w
         ‚àß Flag = setNZ s1 w ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc r]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">_</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(
                        w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk6d"><span class="nb">move</span>=&gt; [addr [w [/mode_spec m [fetch_w [-&gt; [-&gt; [-&gt; -&gt;]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r w;
  Flag := setNZ s1 w;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[RegLoc r]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">_</span> : bv <span class="mi">8</span>,
              ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk6e"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r w;
  Flag := setNZ s1 w;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc r)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">_</span> : bv <span class="mi">8</span>,
        ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     {[(w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc r <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                  RAM :=
                    <span class="kr">match</span> RegLoc r <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk6f"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r w;
  Flag := setNZ s1 w;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               {[(w2, spec.Flag s1 C, spec.Flag s1 V)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb r r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk70"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r w;
  Flag := setNZ s1 w;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb r r&#39;
          <span class="kr">then</span> <span class="nl">?Goal</span>
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned <span class="nl">?Goal</span> <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; <span class="nl">?Goal1</span>
          | spec.Z =&gt; bv_eqb <span class="nl">?Goal</span> <span class="mi">0</span>
          | C =&gt; <span class="nl">?Goal0</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk71" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk71"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(w2, spec.Flag s1 C, spec.Flag s1 V)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk72"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(w2, spec.Flag s1 C, spec.Flag s1 V)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk73"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà read s1 (MemLoc addr)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        {[(w2, spec.Flag s1 C, spec.Flag s1 V)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk74"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[(w, spec.Flag s1 C, spec.Flag s1 V)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk75">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r w;
  Flag := setNZ s1 w;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb r r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; spec.Flag s1 V
          | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
          | C =&gt; spec.Flag s1 C
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk76">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r w;
  Flag := setNZ s1 w;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|} =
{|
  Reg :=
    <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
      <span class="kr">if</span> reg_eqb r r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="mi">0</span>
               `max` <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk77"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 w =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk78"><span class="kn">Lemma</span> <span class="nf">run_Or</span> <span class="nv">s1</span> <span class="nv">s2</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.logic_instr s1 s2 bv_or mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical RegA (Binop Or mode&#39;) true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí logic_instr s1 s2 bv_or mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr (Typical RegA (Binop Or mode&#39;) true)
          s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk79"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí logic_instr s1 s2 bv_or mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr (Typical RegA (Binop Or mode&#39;) true)
          s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk7a"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">logic_instr s1 s2 bv_or mode
  (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Or mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk7b"><span class="nb">rewrite</span> /logic_instr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC s2 =
       PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
       ‚àß Reg s2 = setReg s1 A (bv_or (Reg s1 A) w)
         ‚àß Flag s2 = setNZ s1 (bv_or (Reg s1 A) w)
           ‚àß RAM s2 = RAM s1)
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Or mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk7c"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC =
       spec.PC s1
       `+Z` Z.of_nat
              (S
                 (<span class="kr">match</span>
                    mode&#39; <span class="kr">as</span> m
                    <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                  <span class="kr">with</span>
                  | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                  | Abs wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                  | Zpg wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                  | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                  | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                  | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                  <span class="kr">end</span> eq_refl))
       ‚àß Reg = setReg s1 A (bv_or (spec.Reg s1 A) w)
         ‚àß Flag = setNZ s1 (bv_or (spec.Reg s1 A) w)
           ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(
                        bv_or w w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk7d"><span class="nb">move</span>=&gt; [addr&#39; [w [/mode_spec m [fetch_w [-&gt; [-&gt; [-&gt; -&gt;]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_or (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_or (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[RegLoc A]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(bv_or w w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk7e"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_or (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_or (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc A)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     {[(bv_or w w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                  RAM :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk7f"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_or (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_or (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               {[(bv_or (spec.Reg s1 A) w2,
                  spec.Flag s1 C, 
                  spec.Flag s1 V)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb A r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk80"><span class="nb">eexists</span>; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_or (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_or (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà (<span class="kr">let</span>
   &#39;(w, c, v) := <span class="nl">?a</span> <span class="kr">in</span>
    {[{|
        Reg :=
          <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
            <span class="kr">if</span> reg_eqb A r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | V =&gt; v
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; c
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>;
        PC :=
          spec.PC s1
          `+Z` Z.of_nat
                 (S
                    (<span class="mi">0</span>
                     `max` 
                     <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
        RAM := spec.RAM s1
      |}]})</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk81" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk81"><hr></label><div class="goal-conclusion"><span class="nl">?a</span>
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(bv_or (spec.Reg s1 A) w2,
                 spec.Flag s1 C, 
                 spec.Flag s1 V)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk82"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(bv_or (spec.Reg s1 A) w2,
                 spec.Flag s1 C, 
                 spec.Flag s1 V)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk83"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        {[(bv_or (spec.Reg s1 A) w2, 
           spec.Flag s1 C, 
           spec.Flag s1 V)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk84"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà {[(bv_or (spec.Reg s1 A) w, 
     spec.Flag s1 C, spec.Flag s1 V)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk85">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_or (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_or (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà (<span class="kr">let</span>
   &#39;(w, c, v) :=
    (bv_or (spec.Reg s1 A) w, 
     spec.Flag s1 C, spec.Flag s1 V) <span class="kr">in</span>
    {[{|
        Reg :=
          <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
            <span class="kr">if</span> reg_eqb A r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | V =&gt; v
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; c
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>;
        PC :=
          spec.PC s1
          `+Z` Z.of_nat
                 (S
                    (<span class="mi">0</span>
                     `max` 
                     <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
        RAM := spec.RAM s1
      |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk86">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_or (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_or (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|} =
{|
  Reg :=
    <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
      <span class="kr">if</span> reg_eqb A r&#39;
      <span class="kr">then</span> bv_or (spec.Reg s1 A) w
      <span class="kr">else</span> spec.Reg s1 r&#39;;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_or (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb (bv_or (spec.Reg s1 A) w) <span class="mi">0</span>
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="mi">0</span>
               `max` <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk87"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 (bv_or (spec.Reg s1 A) w) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span>
         bv_unsigned (bv_or (spec.Reg s1 A) w)
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb (bv_or (spec.Reg s1 A) w) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk88"><span class="kn">Lemma</span> <span class="nf">run_And</span> <span class="nv">s1</span> <span class="nv">s2</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.logic_instr s1 s2 bv_and mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical RegA (Binop And mode&#39;) true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí logic_instr s1 s2 bv_and mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical RegA (Binop And mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk89"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí logic_instr s1 s2 bv_and mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical RegA (Binop And mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk8a"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">logic_instr s1 s2 bv_and mode
  (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop And mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk8b"><span class="nb">rewrite</span> /logic_instr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC s2 =
       PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
       ‚àß Reg s2 = setReg s1 A (bv_and (Reg s1 A) w)
         ‚àß Flag s2 = setNZ s1 (bv_and (Reg s1 A) w)
           ‚àß RAM s2 = RAM s1)
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop And mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk8c"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC =
       spec.PC s1
       `+Z` Z.of_nat
              (S
                 (<span class="kr">match</span>
                    mode&#39; <span class="kr">as</span> m
                    <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                  <span class="kr">with</span>
                  | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                  | Abs wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                  | Zpg wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                  | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                  | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                  | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                  <span class="kr">end</span> eq_refl))
       ‚àß Reg = setReg s1 A (bv_and (spec.Reg s1 A) w)
         ‚àß Flag = setNZ s1 (bv_and (spec.Reg s1 A) w)
           ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(
                        bv_and w w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk8d"><span class="nb">move</span>=&gt; [addr&#39; [w [/mode_spec m [fetch_w [-&gt; [-&gt; [-&gt; -&gt;]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_and (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_and (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[RegLoc A]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(bv_and w w2,
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk8e"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_and (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_and (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc A)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     {[(bv_and w w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                  RAM :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk8f"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_and (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_and (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               {[(bv_and (spec.Reg s1 A) w2,
                  spec.Flag s1 C, 
                  spec.Flag s1 V)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb A r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk90"><span class="nb">eexists</span>; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_and (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_and (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà (<span class="kr">let</span>
   &#39;(w, c, v) := <span class="nl">?a</span> <span class="kr">in</span>
    {[{|
        Reg :=
          <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
            <span class="kr">if</span> reg_eqb A r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | V =&gt; v
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; c
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>;
        PC :=
          spec.PC s1
          `+Z` Z.of_nat
                 (S
                    (<span class="mi">0</span>
                     `max` 
                     <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
        RAM := spec.RAM s1
      |}]})</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk91" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk91"><hr></label><div class="goal-conclusion"><span class="nl">?a</span>
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(bv_and (spec.Reg s1 A) w2,
                 spec.Flag s1 C, 
                 spec.Flag s1 V)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk92"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(bv_and (spec.Reg s1 A) w2,
                 spec.Flag s1 C, 
                 spec.Flag s1 V)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk93"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        {[(bv_and (spec.Reg s1 A) w2, 
           spec.Flag s1 C, 
           spec.Flag s1 V)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk94"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà {[(bv_and (spec.Reg s1 A) w, 
     spec.Flag s1 C, spec.Flag s1 V)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk95">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_and (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_and (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà (<span class="kr">let</span>
   &#39;(w, c, v) :=
    (bv_and (spec.Reg s1 A) w, 
     spec.Flag s1 C, spec.Flag s1 V) <span class="kr">in</span>
    {[{|
        Reg :=
          <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
            <span class="kr">if</span> reg_eqb A r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | V =&gt; v
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; c
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>;
        PC :=
          spec.PC s1
          `+Z` Z.of_nat
                 (S
                    (<span class="mi">0</span>
                     `max` 
                     <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
        RAM := spec.RAM s1
      |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk96">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_and (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_and (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|} =
{|
  Reg :=
    <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
      <span class="kr">if</span> reg_eqb A r&#39;
      <span class="kr">then</span> bv_and (spec.Reg s1 A) w
      <span class="kr">else</span> spec.Reg s1 r&#39;;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="mi">0</span>
               `max` <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk97"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 (bv_and (spec.Reg s1 A) w) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span>
         bv_unsigned (bv_and (spec.Reg s1 A) w)
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk98"><span class="kn">Lemma</span> <span class="nf">run_Xor</span> <span class="nv">s1</span> <span class="nv">s2</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.logic_instr s1 s2 bv_xor mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical RegA (Binop Xor mode&#39;) true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí logic_instr s1 s2 bv_xor mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical RegA (Binop Xor mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk99"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí logic_instr s1 s2 bv_xor mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical RegA (Binop Xor mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk9a"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">logic_instr s1 s2 bv_xor mode
  (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Xor mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk9b"><span class="nb">rewrite</span> /logic_instr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC s2 =
       PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
       ‚àß Reg s2 = setReg s1 A (bv_xor (Reg s1 A) w)
         ‚àß Flag s2 = setNZ s1 (bv_xor (Reg s1 A) w)
           ‚àß RAM s2 = RAM s1)
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Xor mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk9c"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC =
       spec.PC s1
       `+Z` Z.of_nat
              (S
                 (<span class="kr">match</span>
                    mode&#39; <span class="kr">as</span> m
                    <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                  <span class="kr">with</span>
                  | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                  | Abs wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                  | Zpg wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                  | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                  | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                  | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                  <span class="kr">end</span> eq_refl))
       ‚àß Reg = setReg s1 A (bv_xor (spec.Reg s1 A) w)
         ‚àß Flag = setNZ s1 (bv_xor (spec.Reg s1 A) w)
           ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(
                        bv_xor w w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk9d"><span class="nb">move</span>=&gt; [addr&#39; [w [/mode_spec m [fetch_w [-&gt; [-&gt; [-&gt; -&gt;]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_xor (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_xor (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[RegLoc A]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(bv_xor w w2,
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk9e"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_xor (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_xor (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc A)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     {[(bv_xor w w2, 
                        spec.Flag s1 C, 
                        spec.Flag s1 V)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                  RAM :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk9f"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_xor (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_xor (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               {[(bv_xor (spec.Reg s1 A) w2,
                  spec.Flag s1 C, 
                  spec.Flag s1 V)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb A r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chka0"><span class="nb">eexists</span>; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_xor (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_xor (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà (<span class="kr">let</span>
   &#39;(w, c, v) := <span class="nl">?a</span> <span class="kr">in</span>
    {[{|
        Reg :=
          <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
            <span class="kr">if</span> reg_eqb A r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | V =&gt; v
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; c
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>;
        PC :=
          spec.PC s1
          `+Z` Z.of_nat
                 (S
                    (<span class="mi">0</span>
                     `max` 
                     <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
        RAM := spec.RAM s1
      |}]})</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chka1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><label class="goal-separator" for="instruction-v-chka1"><hr></label><div class="goal-conclusion"><span class="nl">?a</span>
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(bv_xor (spec.Reg s1 A) w2,
                 spec.Flag s1 C, 
                 spec.Flag s1 V)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chka2"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(bv_xor (spec.Reg s1 A) w2,
                 spec.Flag s1 C, 
                 spec.Flag s1 V)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chka3"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        {[(bv_xor (spec.Reg s1 A) w2, 
           spec.Flag s1 C, 
           spec.Flag s1 V)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chka4"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà {[(bv_xor (spec.Reg s1 A) w, 
     spec.Flag s1 C, spec.Flag s1 V)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chka5">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_xor (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_xor (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà (<span class="kr">let</span>
   &#39;(w, c, v) :=
    (bv_xor (spec.Reg s1 A) w, 
     spec.Flag s1 C, spec.Flag s1 V) <span class="kr">in</span>
    {[{|
        Reg :=
          <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
            <span class="kr">if</span> reg_eqb A r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | V =&gt; v
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; c
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>;
        PC :=
          spec.PC s1
          `+Z` Z.of_nat
                 (S
                    (<span class="mi">0</span>
                     `max` 
                     <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
        RAM := spec.RAM s1
      |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chka6">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A (bv_xor (spec.Reg s1 A) w);
  Flag := setNZ s1 (bv_xor (spec.Reg s1 A) w);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|} =
{|
  Reg :=
    <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
      <span class="kr">if</span> reg_eqb A r&#39;
      <span class="kr">then</span> bv_xor (spec.Reg s1 A) w
      <span class="kr">else</span> spec.Reg s1 r&#39;;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_xor (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb (bv_xor (spec.Reg s1 A) w) <span class="mi">0</span>
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="mi">0</span>
               `max` <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chka7"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 (bv_xor (spec.Reg s1 A) w) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span>
         bv_unsigned (bv_xor (spec.Reg s1 A) w)
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb (bv_xor (spec.Reg s1 A) w) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chka8"><span class="kn">Lemma</span> <span class="nf">run_Bit</span> <span class="nv">s1</span> <span class="nv">s2</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.BIT_mode s1 s2 mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical RegA (Binop Bit mode&#39;) true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí BIT_mode s1 s2 mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical RegA (Binop Bit mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chka9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí BIT_mode s1 s2 mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical RegA (Binop Bit mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkaa"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">BIT_mode s1 s2 mode (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Bit mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkab"><span class="nb">rewrite</span> /BIT_mode.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC s2 =
       PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
       ‚àß Reg s2 = Reg s1
         ‚àß Flag s2 =
           (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
              <span class="kr">match</span> f <span class="kr">with</span>
              | spec.N =&gt; bit <span class="mi">7</span> (bv_and (Reg s1 A) w)
              | V =&gt; bit <span class="mi">6</span> (bv_and (Reg s1 A) w)
              | spec.Z =&gt;
                  bv_eqb (bv_and (Reg s1 A) w) <span class="mi">0</span>
              | _ =&gt; Flag s1 f
              <span class="kr">end</span>) ‚àß RAM s2 = RAM s1)
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Bit mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkac"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC =
       spec.PC s1
       `+Z` Z.of_nat
              (S
                 (<span class="kr">match</span>
                    mode&#39; <span class="kr">as</span> m
                    <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                  <span class="kr">with</span>
                  | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                  | Abs wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                  | Zpg wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                  | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                  | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                  | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                  <span class="kr">end</span> eq_refl))
       ‚àß Reg = spec.Reg s1
         ‚àß Flag =
           (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
              <span class="kr">match</span> f <span class="kr">with</span>
              | spec.N =&gt;
                  <span class="kr">match</span>
                    bv_unsigned
                      (bv_and (spec.Reg s1 A) w)
                  <span class="kr">with</span>
                  | <span class="mi">0</span>%Z =&gt; false
                  | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                  | Z.neg a =&gt;
                      negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                  <span class="kr">end</span>
              | V =&gt;
                  <span class="kr">match</span>
                    bv_unsigned
                      (bv_and (spec.Reg s1 A) w)
                  <span class="kr">with</span>
                  | <span class="mi">0</span>%Z =&gt; false
                  | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
                  | Z.neg a =&gt;
                      negb
                        (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
                  <span class="kr">end</span>
              | spec.Z =&gt;
                  bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
              | _ =&gt; spec.Flag s1 f
              <span class="kr">end</span>) ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(
                        bv_and w w2, 
                        spec.Flag s1 C,
                        <span class="kr">match</span>
                        bv_unsigned (bv_and w w2)
                        <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
                        <span class="kr">end</span>)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg := spec.Reg s1;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkad"><span class="nb">move</span>=&gt; [addr&#39; [w [/mode_spec m [fetch_w [-&gt; [-&gt; [-&gt; -&gt;]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[RegLoc A]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(bv_and w w2,
                        spec.Flag s1 C,
                        <span class="kr">match</span>
                        bv_unsigned (bv_and w w2)
                        <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
                        <span class="kr">end</span>)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg := spec.Reg s1;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkae"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc A)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     {[(bv_and w w2, 
                        spec.Flag s1 C,
                        <span class="kr">match</span>
                        bv_unsigned (bv_and w w2)
                        <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
                        <span class="kr">end</span>)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg := spec.Reg s1;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                  RAM :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkaf"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               {[(bv_and (spec.Reg s1 A) w2,
                  spec.Flag s1 C,
                  <span class="kr">match</span>
                    bv_unsigned
                      (bv_and (spec.Reg s1 A) w2)
                  <span class="kr">with</span>
                  | <span class="mi">0</span>%Z =&gt; false
                  | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
                  | Z.neg a =&gt;
                      negb
                        (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
                  <span class="kr">end</span>)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg := spec.Reg s1;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkb0"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg := spec.Reg s1;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned <span class="nl">?Goal</span> <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; <span class="nl">?Goal1</span>
          | spec.Z =&gt; bv_eqb <span class="nl">?Goal</span> <span class="mi">0</span>
          | C =&gt; <span class="nl">?Goal0</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chkb1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><label class="goal-separator" for="instruction-v-chkb1"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(bv_and (spec.Reg s1 A) w2,
                 spec.Flag s1 C,
                 <span class="kr">match</span>
                   bv_unsigned
                     (bv_and (spec.Reg s1 A) w2)
                 <span class="kr">with</span>
                 | <span class="mi">0</span>%Z =&gt; false
                 | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
                 | Z.neg a =&gt;
                     negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
                 <span class="kr">end</span>)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkb2"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(bv_and (spec.Reg s1 A) w2,
                 spec.Flag s1 C,
                 <span class="kr">match</span>
                   bv_unsigned
                     (bv_and (spec.Reg s1 A) w2)
                 <span class="kr">with</span>
                 | <span class="mi">0</span>%Z =&gt; false
                 | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
                 | Z.neg a =&gt;
                     negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
                 <span class="kr">end</span>)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkb3"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        {[(bv_and (spec.Reg s1 A) w2, 
           spec.Flag s1 C,
           <span class="kr">match</span>
             bv_unsigned (bv_and (spec.Reg s1 A) w2)
           <span class="kr">with</span>
           | <span class="mi">0</span>%Z =&gt; false
           | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
           | Z.neg a =&gt;
               negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
           <span class="kr">end</span>)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkb4"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[(bv_and (spec.Reg s1 A) w, 
     spec.Flag s1 C,
     <span class="kr">match</span> bv_unsigned (bv_and (spec.Reg s1 A) w) <span class="kr">with</span>
     | <span class="mi">0</span>%Z =&gt; false
     | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
     | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
     <span class="kr">end</span>)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkb5">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg := spec.Reg s1;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span>
                bv_unsigned (bv_and (spec.Reg s1 A) w)
              <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt;
              <span class="kr">match</span>
                bv_unsigned (bv_and (spec.Reg s1 A) w)
              <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
              <span class="kr">end</span>
          | spec.Z =&gt;
              bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
          | C =&gt; spec.Flag s1 C
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkb6">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|} =
{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          <span class="kr">match</span>
            bv_unsigned (bv_and (spec.Reg s1 A) w)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="mi">0</span>
               `max` <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkb7"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span>
         bv_unsigned (bv_and (spec.Reg s1 A) w)
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt;
       <span class="kr">match</span>
         bv_unsigned (bv_and (spec.Reg s1 A) w)
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
       <span class="kr">end</span>
   | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span>
         bv_unsigned (bv_and (spec.Reg s1 A) w)
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt;
       <span class="kr">match</span>
         bv_unsigned (bv_and (spec.Reg s1 A) w)
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">6</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">6</span>)
       <span class="kr">end</span>
   | spec.Z =&gt; bv_eqb (bv_and (spec.Reg s1 A) w) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkb8"><span class="kn">Lemma</span> <span class="nf">run_Adc</span> <span class="nv">s1</span> <span class="nv">s2</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.ADC_mode s1 s2 mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical RegA (Binop Adc mode&#39;) true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí ADC_mode s1 s2 mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical RegA (Binop Adc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkb9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí ADC_mode s1 s2 mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical RegA (Binop Adc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkba"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ADC_mode s1 s2 mode (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Adc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkbb"><span class="nb">have</span> [d d_def]: <span class="kr">exists</span> <span class="nv">d</span>, d = Flag s1 D <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">Flag</span> <span class="nv">s1</span> <span class="nv">D</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>d = Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ADC_mode s1 s2 mode (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Adc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkbc"><span class="nb">rewrite</span> /ADC_mode -d_def; <span class="nb">case</span>: d d_def =&gt; d_def.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> <span class="nv">w_out</span> : bv <span class="mi">8</span>) (<span class="nv">c_out</span> <span class="nv">v</span> : bool),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß ADC_decimal_relation 
         (Flag s1 C) (Reg s1 A) w_in w_out c_out
       ‚àß PC s2 =
         PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
         ‚àß Reg s2 = setReg s1 A w_out
           ‚àß Flag s2 =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt; bit <span class="mi">7</span> w_out
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; c_out
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>) ‚àß RAM s2 = RAM s1)
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Adc mode&#39;) true) s1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = Flag s1 D</span></span></span><br></div><label class="goal-separator" for="instruction-v-chkbd"><hr></label><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß (<span class="kr">let</span>
        &#39;(w_out, c) :=
         add_with_carry (Flag s1 C) (Reg s1 A) w_in <span class="kr">in</span>
         PC s2 =
         PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
         ‚àß Reg s2 = setReg s1 A w_out
           ‚àß Flag s2 =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt; bit <span class="mi">7</span> w_out
                | V =&gt;
                    negb
                      (bv_signed w_out =?
                       bv_signed (Reg s1 A) +
                       bv_signed w_in)%Z
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>) ‚àß RAM s2 = RAM s1))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Adc mode&#39;) true) s1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkbe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> <span class="nv">w_out</span> : bv <span class="mi">8</span>) (<span class="nv">c_out</span> <span class="nv">v</span> : bool),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß ADC_decimal_relation 
         (Flag s1 C) (Reg s1 A) w_in w_out c_out
       ‚àß PC s2 =
         PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
         ‚àß Reg s2 = setReg s1 A w_out
           ‚àß Flag s2 =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt; bit <span class="mi">7</span> w_out
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; c_out
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>) ‚àß RAM s2 = RAM s1)
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Adc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkbf"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> <span class="nv">w_out</span> : bv <span class="mi">8</span>) (<span class="nv">c_out</span> <span class="nv">v</span> : bool),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß ADC_decimal_relation 
         (spec.Flag s1 C) 
         (spec.Reg s1 A) w_in w_out c_out
       ‚àß PC =
         spec.PC s1
         `+Z` Z.of_nat
                (S
                   (<span class="kr">match</span>
                      mode&#39; <span class="kr">as</span> m
                      <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                    <span class="kr">with</span>
                    | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                    | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                    | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                    | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                    | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                    | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                    <span class="kr">end</span> eq_refl))
         ‚àß Reg = setReg s1 A w_out
           ‚àß Flag =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; c_out
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>) ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        <span class="kr">if</span> spec.Flag s1 D
                        <span class="kr">then</span>
                        ‚ä§
                        ‚â´= 
                        (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : ... * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        ADC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                        <span class="kr">else</span>
                        {[(
                        add_with_carry
                        (spec.Flag s1 C) w w2,
                        negb
                        (bv_signed
                        (trunc <span class="mi">8</span> (... + ...)) =?
                        bv_signed w + bv_signed w2)%Z)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkc0"><span class="nb">move</span>=&gt;
            [addr&#39; [w_in [w_out [c_out
                [v [/mode_spec m [fetch_w_in [is_dec_Adc
                    [-&gt; [-&gt; [-&gt; -&gt;]]]]]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w_out;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; v
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[RegLoc A]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        <span class="kr">if</span> spec.Flag s1 D
                        <span class="kr">then</span>
                        ‚ä§
                        ‚â´= 
                        (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        ADC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                        <span class="kr">else</span>
                        {[(
                        add_with_carry
                        (spec.Flag s1 C) w w2,
                        negb
                        (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend ... ... +
                        (...))) =?
                        bv_signed w + bv_signed w2)%Z)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkc1"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w_out;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; v
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc A)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     <span class="kr">if</span> spec.Flag s1 D
                     <span class="kr">then</span>
                      ‚ä§
                      ‚â´= 
                      (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        ADC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                     <span class="kr">else</span>
                      {[(
                     add_with_carry 
                       (spec.Flag s1 C) w w2,
                     negb
                       (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bool_to_bv <span class="mi">1</span> (...)) +
                        (bv_zero_extend (...) w +
                        bv_zero_extend (...) w2))) =?
                        bv_signed w + bv_signed w2)%Z)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                  RAM :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkc2"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w_out;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; v
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               <span class="kr">if</span> spec.Flag s1 D
               <span class="kr">then</span>
                ‚ä§
                ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                      propset_bind 
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        ADC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
               <span class="kr">else</span>
                {[(add_with_carry 
                     (spec.Flag s1 C) 
                     (spec.Reg s1 A) w2,
                   negb
                     (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w2))) =?
                      bv_signed (spec.Reg s1 A) +
                      bv_signed w2)%Z)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb A r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkc3"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w_out;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; v
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb A r&#39;
          <span class="kr">then</span> <span class="nl">?Goal0</span>
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned <span class="nl">?Goal0</span> <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; <span class="nl">?Goal2</span>
          | spec.Z =&gt; bv_eqb <span class="nl">?Goal0</span> <span class="mi">0</span>
          | C =&gt; <span class="nl">?Goal1</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chkc4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><label class="goal-separator" for="instruction-v-chkc4"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              <span class="kr">if</span> spec.Flag s1 D
              <span class="kr">then</span>
               ‚ä§
               ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                     propset_bind 
                       (bv <span class="mi">8</span> * bool)%type
                       (bv <span class="mi">8</span> * bool * bool)%type
                       (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(
                        wc, v)]})
                       {[ wc | 
                       ADC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
              <span class="kr">else</span>
               {[(add_with_carry 
                    (spec.Flag s1 C) 
                    (spec.Reg s1 A) w2,
                  negb
                    (bv_signed
                       (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w2))) =?
                     bv_signed (spec.Reg s1 A) +
                     bv_signed w2)%Z)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkc5"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              <span class="kr">if</span> spec.Flag s1 D
              <span class="kr">then</span>
               ‚ä§
               ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                     propset_bind 
                       (bv <span class="mi">8</span> * bool)%type
                       (bv <span class="mi">8</span> * bool * bool)%type
                       (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(
                        wc, v)]})
                       {[ wc | 
                       ADC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
              <span class="kr">else</span>
               {[(add_with_carry 
                    (spec.Flag s1 C) 
                    (spec.Reg s1 A) w2,
                  negb
                    (bv_signed
                       (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w2))) =?
                     bv_signed (spec.Reg s1 A) +
                     bv_signed w2)%Z)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkc6"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        <span class="kr">if</span> spec.Flag s1 D
        <span class="kr">then</span>
         ‚ä§
         ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
               propset_bind 
                 (bv <span class="mi">8</span> * bool)%type
                 (bv <span class="mi">8</span> * bool * bool)%type
                 (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
                 {[ wc | 
                 ADC_decimal_relation 
                   (spec.Flag s1 C) 
                   (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
        <span class="kr">else</span>
         {[(add_with_carry 
              (spec.Flag s1 C) 
              (spec.Reg s1 A) w2,
            negb
              (bv_signed
                 (trunc <span class="mi">8</span>
                    (bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>)
                       (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                     (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                      bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w2))) =?
               bv_signed (spec.Reg s1 A) +
               bv_signed w2)%Z)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkc7"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà (<span class="kr">if</span> spec.Flag s1 D
   <span class="kr">then</span>
    ‚ä§
    ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
          propset_bind (bv <span class="mi">8</span> * bool)%type
            (bv <span class="mi">8</span> * bool * bool)%type
            (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
            {[ wc | ADC_decimal_relation
                      (spec.Flag s1 C) 
                      (spec.Reg s1 A) w_in wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
   <span class="kr">else</span>
    {[(add_with_carry (spec.Flag s1 C) 
         (spec.Reg s1 A) w_in,
       negb
         (bv_signed
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
          bv_signed (spec.Reg s1 A) + bv_signed w_in)%Z)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkc8"><span class="nb">rewrite</span> -d_def.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà ‚ä§
  ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
        propset_bind (bv <span class="mi">8</span> * bool)%type
          (bv <span class="mi">8</span> * bool * bool)%type
          (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
          {[ wc | ADC_decimal_relation
                    (spec.Flag s1 C) 
                    (spec.Reg s1 A) w_in wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkc9"><span class="kr">exists</span> <span class="nv">v</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà propset_bind (bv <span class="mi">8</span> * bool)%type
    (bv <span class="mi">8</span> * bool * bool)%type
    (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
    {[ wc | ADC_decimal_relation 
              (spec.Flag s1 C) 
              (spec.Reg s1 A) w_in wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkca"><span class="kr">exists</span> (<span class="nv">w_out</span>,c_out); <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> is_dec_Adc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>) ‚àà {[(w_out, c_out, v)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkcb">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>ADC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w_out;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; v
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb A r&#39;
          <span class="kr">then</span> w_out
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; v
          | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
          | C =&gt; c_out
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkcc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß (<span class="kr">let</span>
        &#39;(w_out, c) :=
         add_with_carry (Flag s1 C) (Reg s1 A) w_in <span class="kr">in</span>
         PC s2 =
         PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
         ‚àß Reg s2 = setReg s1 A w_out
           ‚àß Flag s2 =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt; bit <span class="mi">7</span> w_out
                | V =&gt;
                    negb
                      (bv_signed w_out =?
                       bv_signed (Reg s1 A) +
                       bv_signed w_in)%Z
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>) ‚àß RAM s2 = RAM s1))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Adc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkcd"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß PC =
       spec.PC s1
       `+Z` Z.of_nat
              (S
                 (<span class="kr">match</span>
                    mode&#39; <span class="kr">as</span> m
                    <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                  <span class="kr">with</span>
                  | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                  | Abs wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                  | Zpg wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                  | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                  | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                  | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                  <span class="kr">end</span> eq_refl))
       ‚àß Reg =
         setReg s1 A
           (trunc <span class="mi">8</span>
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
         ‚àß Flag =
           (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
              <span class="kr">match</span> f <span class="kr">with</span>
              | spec.N =&gt;
                  <span class="kr">match</span>
                    bv_unsigned
                      (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
                  <span class="kr">with</span>
                  | <span class="mi">0</span>%Z =&gt; false
                  | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                  | Z.neg a =&gt;
                      negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                  <span class="kr">end</span>
              | V =&gt;
                  negb
                    (bv_signed
                       (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
                     bv_signed (spec.Reg s1 A) +
                     bv_signed w_in)%Z
              | spec.Z =&gt;
                  bv_eqb
                    (trunc <span class="mi">8</span>
                       (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
                    <span class="mi">0</span>
              | C =&gt;
                  <span class="kr">match</span>
                    bv_unsigned
                      (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                       (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))
                  <span class="kr">with</span>
                  | <span class="mi">0</span>%Z =&gt; false
                  | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
                  | Z.neg a =&gt;
                      negb
                        (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
                  <span class="kr">end</span>
              | _ =&gt; spec.Flag s1 f
              <span class="kr">end</span>) ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        <span class="kr">if</span> spec.Flag s1 D
                        <span class="kr">then</span>
                        ‚ä§
                        ‚â´= 
                        (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : ... * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        ADC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                        <span class="kr">else</span>
                        {[(
                        add_with_carry
                        (spec.Flag s1 C) w w2,
                        negb
                        (bv_signed
                        (trunc <span class="mi">8</span> (... + ...)) =?
                        bv_signed w + bv_signed w2)%Z)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkce"><span class="nb">move</span>=&gt; [addr&#39; [w_in [/mode_spec m [fetch_w_in tmp]]]]; <span class="nb">move</span>:tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl))
‚àß Reg =
  setReg s1 A
    (trunc <span class="mi">8</span>
       (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>)
          (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
        (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
         bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
  ‚àß Flag =
    (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
       <span class="kr">match</span> f <span class="kr">with</span>
       | spec.N =&gt;
           <span class="kr">match</span>
             bv_unsigned
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
           <span class="kr">with</span>
           | <span class="mi">0</span>%Z =&gt; false
           | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
           | Z.neg a =&gt;
               negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
           <span class="kr">end</span>
       | V =&gt;
           negb
             (bv_signed
                (trunc <span class="mi">8</span>
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>)
                      (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                    (bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>) 
                       (spec.Reg s1 A) +
                     bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
              bv_signed (spec.Reg s1 A) +
              bv_signed w_in)%Z
       | spec.Z =&gt;
           bv_eqb
             (trunc <span class="mi">8</span>
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>)
                   (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (spec.Reg s1 A) +
                  bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) <span class="mi">0</span>
       | C =&gt;
           <span class="kr">match</span>
             bv_unsigned
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))
           <span class="kr">with</span>
           | <span class="mi">0</span>%Z =&gt; false
           | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
           | Z.neg a =&gt;
               negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
           <span class="kr">end</span>
       | _ =&gt; spec.Flag s1 f
       <span class="kr">end</span>) ‚àß RAM = spec.RAM s1
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        <span class="kr">if</span> spec.Flag s1 D
                        <span class="kr">then</span>
                        ‚ä§
                        ‚â´= 
                        (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : ... * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        ADC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                        <span class="kr">else</span>
                        {[(
                        add_with_carry
                        (spec.Flag s1 C) w w2,
                        negb
                        (bv_signed
                        (trunc <span class="mi">8</span> (... + ...)) =?
                        bv_signed w + bv_signed w2)%Z)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkcf"><span class="nb">move</span>=&gt; [-&gt; [-&gt; [-&gt; -&gt;]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg :=
    setReg s1 A
      (trunc <span class="mi">8</span>
         (bv_zero_extend 
            (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
          (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
           bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)));
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>)
                    (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 A) +
                   bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          negb
            (bv_signed
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
             bv_signed (spec.Reg s1 A) +
             bv_signed w_in)%Z
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[RegLoc A]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        <span class="kr">if</span> spec.Flag s1 D
                        <span class="kr">then</span>
                        ‚ä§
                        ‚â´= 
                        (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        ADC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                        <span class="kr">else</span>
                        {[(
                        add_with_carry
                        (spec.Flag s1 C) w w2,
                        negb
                        (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend ... ... +
                        (...))) =?
                        bv_signed w + bv_signed w2)%Z)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkd0"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg :=
    setReg s1 A
      (trunc <span class="mi">8</span>
         (bv_zero_extend 
            (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
          (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
           bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)));
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>)
                    (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 A) +
                   bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          negb
            (bv_signed
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
             bv_signed (spec.Reg s1 A) +
             bv_signed w_in)%Z
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc A)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     <span class="kr">if</span> spec.Flag s1 D
                     <span class="kr">then</span>
                      ‚ä§
                      ‚â´= 
                      (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        ADC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                     <span class="kr">else</span>
                      {[(
                     add_with_carry 
                       (spec.Flag s1 C) w w2,
                     negb
                       (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bool_to_bv <span class="mi">1</span> (...)) +
                        (bv_zero_extend (...) w +
                        bv_zero_extend (...) w2))) =?
                        bv_signed w + bv_signed w2)%Z)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                  RAM :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkd1"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg :=
    setReg s1 A
      (trunc <span class="mi">8</span>
         (bv_zero_extend 
            (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
          (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
           bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)));
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>)
                    (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 A) +
                   bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          negb
            (bv_signed
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
             bv_signed (spec.Reg s1 A) +
             bv_signed w_in)%Z
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               <span class="kr">if</span> spec.Flag s1 D
               <span class="kr">then</span>
                ‚ä§
                ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                      propset_bind 
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        ADC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
               <span class="kr">else</span>
                {[(add_with_carry 
                     (spec.Flag s1 C) 
                     (spec.Reg s1 A) w2,
                   negb
                     (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w2))) =?
                      bv_signed (spec.Reg s1 A) +
                      bv_signed w2)%Z)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb A r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkd2"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg :=
    setReg s1 A
      (trunc <span class="mi">8</span>
         (bv_zero_extend 
            (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
          (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
           bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)));
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>)
                    (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 A) +
                   bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          negb
            (bv_signed
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
             bv_signed (spec.Reg s1 A) +
             bv_signed w_in)%Z
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb A r&#39;
          <span class="kr">then</span> <span class="nl">?Goal</span>
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned <span class="nl">?Goal</span> <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; <span class="nl">?Goal1</span>
          | spec.Z =&gt; bv_eqb <span class="nl">?Goal</span> <span class="mi">0</span>
          | C =&gt; <span class="nl">?Goal0</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><label class="goal-separator" for="instruction-v-chkd3"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              <span class="kr">if</span> spec.Flag s1 D
              <span class="kr">then</span>
               ‚ä§
               ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                     propset_bind 
                       (bv <span class="mi">8</span> * bool)%type
                       (bv <span class="mi">8</span> * bool * bool)%type
                       (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(
                        wc, v)]})
                       {[ wc | 
                       ADC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
              <span class="kr">else</span>
               {[(add_with_carry 
                    (spec.Flag s1 C) 
                    (spec.Reg s1 A) w2,
                  negb
                    (bv_signed
                       (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w2))) =?
                     bv_signed (spec.Reg s1 A) +
                     bv_signed w2)%Z)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkd4"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              <span class="kr">if</span> spec.Flag s1 D
              <span class="kr">then</span>
               ‚ä§
               ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                     propset_bind 
                       (bv <span class="mi">8</span> * bool)%type
                       (bv <span class="mi">8</span> * bool * bool)%type
                       (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(
                        wc, v)]})
                       {[ wc | 
                       ADC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
              <span class="kr">else</span>
               {[(add_with_carry 
                    (spec.Flag s1 C) 
                    (spec.Reg s1 A) w2,
                  negb
                    (bv_signed
                       (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w2))) =?
                     bv_signed (spec.Reg s1 A) +
                     bv_signed w2)%Z)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkd5"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        <span class="kr">if</span> spec.Flag s1 D
        <span class="kr">then</span>
         ‚ä§
         ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
               propset_bind 
                 (bv <span class="mi">8</span> * bool)%type
                 (bv <span class="mi">8</span> * bool * bool)%type
                 (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
                 {[ wc | 
                 ADC_decimal_relation 
                   (spec.Flag s1 C) 
                   (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
        <span class="kr">else</span>
         {[(add_with_carry 
              (spec.Flag s1 C) 
              (spec.Reg s1 A) w2,
            negb
              (bv_signed
                 (trunc <span class="mi">8</span>
                    (bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>)
                       (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                     (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                      bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w2))) =?
               bv_signed (spec.Reg s1 A) +
               bv_signed w2)%Z)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkd6"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (<span class="kr">if</span> spec.Flag s1 D
   <span class="kr">then</span>
    ‚ä§
    ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
          propset_bind (bv <span class="mi">8</span> * bool)%type
            (bv <span class="mi">8</span> * bool * bool)%type
            (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
            {[ wc | ADC_decimal_relation
                      (spec.Flag s1 C) 
                      (spec.Reg s1 A) w_in wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
   <span class="kr">else</span>
    {[(add_with_carry (spec.Flag s1 C) 
         (spec.Reg s1 A) w_in,
       negb
         (bv_signed
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
          bv_signed (spec.Reg s1 A) + bv_signed w_in)%Z)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkd7"><span class="nb">rewrite</span> -d_def.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[(add_with_carry (spec.Flag s1 C) 
       (spec.Reg s1 A) w_in,
     negb
       (bv_signed
          (trunc <span class="mi">8</span>
             (bv_zero_extend 
                (<span class="mi">8</span> + <span class="mi">1</span>)
                (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
              (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
               bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
        bv_signed (spec.Reg s1 A) + bv_signed w_in)%Z)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkd8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg :=
    setReg s1 A
      (trunc <span class="mi">8</span>
         (bv_zero_extend 
            (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
          (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
           bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)));
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>)
                    (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 A) +
                   bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          negb
            (bv_signed
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
             bv_signed (spec.Reg s1 A) +
             bv_signed w_in)%Z
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb A r&#39;
          <span class="kr">then</span>
           trunc <span class="mi">8</span>
             (bv_zero_extend 
                (<span class="mi">8</span> + <span class="mi">1</span>)
                (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
              (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
               bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span>
                bv_unsigned
                  (trunc <span class="mi">8</span>
                     (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                      (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                       bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in)))
              <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt;
              negb
                (bv_signed
                   (trunc <span class="mi">8</span>
                      (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                       (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) =?
                 bv_signed (spec.Reg s1 A) +
                 bv_signed w_in)%Z
          | spec.Z =&gt;
              bv_eqb
                (trunc <span class="mi">8</span>
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>)
                      (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                    (bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>) 
                       (spec.Reg s1 A) +
                     bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))) <span class="mi">0</span>
          | C =&gt;
              bit (Z.of_N <span class="mi">8</span>)
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>)
                   (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (spec.Reg s1 A) +
                  bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) w_in))
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkd9"><span class="kn">Lemma</span> <span class="nf">run_Sbc</span> <span class="nv">s1</span> <span class="nv">s2</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.SBC_mode s1 s2 mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical RegA (Binop Sbc mode&#39;) true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí SBC_mode s1 s2 mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical RegA (Binop Sbc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkda"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí SBC_mode s1 s2 mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical RegA (Binop Sbc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkdb"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SBC_mode s1 s2 mode (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Sbc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkdc"><span class="nb">have</span> [d d_def]: <span class="kr">exists</span> <span class="nv">d</span>, d = Flag s1 D <span class="bp">by</span> <span class="kr">exists</span> (<span class="nv">Flag</span> <span class="nv">s1</span> <span class="nv">D</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>d = Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">SBC_mode s1 s2 mode (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Sbc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkdd"><span class="nb">rewrite</span> /SBC_mode -d_def; <span class="nb">case</span>: d d_def =&gt; d_def.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> <span class="nv">w_out</span> : bv <span class="mi">8</span>) (<span class="nv">c_out</span> <span class="nv">v</span> : bool),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß SBC_decimal_relation 
         (Flag s1 C) (Reg s1 A) w_in w_out c_out
       ‚àß PC s2 =
         PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
         ‚àß Reg s2 = setReg s1 A w_out
           ‚àß Flag s2 =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt; bit <span class="mi">7</span> w_out
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; c_out
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>) ‚àß RAM s2 = RAM s1)
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Sbc mode&#39;) true) s1</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chkde" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = Flag s1 D</span></span></span><br></div><label class="goal-separator" for="instruction-v-chkde"><hr></label><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß (<span class="kr">let</span>
        &#39;(w_out, c) :=
         sub_with_inverted_borrow 
           (Flag s1 C) (Reg s1 A) w_in <span class="kr">in</span>
         PC s2 =
         PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
         ‚àß Reg s2 = setReg s1 A w_out
           ‚àß Flag s2 =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt; bit <span class="mi">7</span> w_out
                | V =&gt;
                    negb
                      (bv_signed w_out =?
                       bv_signed (Reg s1 A) -
                       bv_signed w_in)%Z
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>) ‚àß RAM s2 = RAM s1))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Sbc mode&#39;) true) s1</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkdf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> <span class="nv">w_out</span> : bv <span class="mi">8</span>) (<span class="nv">c_out</span> <span class="nv">v</span> : bool),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß SBC_decimal_relation 
         (Flag s1 C) (Reg s1 A) w_in w_out c_out
       ‚àß PC s2 =
         PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
         ‚àß Reg s2 = setReg s1 A w_out
           ‚àß Flag s2 =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt; bit <span class="mi">7</span> w_out
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; c_out
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>) ‚àß RAM s2 = RAM s1)
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Sbc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chke0"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> <span class="nv">w_out</span> : bv <span class="mi">8</span>) (<span class="nv">c_out</span> <span class="nv">v</span> : bool),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß SBC_decimal_relation 
         (spec.Flag s1 C) 
         (spec.Reg s1 A) w_in w_out c_out
       ‚àß PC =
         spec.PC s1
         `+Z` Z.of_nat
                (S
                   (<span class="kr">match</span>
                      mode&#39; <span class="kr">as</span> m
                      <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                    <span class="kr">with</span>
                    | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                    | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                    | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                    | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                    | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                    | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                    <span class="kr">end</span> eq_refl))
         ‚àß Reg = setReg s1 A w_out
           ‚àß Flag =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; c_out
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>) ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        <span class="kr">if</span> spec.Flag s1 D
                        <span class="kr">then</span>
                        ‚ä§
                        ‚â´= 
                        (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : ... * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        SBC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                        <span class="kr">else</span>
                        {[(
                        sub_with_inverted_borrow
                        (spec.Flag s1 C) w w2,
                        negb
                        (bv_signed
                        (trunc <span class="mi">8</span> (... + ...)) =?
                        bv_signed w - bv_signed w2)%Z)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chke1"><span class="nb">move</span>=&gt;
            [addr&#39; [w_in [w_out [c_out
                [v [/mode_spec m [fetch_w_in [is_dec_Adc
                    [-&gt; [-&gt; [-&gt; -&gt;]]]]]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w_out;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; v
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[RegLoc A]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        <span class="kr">if</span> spec.Flag s1 D
                        <span class="kr">then</span>
                        ‚ä§
                        ‚â´= 
                        (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        SBC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                        <span class="kr">else</span>
                        {[(
                        sub_with_inverted_borrow
                        (spec.Flag s1 C) w w2,
                        negb
                        (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend ... ... +
                        (...))) =?
                        bv_signed w - bv_signed w2)%Z)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chke2"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w_out;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; v
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc A)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     <span class="kr">if</span> spec.Flag s1 D
                     <span class="kr">then</span>
                      ‚ä§
                      ‚â´= 
                      (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        SBC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                     <span class="kr">else</span>
                      {[(
                     sub_with_inverted_borrow
                       (spec.Flag s1 C) w w2,
                     negb
                       (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bool_to_bv <span class="mi">1</span> (...)) +
                        (bv_zero_extend (...) w +
                        bv_zero_extend (...) (...)))) =?
                        bv_signed w - bv_signed w2)%Z)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                  RAM :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chke3"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w_out;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; v
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               <span class="kr">if</span> spec.Flag s1 D
               <span class="kr">then</span>
                ‚ä§
                ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                      propset_bind 
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        SBC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
               <span class="kr">else</span>
                {[(sub_with_inverted_borrow
                     (spec.Flag s1 C) 
                     (spec.Reg s1 A) w2,
                   negb
                     (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w2)))) =?
                      bv_signed (spec.Reg s1 A) -
                      bv_signed w2)%Z)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb A r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chke4"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w_out;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; v
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb A r&#39;
          <span class="kr">then</span> <span class="nl">?Goal0</span>
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned <span class="nl">?Goal0</span> <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; <span class="nl">?Goal2</span>
          | spec.Z =&gt; bv_eqb <span class="nl">?Goal0</span> <span class="mi">0</span>
          | C =&gt; <span class="nl">?Goal1</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chke5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><label class="goal-separator" for="instruction-v-chke5"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              <span class="kr">if</span> spec.Flag s1 D
              <span class="kr">then</span>
               ‚ä§
               ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                     propset_bind 
                       (bv <span class="mi">8</span> * bool)%type
                       (bv <span class="mi">8</span> * bool * bool)%type
                       (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(
                        wc, v)]})
                       {[ wc | 
                       SBC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
              <span class="kr">else</span>
               {[(sub_with_inverted_borrow
                    (spec.Flag s1 C) 
                    (spec.Reg s1 A) w2,
                  negb
                    (bv_signed
                       (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w2)))) =?
                     bv_signed (spec.Reg s1 A) -
                     bv_signed w2)%Z)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chke6"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              <span class="kr">if</span> spec.Flag s1 D
              <span class="kr">then</span>
               ‚ä§
               ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                     propset_bind 
                       (bv <span class="mi">8</span> * bool)%type
                       (bv <span class="mi">8</span> * bool * bool)%type
                       (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(
                        wc, v)]})
                       {[ wc | 
                       SBC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
              <span class="kr">else</span>
               {[(sub_with_inverted_borrow
                    (spec.Flag s1 C) 
                    (spec.Reg s1 A) w2,
                  negb
                    (bv_signed
                       (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w2)))) =?
                     bv_signed (spec.Reg s1 A) -
                     bv_signed w2)%Z)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chke7"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        <span class="kr">if</span> spec.Flag s1 D
        <span class="kr">then</span>
         ‚ä§
         ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
               propset_bind 
                 (bv <span class="mi">8</span> * bool)%type
                 (bv <span class="mi">8</span> * bool * bool)%type
                 (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
                 {[ wc | 
                 SBC_decimal_relation 
                   (spec.Flag s1 C) 
                   (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
        <span class="kr">else</span>
         {[(sub_with_inverted_borrow 
              (spec.Flag s1 C) 
              (spec.Reg s1 A) w2,
            negb
              (bv_signed
                 (trunc <span class="mi">8</span>
                    (bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>)
                       (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                     (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                      bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w2)))) =?
               bv_signed (spec.Reg s1 A) -
               bv_signed w2)%Z)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chke8"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà (<span class="kr">if</span> spec.Flag s1 D
   <span class="kr">then</span>
    ‚ä§
    ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
          propset_bind (bv <span class="mi">8</span> * bool)%type
            (bv <span class="mi">8</span> * bool * bool)%type
            (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
            {[ wc | SBC_decimal_relation
                      (spec.Flag s1 C) 
                      (spec.Reg s1 A) w_in wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
   <span class="kr">else</span>
    {[(sub_with_inverted_borrow 
         (spec.Flag s1 C) 
         (spec.Reg s1 A) w_in,
       negb
         (bv_signed
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))) =?
          bv_signed (spec.Reg s1 A) - bv_signed w_in)%Z)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chke9"><span class="nb">rewrite</span> -d_def.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà ‚ä§
  ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
        propset_bind (bv <span class="mi">8</span> * bool)%type
          (bv <span class="mi">8</span> * bool * bool)%type
          (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
          {[ wc | SBC_decimal_relation
                    (spec.Flag s1 C) 
                    (spec.Reg s1 A) w_in wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkea"><span class="kr">exists</span> <span class="nv">v</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">done</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>)
‚àà propset_bind (bv <span class="mi">8</span> * bool)%type
    (bv <span class="mi">8</span> * bool * bool)%type
    (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
    {[ wc | SBC_decimal_relation 
              (spec.Flag s1 C) 
              (spec.Reg s1 A) w_in wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkeb"><span class="kr">exists</span> (<span class="nv">w_out</span>,c_out); <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> is_dec_Adc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>, <span class="nl">?Goal2</span>) ‚àà {[(w_out, c_out, v)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkec">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>true = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in, w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out, v</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_dec_Adc</var><span class="hyp-type"><b>: </b><span>SBC_decimal_relation (spec.Flag s1 C)
  (spec.Reg s1 A) w_in w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w_out;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; v
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb A r&#39;
          <span class="kr">then</span> w_out
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; v
          | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
          | C =&gt; c_out
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chked">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß (<span class="kr">let</span>
        &#39;(w_out, c) :=
         sub_with_inverted_borrow 
           (Flag s1 C) (Reg s1 A) w_in <span class="kr">in</span>
         PC s2 =
         PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
         ‚àß Reg s2 = setReg s1 A w_out
           ‚àß Flag s2 =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt; bit <span class="mi">7</span> w_out
                | V =&gt;
                    negb
                      (bv_signed w_out =?
                       bv_signed (Reg s1 A) -
                       bv_signed w_in)%Z
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>) ‚àß RAM s2 = RAM s1))
‚Üí s2
  ‚àà run_instr (Typical RegA (Binop Sbc mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkee"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß PC =
       spec.PC s1
       `+Z` Z.of_nat
              (S
                 (<span class="kr">match</span>
                    mode&#39; <span class="kr">as</span> m
                    <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                  <span class="kr">with</span>
                  | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                  | Abs wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                  | Zpg wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                  | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                  | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                  | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                  <span class="kr">end</span> eq_refl))
       ‚àß Reg =
         setReg s1 A
           (trunc <span class="mi">8</span>
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
         ‚àß Flag =
           (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
              <span class="kr">match</span> f <span class="kr">with</span>
              | spec.N =&gt;
                  <span class="kr">match</span>
                    bv_unsigned
                      (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w_in))))
                  <span class="kr">with</span>
                  | <span class="mi">0</span>%Z =&gt; false
                  | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                  | Z.neg a =&gt;
                      negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                  <span class="kr">end</span>
              | V =&gt;
                  negb
                    (bv_signed
                       (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w_in)))) =?
                     bv_signed (spec.Reg s1 A) -
                     bv_signed w_in)%Z
              | spec.Z =&gt;
                  bv_eqb
                    (trunc <span class="mi">8</span>
                       (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w_in)))) <span class="mi">0</span>
              | C =&gt;
                  <span class="kr">match</span>
                    bv_unsigned
                      (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                       (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w_in)))
                  <span class="kr">with</span>
                  | <span class="mi">0</span>%Z =&gt; false
                  | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
                  | Z.neg a =&gt;
                      negb
                        (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
                  <span class="kr">end</span>
              | _ =&gt; spec.Flag s1 f
              <span class="kr">end</span>) ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        <span class="kr">if</span> spec.Flag s1 D
                        <span class="kr">then</span>
                        ‚ä§
                        ‚â´= 
                        (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : ... * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        SBC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                        <span class="kr">else</span>
                        {[(
                        sub_with_inverted_borrow
                        (spec.Flag s1 C) w w2,
                        negb
                        (bv_signed
                        (trunc <span class="mi">8</span> (... + ...)) =?
                        bv_signed w - bv_signed w2)%Z)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkef"><span class="nb">move</span>=&gt; [addr&#39; [w_in [/mode_spec m [fetch_w_in tmp]]]]; <span class="nb">move</span>:tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl))
‚àß Reg =
  setReg s1 A
    (trunc <span class="mi">8</span>
       (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>)
          (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
        (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
         bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
  ‚àß Flag =
    (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
       <span class="kr">match</span> f <span class="kr">with</span>
       | spec.N =&gt;
           <span class="kr">match</span>
             bv_unsigned
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (bv_not w_in))))
           <span class="kr">with</span>
           | <span class="mi">0</span>%Z =&gt; false
           | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
           | Z.neg a =&gt;
               negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
           <span class="kr">end</span>
       | V =&gt;
           negb
             (bv_signed
                (trunc <span class="mi">8</span>
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>)
                      (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                    (bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>) 
                       (spec.Reg s1 A) +
                     bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>) 
                       (bv_not w_in)))) =?
              bv_signed (spec.Reg s1 A) -
              bv_signed w_in)%Z
       | spec.Z =&gt;
           bv_eqb
             (trunc <span class="mi">8</span>
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>)
                   (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (spec.Reg s1 A) +
                  bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
             <span class="mi">0</span>
       | C =&gt;
           <span class="kr">match</span>
             bv_unsigned
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
           <span class="kr">with</span>
           | <span class="mi">0</span>%Z =&gt; false
           | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
           | Z.neg a =&gt;
               negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
           <span class="kr">end</span>
       | _ =&gt; spec.Flag s1 f
       <span class="kr">end</span>) ‚àß RAM = spec.RAM s1
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        <span class="kr">if</span> spec.Flag s1 D
                        <span class="kr">then</span>
                        ‚ä§
                        ‚â´= 
                        (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : ... * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        SBC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                        <span class="kr">else</span>
                        {[(
                        sub_with_inverted_borrow
                        (spec.Flag s1 C) w w2,
                        negb
                        (bv_signed
                        (trunc <span class="mi">8</span> (... + ...)) =?
                        bv_signed w - bv_signed w2)%Z)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkf0"><span class="nb">move</span>=&gt; [-&gt; [-&gt; [-&gt; -&gt;]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg :=
    setReg s1 A
      (trunc <span class="mi">8</span>
         (bv_zero_extend 
            (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
          (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
           bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))));
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>)
                    (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 A) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          negb
            (bv_signed
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (bv_not w_in)))) =?
             bv_signed (spec.Reg s1 A) -
             bv_signed w_in)%Z
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[RegLoc A]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        <span class="kr">if</span> spec.Flag s1 D
                        <span class="kr">then</span>
                        ‚ä§
                        ‚â´= 
                        (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        SBC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                        <span class="kr">else</span>
                        {[(
                        sub_with_inverted_borrow
                        (spec.Flag s1 C) w w2,
                        negb
                        (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend ... ... +
                        (...))) =?
                        bv_signed w - bv_signed w2)%Z)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkf1"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg :=
    setReg s1 A
      (trunc <span class="mi">8</span>
         (bv_zero_extend 
            (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
          (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
           bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))));
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>)
                    (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 A) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          negb
            (bv_signed
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (bv_not w_in)))) =?
             bv_signed (spec.Reg s1 A) -
             bv_signed w_in)%Z
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc A)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     <span class="kr">if</span> spec.Flag s1 D
                     <span class="kr">then</span>
                      ‚ä§
                      ‚â´= 
                      (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                        propset_bind
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        SBC_decimal_relation
                        (spec.Flag s1 C) w w2 wc.<span class="mi">1</span>
                        wc.<span class="mi">2</span> ]})
                     <span class="kr">else</span>
                      {[(
                     sub_with_inverted_borrow
                       (spec.Flag s1 C) w w2,
                     negb
                       (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bool_to_bv <span class="mi">1</span> (...)) +
                        (bv_zero_extend (...) w +
                        bv_zero_extend (...) (...)))) =?
                        bv_signed w - bv_signed w2)%Z)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                  RAM :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkf2"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg :=
    setReg s1 A
      (trunc <span class="mi">8</span>
         (bv_zero_extend 
            (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
          (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
           bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))));
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>)
                    (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 A) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          negb
            (bv_signed
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (bv_not w_in)))) =?
             bv_signed (spec.Reg s1 A) -
             bv_signed w_in)%Z
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               <span class="kr">if</span> spec.Flag s1 D
               <span class="kr">then</span>
                ‚ä§
                ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                      propset_bind 
                        (bv <span class="mi">8</span> * bool)%type
                        (bv <span class="mi">8</span> * bool * bool)%type
                        (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(wc, v)]})
                        {[ wc | 
                        SBC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
               <span class="kr">else</span>
                {[(sub_with_inverted_borrow
                     (spec.Flag s1 C) 
                     (spec.Reg s1 A) w2,
                   negb
                     (bv_signed
                        (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w2)))) =?
                      bv_signed (spec.Reg s1 A) -
                      bv_signed w2)%Z)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb A r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkf3"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg :=
    setReg s1 A
      (trunc <span class="mi">8</span>
         (bv_zero_extend 
            (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
          (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
           bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))));
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>)
                    (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 A) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          negb
            (bv_signed
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (bv_not w_in)))) =?
             bv_signed (spec.Reg s1 A) -
             bv_signed w_in)%Z
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb A r&#39;
          <span class="kr">then</span> <span class="nl">?Goal</span>
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned <span class="nl">?Goal</span> <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; <span class="nl">?Goal1</span>
          | spec.Z =&gt; bv_eqb <span class="nl">?Goal</span> <span class="mi">0</span>
          | C =&gt; <span class="nl">?Goal0</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chkf4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><label class="goal-separator" for="instruction-v-chkf4"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              <span class="kr">if</span> spec.Flag s1 D
              <span class="kr">then</span>
               ‚ä§
               ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                     propset_bind 
                       (bv <span class="mi">8</span> * bool)%type
                       (bv <span class="mi">8</span> * bool * bool)%type
                       (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(
                        wc, v)]})
                       {[ wc | 
                       SBC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
              <span class="kr">else</span>
               {[(sub_with_inverted_borrow
                    (spec.Flag s1 C) 
                    (spec.Reg s1 A) w2,
                  negb
                    (bv_signed
                       (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w2)))) =?
                     bv_signed (spec.Reg s1 A) -
                     bv_signed w2)%Z)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkf5"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              <span class="kr">if</span> spec.Flag s1 D
              <span class="kr">then</span>
               ‚ä§
               ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
                     propset_bind 
                       (bv <span class="mi">8</span> * bool)%type
                       (bv <span class="mi">8</span> * bool * bool)%type
                       (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool,
                        {[(
                        wc, v)]})
                       {[ wc | 
                       SBC_decimal_relation
                        (spec.Flag s1 C)
                        (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
              <span class="kr">else</span>
               {[(sub_with_inverted_borrow
                    (spec.Flag s1 C) 
                    (spec.Reg s1 A) w2,
                  negb
                    (bv_signed
                       (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w2)))) =?
                     bv_signed (spec.Reg s1 A) -
                     bv_signed w2)%Z)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkf6"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        <span class="kr">if</span> spec.Flag s1 D
        <span class="kr">then</span>
         ‚ä§
         ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
               propset_bind 
                 (bv <span class="mi">8</span> * bool)%type
                 (bv <span class="mi">8</span> * bool * bool)%type
                 (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
                 {[ wc | 
                 SBC_decimal_relation 
                   (spec.Flag s1 C) 
                   (spec.Reg s1 A) w2 wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
        <span class="kr">else</span>
         {[(sub_with_inverted_borrow 
              (spec.Flag s1 C) 
              (spec.Reg s1 A) w2,
            negb
              (bv_signed
                 (trunc <span class="mi">8</span>
                    (bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>)
                       (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                     (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                      bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w2)))) =?
               bv_signed (spec.Reg s1 A) -
               bv_signed w2)%Z)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkf7"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (<span class="kr">if</span> spec.Flag s1 D
   <span class="kr">then</span>
    ‚ä§
    ‚â´= (<span class="kr">Œª</span> <span class="nv">v</span> : bool,
          propset_bind (bv <span class="mi">8</span> * bool)%type
            (bv <span class="mi">8</span> * bool * bool)%type
            (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, v)]})
            {[ wc | SBC_decimal_relation
                      (spec.Flag s1 C) 
                      (spec.Reg s1 A) w_in wc.<span class="mi">1</span> wc.<span class="mi">2</span> ]})
   <span class="kr">else</span>
    {[(sub_with_inverted_borrow 
         (spec.Flag s1 C) 
         (spec.Reg s1 A) w_in,
       negb
         (bv_signed
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))) =?
          bv_signed (spec.Reg s1 A) - bv_signed w_in)%Z)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkf8"><span class="nb">rewrite</span> -d_def.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[(sub_with_inverted_borrow 
       (spec.Flag s1 C) (spec.Reg s1 A) w_in,
     negb
       (bv_signed
          (trunc <span class="mi">8</span>
             (bv_zero_extend 
                (<span class="mi">8</span> + <span class="mi">1</span>)
                (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
              (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
               bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))) =?
        bv_signed (spec.Reg s1 A) - bv_signed w_in)%Z)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkf9">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>d_def</var><span class="hyp-type"><b>: </b><span>false = spec.Flag s1 D</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg :=
    setReg s1 A
      (trunc <span class="mi">8</span>
         (bv_zero_extend 
            (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
          (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
           bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))));
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>)
                    (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 A) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt;
          negb
            (bv_signed
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>)
                     (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 A) +
                    bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (bv_not w_in)))) =?
             bv_signed (spec.Reg s1 A) -
             bv_signed w_in)%Z
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>)
                  (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 A) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>)
                 (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
          <span class="kr">if</span> reg_eqb A r&#39;
          <span class="kr">then</span>
           trunc <span class="mi">8</span>
             (bv_zero_extend 
                (<span class="mi">8</span> + <span class="mi">1</span>)
                (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
              (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 A) +
               bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">else</span> spec.Reg s1 r&#39;;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span>
                bv_unsigned
                  (trunc <span class="mi">8</span>
                     (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                      (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                       bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w_in))))
              <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt;
              negb
                (bv_signed
                   (trunc <span class="mi">8</span>
                      (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>)
                        (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                       (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 A) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w_in)))) =?
                 bv_signed (spec.Reg s1 A) -
                 bv_signed w_in)%Z
          | spec.Z =&gt;
              bv_eqb
                (trunc <span class="mi">8</span>
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>)
                      (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                    (bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>) 
                       (spec.Reg s1 A) +
                     bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>) 
                       (bv_not w_in)))) <span class="mi">0</span>
          | C =&gt;
              bit (Z.of_N <span class="mi">8</span>)
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>)
                   (bool_to_bv <span class="mi">1</span> (spec.Flag s1 C)) +
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (spec.Reg s1 A) +
                  bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">done</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkfa"><span class="kn">Lemma</span> <span class="nf">run_Cmp</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">r</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.CMP_mode s1 s2 r mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical (RegMode r) (Binop Cmp mode&#39;) true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí CMP_mode s1 s2 r mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical (RegMode r) (Binop Cmp mode&#39;) true)
          s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkfb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí CMP_mode s1 s2 r mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical (RegMode r) (Binop Cmp mode&#39;) true)
          s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkfc"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">CMP_mode s1 s2 r mode (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr
      (Typical (RegMode r) (Binop Cmp mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkfd"><span class="nb">rewrite</span> /CMP_mode.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß (<span class="kr">let</span>
        &#39;(w0, c) :=
         sub_with_inverted_borrow true (Reg s1 r) w <span class="kr">in</span>
         PC s2 =
         PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
         ‚àß Reg s2 = Reg s1
           ‚àß Flag s2 =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt; bit <span class="mi">7</span> w0
                | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>) ‚àß RAM s2 = RAM s1))
‚Üí s2
  ‚àà run_instr
      (Typical (RegMode r) (Binop Cmp mode&#39;) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkfe"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC =
       spec.PC s1
       `+Z` Z.of_nat
              (S
                 (<span class="kr">match</span>
                    mode&#39; <span class="kr">as</span> m
                    <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                  <span class="kr">with</span>
                  | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                  | Abs wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                  | Zpg wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                  | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                  | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                  | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                  <span class="kr">end</span> eq_refl))
       ‚àß Reg = spec.Reg s1
         ‚àß Flag =
           (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
              <span class="kr">match</span> f <span class="kr">with</span>
              | spec.N =&gt;
                  <span class="kr">match</span>
                    bv_unsigned
                      (trunc <span class="mi">8</span>
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bool_to_bv <span class="mi">1</span> true) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 r) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w))))
                  <span class="kr">with</span>
                  | <span class="mi">0</span>%Z =&gt; false
                  | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                  | Z.neg a =&gt;
                      negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                  <span class="kr">end</span>
              | spec.Z =&gt;
                  bv_eqb
                    (trunc <span class="mi">8</span>
                       (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bool_to_bv <span class="mi">1</span> true) +
                        (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 r) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w)))) <span class="mi">0</span>
              | C =&gt;
                  <span class="kr">match</span>
                    bv_unsigned
                      (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bool_to_bv <span class="mi">1</span> true) +
                       (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 r) +
                        bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w)))
                  <span class="kr">with</span>
                  | <span class="mi">0</span>%Z =&gt; false
                  | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
                  | Z.neg a =&gt;
                      negb
                        (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
                  <span class="kr">end</span>
              | _ =&gt; spec.Flag s1 f
              <span class="kr">end</span>) ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc r]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(
                        sub_with_inverted_borrow true
                        w w2, 
                        spec.Flag s1 V)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg := spec.Reg s1;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chkff"><span class="nb">move</span>=&gt; [addr&#39; [w_in [/mode_spec m [fetch_w_in tmp]]]]; <span class="nb">move</span>: tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl))
‚àß Reg = spec.Reg s1
  ‚àß Flag =
    (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
       <span class="kr">match</span> f <span class="kr">with</span>
       | spec.N =&gt;
           <span class="kr">match</span>
             bv_unsigned
               (trunc <span class="mi">8</span>
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bool_to_bv <span class="mi">1</span> true) +
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (spec.Reg s1 r) +
                    bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (bv_not w_in))))
           <span class="kr">with</span>
           | <span class="mi">0</span>%Z =&gt; false
           | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
           | Z.neg a =&gt;
               negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
           <span class="kr">end</span>
       | spec.Z =&gt;
           bv_eqb
             (trunc <span class="mi">8</span>
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (bool_to_bv <span class="mi">1</span> true) +
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (spec.Reg s1 r) +
                  bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
             <span class="mi">0</span>
       | C =&gt;
           <span class="kr">match</span>
             bv_unsigned
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>) 
                  (bool_to_bv <span class="mi">1</span> true) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 r) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
           <span class="kr">with</span>
           | <span class="mi">0</span>%Z =&gt; false
           | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
           | Z.neg a =&gt;
               negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
           <span class="kr">end</span>
       | _ =&gt; spec.Flag s1 f
       <span class="kr">end</span>) ‚àß RAM = spec.RAM s1
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc r]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
                 ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                       read s1 l0
                       ‚â´= 
                       (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(
                        sub_with_inverted_borrow true
                        w w2, 
                        spec.Flag s1 V)]})))
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg := spec.Reg s1;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk100"><span class="nb">move</span>=&gt; [-&gt; [-&gt; [-&gt; -&gt;]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (bool_to_bv <span class="mi">1</span> true) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 r) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>) 
                  (bool_to_bv <span class="mi">1</span> true) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 r) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>) 
                 (bool_to_bv <span class="mi">1</span> true) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[RegLoc r]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
               ‚â´= (<span class="kr">Œª</span> <span class="nv">l0</span> : loc,
                     read s1 l0
                     ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                        {[(sub_with_inverted_borrow
                        true w w2, 
                        spec.Flag s1 V)]})))
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg := spec.Reg s1;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk101"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (bool_to_bv <span class="mi">1</span> true) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 r) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>) 
                  (bool_to_bv <span class="mi">1</span> true) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 r) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>) 
                 (bool_to_bv <span class="mi">1</span> true) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc r)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
         ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
               read s1 l
               ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                     {[(sub_with_inverted_borrow true
                        w w2, 
                        spec.Flag s1 V)]})))
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg := spec.Reg s1;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
                  RAM :=
                    <span class="kr">match</span> RegLoc r <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk102"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (bool_to_bv <span class="mi">1</span> true) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 r) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>) 
                  (bool_to_bv <span class="mi">1</span> true) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 r) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>) 
                 (bool_to_bv <span class="mi">1</span> true) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà ((MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
   ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
         read s1 l
         ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
               {[(sub_with_inverted_borrow true
                    (spec.Reg s1 r) w2, 
                  spec.Flag s1 V)]})))
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg := spec.Reg s1;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="mi">0</span>
                        `max` 
                        <span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk103"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (bool_to_bv <span class="mi">1</span> true) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 r) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>) 
                  (bool_to_bv <span class="mi">1</span> true) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 r) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>) 
                 (bool_to_bv <span class="mi">1</span> true) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg := spec.Reg s1;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned <span class="nl">?Goal</span> <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; <span class="nl">?Goal1</span>
          | spec.Z =&gt; bv_eqb <span class="nl">?Goal</span> <span class="mi">0</span>
          | C =&gt; <span class="nl">?Goal0</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk104" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk104"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(sub_with_inverted_borrow true
                   (spec.Reg s1 r) w2, 
                 spec.Flag s1 V)]}))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk105"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
              {[(sub_with_inverted_borrow true
                   (spec.Reg s1 r) w2, 
                 spec.Flag s1 V)]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk106"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
        {[(sub_with_inverted_borrow true
             (spec.Reg s1 r) w2, 
           spec.Flag s1 V)]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk107"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà {[(sub_with_inverted_borrow true 
       (spec.Reg s1 r) w_in, 
     spec.Flag s1 V)]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk108">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (bool_to_bv <span class="mi">1</span> true) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 r) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>) 
                  (bool_to_bv <span class="mi">1</span> true) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 r) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>) 
                 (bool_to_bv <span class="mi">1</span> true) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg := spec.Reg s1;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span>
                bv_unsigned
                  (trunc <span class="mi">8</span>
                     (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bool_to_bv <span class="mi">1</span> true) +
                      (bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (spec.Reg s1 r) +
                       bv_zero_extend 
                        (<span class="mi">8</span> + <span class="mi">1</span>) 
                        (bv_not w_in))))
              <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; spec.Flag s1 V
          | spec.Z =&gt;
              bv_eqb
                (trunc <span class="mi">8</span>
                   (bv_zero_extend 
                      (<span class="mi">8</span> + <span class="mi">1</span>) 
                      (bool_to_bv <span class="mi">1</span> true) +
                    (bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>) 
                       (spec.Reg s1 r) +
                     bv_zero_extend 
                       (<span class="mi">8</span> + <span class="mi">1</span>) 
                       (bv_not w_in)))) <span class="mi">0</span>
          | C =&gt;
              bit (Z.of_N <span class="mi">8</span>)
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (bool_to_bv <span class="mi">1</span> true) +
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (spec.Reg s1 r) +
                  bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl));
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk109">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (bool_to_bv <span class="mi">1</span> true) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 r) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>) 
                  (bool_to_bv <span class="mi">1</span> true) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 r) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>) 
                 (bool_to_bv <span class="mi">1</span> true) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|} =
{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (trunc <span class="mi">8</span>
                 (bv_zero_extend 
                    (<span class="mi">8</span> + <span class="mi">1</span>) 
                    (bool_to_bv <span class="mi">1</span> true) +
                  (bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (spec.Reg s1 r) +
                   bv_zero_extend 
                     (<span class="mi">8</span> + <span class="mi">1</span>) 
                     (bv_not w_in))))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt;
          bv_eqb
            (trunc <span class="mi">8</span>
               (bv_zero_extend 
                  (<span class="mi">8</span> + <span class="mi">1</span>) 
                  (bool_to_bv <span class="mi">1</span> true) +
                (bv_zero_extend 
                   (<span class="mi">8</span> + <span class="mi">1</span>) 
                   (spec.Reg s1 r) +
                 bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
            <span class="mi">0</span>
      | C =&gt;
          <span class="kr">match</span>
            bv_unsigned
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>) 
                 (bool_to_bv <span class="mi">1</span> true) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
          <span class="kr">end</span>
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="mi">0</span>
               `max` <span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl));
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk10a"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span>
         bv_unsigned
           (trunc <span class="mi">8</span>
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>) 
                 (bool_to_bv <span class="mi">1</span> true) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | spec.Z =&gt;
       bv_eqb
         (trunc <span class="mi">8</span>
            (bv_zero_extend 
               (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> true) +
             (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
              bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
         <span class="mi">0</span>
   | C =&gt;
       <span class="kr">match</span>
         bv_unsigned
           (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> true) +
            (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
             bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
       <span class="kr">end</span>
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span>
         bv_unsigned
           (trunc <span class="mi">8</span>
              (bv_zero_extend 
                 (<span class="mi">8</span> + <span class="mi">1</span>) 
                 (bool_to_bv <span class="mi">1</span> true) +
               (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
                bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt;
       bv_eqb
         (trunc <span class="mi">8</span>
            (bv_zero_extend 
               (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> true) +
             (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
              bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in))))
         <span class="mi">0</span>
   | C =&gt;
       <span class="kr">match</span>
         bv_unsigned
           (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bool_to_bv <span class="mi">1</span> true) +
            (bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (spec.Reg s1 r) +
             bv_zero_extend (<span class="mi">8</span> + <span class="mi">1</span>) (bv_not w_in)))
       <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">8</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">8</span>)
       <span class="kr">end</span>
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk10b"><span class="kn">Lemma</span> <span class="nf">run_Shift</span> (<span class="nv">right</span> <span class="nv">roll</span> : bool) <span class="nv">s1</span> <span class="nv">s2</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.shift_instr_mode s1 s2
        (<span class="kr">if</span> <span class="nb">right</span>
        <span class="kr">then</span> (<span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec)
        <span class="kr">else</span> (<span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec))
    mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr
        (Typical mode&#39; ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll) true)
        s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí shift_instr_mode s1 s2
    (<span class="kr">if</span> <span class="nb">right</span>
     <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
     <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec) mode
    len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical mode&#39;
             ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll)
             true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk10c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí shift_instr_mode s1 s2
    (<span class="kr">if</span> <span class="nb">right</span>
     <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
     <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec) mode
    len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2
      ‚àà run_instr
          (Typical mode&#39;
             ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll)
             true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk10d"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shift_instr_mode s1 s2
  (<span class="kr">if</span> <span class="nb">right</span>
   <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
   <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec) mode
  (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2
  ‚àà run_instr
      (Typical mode&#39;
         ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll)
         true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk10e"><span class="nb">rewrite</span> /shift_instr_mode.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> : bv <span class="mi">8</span>) 
   (<span class="nv">cout</span> : bool) (<span class="nv">w_out</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß (<span class="kr">if</span> <span class="nb">right</span>
        <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
        <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec) w_in
         (Flag s1 C) w_out cout
       ‚àß PC s2 =
         PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
         ‚àß Reg s2 = Reg s1
           ‚àß Flag s2 =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt; bit <span class="mi">7</span> w_out
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; cout
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>)
             ‚àß RAM s2 = write addr w_out (RAM s1))
‚Üí s2
  ‚àà run_instr
      (Typical mode&#39;
         ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll)
         true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk10f"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w_in</span> : bv <span class="mi">8</span>) 
   (<span class="nv">cout</span> : bool) (<span class="nv">w_out</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w_in
     ‚àß (<span class="kr">if</span> <span class="nb">right</span>
        <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
        <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec) w_in
         (spec.Flag s1 C) w_out cout
       ‚àß PC =
         spec.PC s1
         `+Z` Z.of_nat
                (S
                   (<span class="kr">match</span>
                      mode&#39; <span class="kr">as</span> m
                      <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                    <span class="kr">with</span>
                    | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                    | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                       <span class="mi">2</span>%nat
                    | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                       <span class="mi">1</span>%nat
                    | XInd =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                    | IndY =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                    | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                    <span class="kr">end</span> eq_refl))
         ‚àß Reg = spec.Reg s1
           ‚àß Flag =
             (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                       negb
                       (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
                | C =&gt; cout
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>)
             ‚àß RAM = write addr w_out (spec.RAM s1))
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                run_operation
                  ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                     roll) s1 w
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[
                      {|
                       Reg :=
                       <span class="kr">if</span>
                       <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                       <span class="kr">with</span>
                       | Binop Cmp _ | Binop Bit _ =&gt;
                       false
                       | _ =&gt; true
                       <span class="kr">end</span>
                       <span class="kr">then</span>
                       <span class="kr">match</span> l <span class="kr">with</span>
                       | RegLoc r =&gt;
                       <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                       <span class="kr">if</span> reg_eqb r r&#39;
                       <span class="kr">then</span> w0
                       <span class="kr">else</span> spec.Reg s1 r&#39;
                       | MemLoc _ =&gt; spec.Reg s1
                       <span class="kr">end</span>
                       <span class="kr">else</span> spec.Reg s1;
                       Flag :=
                       <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                       <span class="kr">match</span> f <span class="kr">with</span>
                       | spec.N =&gt;
                       <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                       | <span class="mi">0</span>%Z =&gt; false
                       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                       | Z.neg a =&gt;
                       negb
                       (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                       <span class="kr">end</span>
                       | V =&gt; v
                       | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                       | C =&gt; c
                       | _ =&gt; spec.Flag s1 f
                       <span class="kr">end</span>;
                       PC :=
                       spec.PC s1
                       `+Z` 
                       Z.of_nat
                       (S
                       (<span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                       <span class="kr">with</span>
                       | Imm =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                       | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                       | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                       | XInd =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                       | IndY =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                       | Rel =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                       <span class="kr">end</span> eq_refl
                       `max` 
                       <span class="kr">match</span> (... ... ...) roll <span class="kr">with</span>
                       | Binop _ m&#39; =&gt; mode_len m&#39;
                       | _ =&gt; <span class="mi">0</span>
                       <span class="kr">end</span>));
                       RAM :=
                       <span class="kr">match</span> l <span class="kr">with</span>
                       | RegLoc _ =&gt; spec.RAM s1
                       | MemLoc a =&gt;
                       write a w0 (spec.RAM s1)
                       <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk110"><span class="nb">move</span>=&gt;
        [addr&#39; [w_in [c_out [w_out [/mode_spec m [fetch_w_in [is_shift
            [-&gt; [-&gt; [-&gt; -&gt;]]]]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; w_out (spec.RAM s1)
|}
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              run_operation
                ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                   roll) s1 w
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                       Reg :=
                       <span class="kr">if</span>
                       <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                       <span class="kr">with</span>
                       | Binop Cmp _ | Binop Bit _ =&gt;
                       false
                       | _ =&gt; true
                       <span class="kr">end</span>
                       <span class="kr">then</span>
                       <span class="kr">match</span> l <span class="kr">with</span>
                       | RegLoc r =&gt;
                       <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                       <span class="kr">if</span> reg_eqb r r&#39;
                       <span class="kr">then</span> w0
                       <span class="kr">else</span> spec.Reg s1 r&#39;
                       | MemLoc _ =&gt; spec.Reg s1
                       <span class="kr">end</span>
                       <span class="kr">else</span> spec.Reg s1;
                       Flag :=
                       <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                       <span class="kr">match</span> f <span class="kr">with</span>
                       | spec.N =&gt;
                       <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                       | <span class="mi">0</span>%Z =&gt; false
                       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                       | Z.neg a =&gt;
                       negb
                       (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                       <span class="kr">end</span>
                       | V =&gt; v
                       | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                       | C =&gt; c
                       | _ =&gt; spec.Flag s1 f
                       <span class="kr">end</span>;
                       PC :=
                       spec.PC s1
                       `+Z` 
                       Z.of_nat
                       (S
                       (<span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                       <span class="kr">with</span>
                       | Imm =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                       | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                       <span class="mi">2</span>%nat
                       | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                       <span class="mi">1</span>%nat
                       | XInd =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                       | IndY =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                       | Rel =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                       <span class="kr">end</span> eq_refl
                       `max` 
                       <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                       <span class="kr">with</span>
                       | Binop _ m&#39; =&gt; mode_len m&#39;
                       | _ =&gt; <span class="mi">0</span>
                       <span class="kr">end</span>));
                       RAM :=
                       <span class="kr">match</span> l <span class="kr">with</span>
                       | RegLoc _ =&gt; spec.RAM s1
                       | MemLoc a =&gt;
                       write a w0 (spec.RAM s1)
                       <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk111"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; w_out (spec.RAM s1)
|}
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        run_operation
          ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll) s1
          w
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">if</span>
                     <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                     <span class="kr">with</span>
                     | Binop Cmp _ | Binop Bit _ =&gt;
                       false
                     | _ =&gt; true
                     <span class="kr">end</span>
                    <span class="kr">then</span>
                     <span class="kr">match</span> MemLoc addr&#39; <span class="kr">with</span>
                     | RegLoc r =&gt;
                       <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                       <span class="kr">if</span> reg_eqb r r&#39;
                       <span class="kr">then</span> w0
                       <span class="kr">else</span> spec.Reg s1 r&#39;
                     | MemLoc _ =&gt; spec.Reg s1
                     <span class="kr">end</span>
                    <span class="kr">else</span> spec.Reg s1;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                       <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                       | <span class="mi">0</span>%Z =&gt; false
                       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                       | Z.neg a =&gt;
                       negb
                       (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                       <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                       (<span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                       <span class="kr">with</span>
                       | Imm =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                       | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                       <span class="mi">2</span>%nat
                       | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                       <span class="mi">1</span>%nat
                       | XInd =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                       | IndY =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                       | Rel =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                       <span class="kr">end</span> eq_refl
                       `max` 
                       <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                       <span class="kr">with</span>
                       | Binop _ m&#39; =&gt; mode_len m&#39;
                       | _ =&gt; <span class="mi">0</span>
                       <span class="kr">end</span>));
                  RAM :=
                    <span class="kr">match</span> MemLoc addr&#39; <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                       write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk112"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w_in.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; w_out (spec.RAM s1)
|}
‚àà run_operation
    ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll) s1 w_in
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">if</span>
               <span class="kr">match</span>
                 (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                   roll
               <span class="kr">with</span>
               | Binop Cmp _ | Binop Bit _ =&gt; false
               | _ =&gt; true
               <span class="kr">end</span>
              <span class="kr">then</span> spec.Reg s1
              <span class="kr">else</span> spec.Reg s1;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                       negb
                       (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                       (<span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                       <span class="kr">with</span>
                       | Imm =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                       | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                       <span class="mi">2</span>%nat
                       | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                       <span class="mi">1</span>%nat
                       | XInd =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                       | IndY =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                       | Rel =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                       <span class="kr">end</span> eq_refl
                       `max` 
                       <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                       <span class="kr">with</span>
                       | Binop _ m&#39; =&gt; mode_len m&#39;
                       | _ =&gt; <span class="mi">0</span>
                       <span class="kr">end</span>));
            RAM := write addr&#39; w (spec.RAM s1)
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk113"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; w_out (spec.RAM s1)
|}
‚àà {[{|
      Reg :=
        <span class="kr">if</span>
         <span class="kr">match</span>
           (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll
         <span class="kr">with</span>
         | Binop Cmp _ | Binop Bit _ =&gt; false
         | _ =&gt; true
         <span class="kr">end</span>
        <span class="kr">then</span> spec.Reg s1
        <span class="kr">else</span> spec.Reg s1;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned <span class="nl">?Goal</span> <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; <span class="nl">?Goal1</span>
          | spec.Z =&gt; bv_eqb <span class="nl">?Goal</span> <span class="mi">0</span>
          | C =&gt; <span class="nl">?Goal0</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                       <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                       <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl
                   `max` 
                   <span class="kr">match</span>
                     (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                       roll
                   <span class="kr">with</span>
                   | Binop _ m&#39; =&gt; mode_len m&#39;
                   | _ =&gt; <span class="mi">0</span>
                   <span class="kr">end</span>));
      RAM := write addr&#39; <span class="nl">?Goal</span> (spec.RAM s1)
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk114" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk114"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà run_operation
    ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll) s1 w_in</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk115"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà run_operation
    ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll) s1 w_in</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk116"><span class="nb">rewrite</span> /run_operation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà <span class="kr">match</span> (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll <span class="kr">with</span>
  | Binop op m =&gt;
      mode_loc s1 m
      ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
            read s1 l
            ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>, run_binop op s1 w_in w2))
  | Inc =&gt;
      {[(w_in `+Z` <span class="mi">1</span>, spec.Flag s1 C, spec.Flag s1 V)]}
  | Dec =&gt;
      {[(w_in `-Z` <span class="mi">1</span>, spec.Flag s1 C, spec.Flag s1 V)]}
  | ShiftL roll =&gt;
      {[ out | spec.bv_concat <span class="mi">9</span> out.<span class="mi">1</span>
                 (bool_to_bv <span class="mi">1</span> out.<span class="mi">2</span>) =
               spec.bv_concat <span class="mi">9</span>
                 (bool_to_bv <span class="mi">1</span>
                    (<span class="kr">if</span> roll
                     <span class="kr">then</span> spec.Flag s1 C
                     <span class="kr">else</span> false)) w_in ]}
      ‚â´= (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, spec.Flag s1 V)]})
  | ShiftR roll =&gt;
      {[ out | spec.bv_concat <span class="mi">9</span> 
                 (bool_to_bv <span class="mi">1</span> out.<span class="mi">2</span>) out.<span class="mi">1</span> =
               spec.bv_concat <span class="mi">9</span> w_in
                 (bool_to_bv <span class="mi">1</span>
                    (<span class="kr">if</span> roll
                     <span class="kr">then</span> spec.Flag s1 C
                     <span class="kr">else</span> false)) ]}
      ‚â´= (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, spec.Flag s1 V)]})
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: is_shift; <span class="nb">case</span>: <span class="nb">right</span>; <span class="nb">case</span>: roll; <span class="nb">move</span>=&gt; is_shift;
            (<span class="nb">eexists</span>; <span class="nb">split</span>; [<span class="bp">reflexivity</span> | <span class="bp">exact</span> is_shift]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk117">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; w_out (spec.RAM s1)
|}
‚àà {[{|
      Reg :=
        <span class="kr">if</span>
         <span class="kr">match</span>
           (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll
         <span class="kr">with</span>
         | Binop Cmp _ | Binop Bit _ =&gt; false
         | _ =&gt; true
         <span class="kr">end</span>
        <span class="kr">then</span> spec.Reg s1
        <span class="kr">else</span> spec.Reg s1;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; spec.Flag s1 V
          | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
          | C =&gt; c_out
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="kr">match</span>
                     mode&#39; <span class="kr">as</span> m
                     <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                   <span class="kr">with</span>
                   | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                   | Abs wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                       <span class="mi">2</span>%nat
                   | Zpg wildcard&#39; =&gt;
                       <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                       <span class="mi">1</span>%nat
                   | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                   | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                   | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                   <span class="kr">end</span> eq_refl
                   `max` 
                   <span class="kr">match</span>
                     (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                       roll
                   <span class="kr">with</span>
                   | Binop _ m&#39; =&gt; mode_len m&#39;
                   | _ =&gt; <span class="mi">0</span>
                   <span class="kr">end</span>));
      RAM := write addr&#39; w_out (spec.RAM s1)
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk118">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; w_out (spec.RAM s1)
|} =
{|
  Reg :=
    <span class="kr">if</span>
     <span class="kr">match</span>
       (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll
     <span class="kr">with</span>
     | Binop Cmp _ | Binop Bit _ =&gt; false
     | _ =&gt; true
     <span class="kr">end</span>
    <span class="kr">then</span> spec.Reg s1
    <span class="kr">else</span> spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
      | C =&gt; c_out
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl
               `max` <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                     <span class="kr">with</span>
                     | Binop _ m&#39; =&gt; mode_len m&#39;
                     | _ =&gt; <span class="mi">0</span>
                     <span class="kr">end</span>));
  RAM := write addr&#39; w_out (spec.RAM s1)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk119"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.Reg s1 =
(<span class="kr">if</span>
  <span class="kr">match</span> (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll <span class="kr">with</span>
  | Binop Cmp _ | Binop Bit _ =&gt; false
  | _ =&gt; true
  <span class="kr">end</span>
 <span class="kr">then</span> spec.Reg s1
 <span class="kr">else</span> spec.Reg s1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk11a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk11a"><hr></label><div class="goal-conclusion">(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
   | C =&gt; c_out
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
   | C =&gt; c_out
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk11b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk11b"><hr></label><div class="goal-conclusion">spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl)) =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl
           `max` <span class="kr">match</span>
                   (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                     roll
                 <span class="kr">with</span>
                 | Binop _ m&#39; =&gt; mode_len m&#39;
                 | _ =&gt; <span class="mi">0</span>
                 <span class="kr">end</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk11c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.Reg s1 =
(<span class="kr">if</span>
  <span class="kr">match</span> (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll <span class="kr">with</span>
  | Binop Cmp _ | Binop Bit _ =&gt; false
  | _ =&gt; true
  <span class="kr">end</span>
 <span class="kr">then</span> spec.Reg s1
 <span class="kr">else</span> spec.Reg s1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">rewrite</span> Tauto.if_same.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk11d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
   | C =&gt; c_out
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned w_out <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb w_out <span class="mi">0</span>
   | C =&gt; c_out
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk11e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w_in</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>c_out</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w_out</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w_in</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w_in</span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  w_in (spec.Flag s1 C) w_out c_out</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl)) =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl
           `max` <span class="kr">match</span>
                   (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                     roll
                 <span class="kr">with</span>
                 | Binop _ m&#39; =&gt; mode_len m&#39;
                 | _ =&gt; <span class="mi">0</span>
                 <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span> mode&#39;; <span class="nb">case</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk11f"><span class="kn">Lemma</span> <span class="nf">run_Shift_A</span> (<span class="nv">right</span> <span class="nv">roll</span> : bool) <span class="nv">s1</span> <span class="nv">s2</span> :
    spec.shift_instr_A s1 s2
        (<span class="kr">if</span> <span class="nb">right</span>
        <span class="kr">then</span> (<span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec)
        <span class="kr">else</span> (<span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)) -&gt;
    s2 ‚àà run_instr
        (Typical RegA ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll) true)
        s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shift_instr_A s1 s2
  (<span class="kr">if</span> <span class="nb">right</span>
   <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
   <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
‚Üí s2
  ‚àà run_instr
      (Typical RegA
         ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll)
         true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk120"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">shift_instr_A s1 s2
  (<span class="kr">if</span> <span class="nb">right</span>
   <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
   <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
‚Üí s2
  ‚àà run_instr
      (Typical RegA
         ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll)
         true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk121"><span class="nb">rewrite</span> /shift_instr_A.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">cout</span> : bool) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   (<span class="kr">if</span> <span class="nb">right</span>
    <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
    <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
     (Reg s1 A) (Flag s1 C) w cout
   ‚àß PC s2 = PC s1 `+Z` <span class="mi">1</span>
     ‚àß Reg s2 = setReg s1 A w
       ‚àß Flag s2 =
         (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt; bit <span class="mi">7</span> w
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; cout
            | _ =&gt; Flag s1 f
            <span class="kr">end</span>) ‚àß RAM s2 = RAM s1)
‚Üí s2
  ‚àà run_instr
      (Typical RegA
         ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll)
         true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk122"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">cout</span> : bool) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   (<span class="kr">if</span> <span class="nb">right</span>
    <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
    <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
     (spec.Reg s1 A) (spec.Flag s1 C) w cout
   ‚àß PC = spec.PC s1 `+Z` <span class="mi">1</span>
     ‚àß Reg = setReg s1 A w
       ‚àß Flag =
         (<span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; cout
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>) ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc A]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                run_operation
                  ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                     roll) s1 w
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[
                      {|
                       Reg :=
                       <span class="kr">if</span>
                       <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                       <span class="kr">with</span>
                       | Binop Cmp _ | Binop Bit _ =&gt;
                       false
                       | _ =&gt; true
                       <span class="kr">end</span>
                       <span class="kr">then</span>
                       <span class="kr">match</span> l <span class="kr">with</span>
                       | RegLoc r =&gt;
                       <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                       <span class="kr">if</span> reg_eqb r r&#39;
                       <span class="kr">then</span> w0
                       <span class="kr">else</span> spec.Reg s1 r&#39;
                       | MemLoc _ =&gt; spec.Reg s1
                       <span class="kr">end</span>
                       <span class="kr">else</span> spec.Reg s1;
                       Flag :=
                       <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                       <span class="kr">match</span> f <span class="kr">with</span>
                       | spec.N =&gt;
                       <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                       | <span class="mi">0</span>%Z =&gt; false
                       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                       | Z.neg a =&gt;
                       negb
                       (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                       <span class="kr">end</span>
                       | V =&gt; v
                       | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                       | C =&gt; c
                       | _ =&gt; spec.Flag s1 f
                       <span class="kr">end</span>;
                       PC :=
                       spec.PC s1
                       `+Z` 
                       Z.of_nat
                       (S
                       (<span class="mi">0</span>
                       `max` 
                       <span class="kr">match</span> (... ... ...) roll <span class="kr">with</span>
                       | Binop _ m&#39; =&gt; mode_len m&#39;
                       | _ =&gt; <span class="mi">0</span>
                       <span class="kr">end</span>));
                       RAM :=
                       <span class="kr">match</span> l <span class="kr">with</span>
                       | RegLoc _ =&gt; spec.RAM s1
                       | MemLoc a =&gt;
                       write a w0 (spec.RAM s1)
                       <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk123"><span class="nb">move</span>=&gt; [addr&#39; [w [is_shift [-&gt; [-&gt; [-&gt; -&gt;]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
      | C =&gt; addr&#39;
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà {[RegLoc A]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              run_operation
                ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                   roll) s1 w
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                       Reg :=
                       <span class="kr">if</span>
                       <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                       <span class="kr">with</span>
                       | Binop Cmp _ | Binop Bit _ =&gt;
                       false
                       | _ =&gt; true
                       <span class="kr">end</span>
                       <span class="kr">then</span>
                       <span class="kr">match</span> l <span class="kr">with</span>
                       | RegLoc r =&gt;
                       <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                       <span class="kr">if</span> reg_eqb r r&#39;
                       <span class="kr">then</span> w0
                       <span class="kr">else</span> spec.Reg s1 r&#39;
                       | MemLoc _ =&gt; spec.Reg s1
                       <span class="kr">end</span>
                       <span class="kr">else</span> spec.Reg s1;
                       Flag :=
                       <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                       <span class="kr">match</span> f <span class="kr">with</span>
                       | spec.N =&gt;
                       <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                       | <span class="mi">0</span>%Z =&gt; false
                       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                       | Z.neg a =&gt;
                       negb
                       (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                       <span class="kr">end</span>
                       | V =&gt; v
                       | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                       | C =&gt; c
                       | _ =&gt; spec.Flag s1 f
                       <span class="kr">end</span>;
                       PC :=
                       spec.PC s1
                       `+Z` 
                       Z.of_nat
                       (S
                       (<span class="mi">0</span>
                       `max` 
                       <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                       <span class="kr">with</span>
                       | Binop _ m&#39; =&gt; mode_len m&#39;
                       | _ =&gt; <span class="mi">0</span>
                       <span class="kr">end</span>));
                       RAM :=
                       <span class="kr">match</span> l <span class="kr">with</span>
                       | RegLoc _ =&gt; spec.RAM s1
                       | MemLoc a =&gt;
                       write a w0 (spec.RAM s1)
                       <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk124"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
      | C =&gt; addr&#39;
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc A)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        run_operation
          ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll) s1
          w
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">if</span>
                     <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                     <span class="kr">with</span>
                     | Binop Cmp _ | Binop Bit _ =&gt;
                       false
                     | _ =&gt; true
                     <span class="kr">end</span>
                    <span class="kr">then</span>
                     <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                     | RegLoc r =&gt;
                       <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                       <span class="kr">if</span> reg_eqb r r&#39;
                       <span class="kr">then</span> w0
                       <span class="kr">else</span> spec.Reg s1 r&#39;
                     | MemLoc _ =&gt; spec.Reg s1
                     <span class="kr">end</span>
                    <span class="kr">else</span> spec.Reg s1;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                       <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                       | <span class="mi">0</span>%Z =&gt; false
                       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                       | Z.neg a =&gt;
                       negb
                       (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                       <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                       (<span class="mi">0</span>
                       `max` 
                       <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                       <span class="kr">with</span>
                       | Binop _ m&#39; =&gt; mode_len m&#39;
                       | _ =&gt; <span class="mi">0</span>
                       <span class="kr">end</span>));
                  RAM :=
                    <span class="kr">match</span> RegLoc A <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                       write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk125"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
      | C =&gt; addr&#39;
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà run_operation
    ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll) s1
    (spec.Reg s1 A)
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">if</span>
               <span class="kr">match</span>
                 (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                   roll
               <span class="kr">with</span>
               | Binop Cmp _ | Binop Bit _ =&gt; false
               | _ =&gt; true
               <span class="kr">end</span>
              <span class="kr">then</span>
               <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                 <span class="kr">if</span> reg_eqb A r&#39;
                 <span class="kr">then</span> w
                 <span class="kr">else</span> spec.Reg s1 r&#39;
              <span class="kr">else</span> spec.Reg s1;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                       negb
                       (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                       (<span class="mi">0</span>
                       `max` 
                       <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                       <span class="kr">with</span>
                       | Binop _ m&#39; =&gt; mode_len m&#39;
                       | _ =&gt; <span class="mi">0</span>
                       <span class="kr">end</span>));
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk126"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
      | C =&gt; addr&#39;
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">if</span>
         <span class="kr">match</span>
           (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll
         <span class="kr">with</span>
         | Binop Cmp _ | Binop Bit _ =&gt; false
         | _ =&gt; true
         <span class="kr">end</span>
        <span class="kr">then</span>
         <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
           <span class="kr">if</span> reg_eqb A r&#39;
           <span class="kr">then</span> <span class="nl">?Goal</span>
           <span class="kr">else</span> spec.Reg s1 r&#39;
        <span class="kr">else</span> spec.Reg s1;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned <span class="nl">?Goal</span> <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; <span class="nl">?Goal1</span>
          | spec.Z =&gt; bv_eqb <span class="nl">?Goal</span> <span class="mi">0</span>
          | C =&gt; <span class="nl">?Goal0</span>
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                       roll
                   <span class="kr">with</span>
                   | Binop _ m&#39; =&gt; mode_len m&#39;
                   | _ =&gt; <span class="mi">0</span>
                   <span class="kr">end</span>));
      RAM := spec.RAM s1
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk127" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk127"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà run_operation
    ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll) s1
    (spec.Reg s1 A)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk128"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà run_operation
    ((<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll) s1
    (spec.Reg s1 A)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk129"><span class="nb">rewrite</span> /run_operation.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal</span>, <span class="nl">?Goal0</span>, <span class="nl">?Goal1</span>)
‚àà <span class="kr">match</span> (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll <span class="kr">with</span>
  | Binop op m =&gt;
      mode_loc s1 m
      ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
            read s1 l
            ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
                  run_binop op s1 (spec.Reg s1 A) w2))
  | Inc =&gt;
      {[(spec.Reg s1 A `+Z` <span class="mi">1</span>, 
         spec.Flag s1 C, 
         spec.Flag s1 V)]}
  | Dec =&gt;
      {[(spec.Reg s1 A `-Z` <span class="mi">1</span>, 
         spec.Flag s1 C, 
         spec.Flag s1 V)]}
  | ShiftL roll =&gt;
      {[ out | spec.bv_concat <span class="mi">9</span> out.<span class="mi">1</span>
                 (bool_to_bv <span class="mi">1</span> out.<span class="mi">2</span>) =
               spec.bv_concat <span class="mi">9</span>
                 (bool_to_bv <span class="mi">1</span>
                    (<span class="kr">if</span> roll
                     <span class="kr">then</span> spec.Flag s1 C
                     <span class="kr">else</span> false)) 
                 (spec.Reg s1 A) ]}
      ‚â´= (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, spec.Flag s1 V)]})
  | ShiftR roll =&gt;
      {[ out | spec.bv_concat <span class="mi">9</span> 
                 (bool_to_bv <span class="mi">1</span> out.<span class="mi">2</span>) out.<span class="mi">1</span> =
               spec.bv_concat <span class="mi">9</span> 
                 (spec.Reg s1 A)
                 (bool_to_bv <span class="mi">1</span>
                    (<span class="kr">if</span> roll
                     <span class="kr">then</span> spec.Flag s1 C
                     <span class="kr">else</span> false)) ]}
      ‚â´= (<span class="kr">Œª</span> <span class="nv">wc</span> : bv <span class="mi">8</span> * bool, {[(wc, spec.Flag s1 V)]})
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: is_shift; <span class="nb">case</span>: <span class="nb">right</span>; <span class="nb">case</span>: roll; <span class="nb">move</span>=&gt; is_shift;
            (<span class="nb">eexists</span>; <span class="nb">split</span>; [<span class="bp">reflexivity</span> | <span class="bp">exact</span> is_shift]).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk12a">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
      | C =&gt; addr&#39;
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">if</span>
         <span class="kr">match</span>
           (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll
         <span class="kr">with</span>
         | Binop Cmp _ | Binop Bit _ =&gt; false
         | _ =&gt; true
         <span class="kr">end</span>
        <span class="kr">then</span>
         <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
           <span class="kr">if</span> reg_eqb A r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;
        <span class="kr">else</span> spec.Reg s1;
      Flag :=
        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
          <span class="kr">match</span> f <span class="kr">with</span>
          | spec.N =&gt;
              <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
              | <span class="mi">0</span>%Z =&gt; false
              | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
              | Z.neg a =&gt;
                  negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
              <span class="kr">end</span>
          | V =&gt; spec.Flag s1 V
          | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
          | C =&gt; addr&#39;
          | _ =&gt; spec.Flag s1 f
          <span class="kr">end</span>;
      PC :=
        spec.PC s1
        `+Z` Z.of_nat
               (S
                  (<span class="mi">0</span>
                   `max` 
                   <span class="kr">match</span>
                     (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                       roll
                   <span class="kr">with</span>
                   | Binop _ m&#39; =&gt; mode_len m&#39;
                   | _ =&gt; <span class="mi">0</span>
                   <span class="kr">end</span>));
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk12b">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 A w;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
      | C =&gt; addr&#39;
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|} =
{|
  Reg :=
    <span class="kr">if</span>
     <span class="kr">match</span>
       (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll
     <span class="kr">with</span>
     | Binop Cmp _ | Binop Bit _ =&gt; false
     | _ =&gt; true
     <span class="kr">end</span>
    <span class="kr">then</span>
     <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
       <span class="kr">if</span> reg_eqb A r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;
    <span class="kr">else</span> spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
      | C =&gt; addr&#39;
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="mi">0</span>
               `max` <span class="kr">match</span>
                       (<span class="kr">if</span> <span class="nb">right</span>
                       <span class="kr">then</span> ShiftR
                       <span class="kr">else</span> ShiftL) roll
                     <span class="kr">with</span>
                     | Binop _ m&#39; =&gt; mode_len m&#39;
                     | _ =&gt; <span class="mi">0</span>
                     <span class="kr">end</span>));
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk12c"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setReg s1 A w =
(<span class="kr">if</span>
  <span class="kr">match</span> (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll <span class="kr">with</span>
  | Binop Cmp _ | Binop Bit _ =&gt; false
  | _ =&gt; true
  <span class="kr">end</span>
 <span class="kr">then</span>
  <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
    <span class="kr">if</span> reg_eqb A r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;
 <span class="kr">else</span> spec.Reg s1)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk12d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk12d"><hr></label><div class="goal-conclusion">(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
   | C =&gt; addr&#39;
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
   | C =&gt; addr&#39;
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk12e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk12e"><hr></label><div class="goal-conclusion">spec.PC s1 `+Z` <span class="mi">1</span> =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="mi">0</span>
           `max` <span class="kr">match</span>
                   (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                     roll
                 <span class="kr">with</span>
                 | Binop _ m&#39; =&gt; mode_len m&#39;
                 | _ =&gt; <span class="mi">0</span>
                 <span class="kr">end</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk12f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setReg s1 A w =
(<span class="kr">if</span>
  <span class="kr">match</span> (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL) roll <span class="kr">with</span>
  | Binop Cmp _ | Binop Bit _ =&gt; false
  | _ =&gt; true
  <span class="kr">end</span>
 <span class="kr">then</span>
  <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
    <span class="kr">if</span> reg_eqb A r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;
 <span class="kr">else</span> spec.Reg s1)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: is_shift; <span class="bp">by</span> <span class="nb">case</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk130">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
   | C =&gt; addr&#39;
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
   | C =&gt; addr&#39;
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk131">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>right, roll</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>is_shift</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> <span class="nb">right</span>
 <span class="kr">then</span> <span class="kr">if</span> roll <span class="kr">then</span> ROR_spec <span class="kr">else</span> LSR_spec
 <span class="kr">else</span> <span class="kr">if</span> roll <span class="kr">then</span> ROL_spec <span class="kr">else</span> ASL_spec)
  (spec.Reg s1 A) (spec.Flag s1 C) w addr&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.PC s1 `+Z` <span class="mi">1</span> =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="mi">0</span>
           `max` <span class="kr">match</span>
                   (<span class="kr">if</span> <span class="nb">right</span> <span class="kr">then</span> ShiftR <span class="kr">else</span> ShiftL)
                     roll
                 <span class="kr">with</span>
                 | Binop _ m&#39; =&gt; mode_len m&#39;
                 | _ =&gt; <span class="mi">0</span>
                 <span class="kr">end</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span> <span class="nb">right</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk132"><span class="kn">Lemma</span> <span class="nf">run_Inc_mode</span> <span class="nv">s1</span> <span class="nv">s2</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.INC_mode s1 s2 mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical mode&#39; Inc true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí INC_mode s1 s2 mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2 ‚àà run_instr (Typical mode&#39; Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk133"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí INC_mode s1 s2 mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2 ‚àà run_instr (Typical mode&#39; Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk134"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">INC_mode s1 s2 mode (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2 ‚àà run_instr (Typical mode&#39; Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk135"><span class="nb">rewrite</span> /INC_mode.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC s2 =
       PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
       ‚àß Reg s2 = Reg s1
         ‚àß Flag s2 = setNZ s1 (w `+Z` <span class="mi">1</span>)
           ‚àß RAM s2 = write addr (w `+Z` <span class="mi">1</span>) (RAM s1))
‚Üí s2 ‚àà run_instr (Typical mode&#39; Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk136"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC =
       spec.PC s1
       `+Z` Z.of_nat
              (S
                 (<span class="kr">match</span>
                    mode&#39; <span class="kr">as</span> m
                    <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                  <span class="kr">with</span>
                  | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                  | Abs wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                  | Zpg wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                  | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                  | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                  | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                  <span class="kr">end</span> eq_refl))
       ‚àß Reg = spec.Reg s1
         ‚àß Flag = setNZ s1 (w `+Z` <span class="mi">1</span>)
           ‚àß RAM = write addr (w `+Z` <span class="mi">1</span>) (spec.RAM s1))
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                {[(w `+Z` <span class="mi">1</span>, 
                   spec.Flag s1 C, 
                   spec.Flag s1 V)]}
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk137"><span class="nb">move</span>=&gt; [addr&#39; [w [/mode_spec m [fetch_w [-&gt; [-&gt; [-&gt; -&gt;]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := setNZ s1 (w `+Z` <span class="mi">1</span>);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; (w `+Z` <span class="mi">1</span>) (spec.RAM s1)
|}
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              {[(w `+Z` <span class="mi">1</span>, 
                 spec.Flag s1 C, 
                 spec.Flag s1 V)]}
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk138"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := setNZ s1 (w `+Z` <span class="mi">1</span>);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; (w `+Z` <span class="mi">1</span>) (spec.RAM s1)
|}
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        {[(w `+Z` <span class="mi">1</span>, spec.Flag s1 C, spec.Flag s1 V)]}
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> MemLoc addr&#39; <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
                  RAM :=
                    <span class="kr">match</span> MemLoc addr&#39; <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk139"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := setNZ s1 (w `+Z` <span class="mi">1</span>);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; (w `+Z` <span class="mi">1</span>) (spec.RAM s1)
|}
‚àà {[(w `+Z` <span class="mi">1</span>, spec.Flag s1 C, spec.Flag s1 V)]}
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg := spec.Reg s1;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
            RAM := write addr&#39; w (spec.RAM s1)
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk13a"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := setNZ s1 (w `+Z` <span class="mi">1</span>);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; (w `+Z` <span class="mi">1</span>) (spec.RAM s1)
|}
‚àà (<span class="kr">let</span>
   &#39;(w, c, v) :=
    (w `+Z` <span class="mi">1</span>, spec.Flag s1 C, spec.Flag s1 V) <span class="kr">in</span>
    {[{|
        Reg := spec.Reg s1;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | V =&gt; v
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; c
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>;
        PC :=
          spec.PC s1
          `+Z` Z.of_nat
                 (S
                    (<span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
        RAM := write addr&#39; w (spec.RAM s1)
      |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk13b">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := setNZ s1 (w `+Z` <span class="mi">1</span>);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; (w `+Z` <span class="mi">1</span>) (spec.RAM s1)
|} =
{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned (w `+Z` <span class="mi">1</span>) <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb (w `+Z` <span class="mi">1</span>) <span class="mi">0</span>
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
  RAM := write addr&#39; (w `+Z` <span class="mi">1</span>) (spec.RAM s1)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk13c"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 (w `+Z` <span class="mi">1</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned (w `+Z` <span class="mi">1</span>) <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb (w `+Z` <span class="mi">1</span>) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk13d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk13d"><hr></label><div class="goal-conclusion">spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl)) =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk13e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 (w `+Z` <span class="mi">1</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned (w `+Z` <span class="mi">1</span>) <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb (w `+Z` <span class="mi">1</span>) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk13f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl)) =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span> mode&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk140"><span class="kn">Lemma</span> <span class="nf">run_Inc_reg</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">r</span> :
    spec.INC_reg s1 s2 r -&gt;
    s2 ‚àà run_instr (Typical (RegMode r) Inc true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">INC_reg s1 s2 r
‚Üí s2 ‚àà run_instr (Typical (RegMode r) Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk141"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">INC_reg s1 s2 r
‚Üí s2 ‚àà run_instr (Typical (RegMode r) Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk142"><span class="nb">rewrite</span> /INC_reg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC s2 = PC s1 `+Z` <span class="mi">1</span>
‚àß Reg s2 = setReg s1 r (Reg s1 r `+Z` <span class="mi">1</span>)
  ‚àß Flag s2 = setNZ s1 (Reg s1 r `+Z` <span class="mi">1</span>)
    ‚àß RAM s2 = RAM s1
‚Üí s2 ‚àà run_instr (Typical (RegMode r) Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk143"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC = spec.PC s1 `+Z` <span class="mi">1</span>
‚àß Reg = setReg s1 r (spec.Reg s1 r `+Z` <span class="mi">1</span>)
  ‚àß Flag = setNZ s1 (spec.Reg s1 r `+Z` <span class="mi">1</span>)
    ‚àß RAM = spec.RAM s1
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc r]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                {[(w `+Z` <span class="mi">1</span>, spec.Flag s1 C,
                   spec.Flag s1 V)]}
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                          Reg :=
                            <span class="kr">match</span> l <span class="kr">with</span>
                            | RegLoc r =&gt;
                                <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                                  <span class="kr">if</span> reg_eqb r r&#39;
                                  <span class="kr">then</span> w0
                                  <span class="kr">else</span> spec.Reg s1 r&#39;
                            | MemLoc _ =&gt; spec.Reg s1
                            <span class="kr">end</span>;
                          Flag :=
                            <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                              <span class="kr">match</span> f <span class="kr">with</span>
                              | spec.N =&gt;
                                  <span class="kr">match</span>
                                    bv_unsigned w0
                                  <span class="kr">with</span>
                                  | <span class="mi">0</span>%Z =&gt; false
                                  | Z.pos a =&gt;
                                      Pos.testbit a <span class="mi">7</span>
                                  | Z.neg a =&gt;
                                      negb
                                        (N.testbit
                                           (Pos.pred_N
                                              a) <span class="mi">7</span>)
                                  <span class="kr">end</span>
                              | V =&gt; v
                              | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                              | C =&gt; c
                              | _ =&gt; spec.Flag s1 f
                              <span class="kr">end</span>;
                          PC :=
                            spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
                          RAM :=
                            <span class="kr">match</span> l <span class="kr">with</span>
                            | RegLoc _ =&gt; spec.RAM s1
                            | MemLoc a =&gt;
                                write a w0
                                  (spec.RAM s1)
                            <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk144"><span class="nb">move</span>=&gt; [-&gt; [-&gt; [-&gt; -&gt;]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r (spec.Reg s1 r `+Z` <span class="mi">1</span>);
  Flag := setNZ s1 (spec.Reg s1 r `+Z` <span class="mi">1</span>);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà {[RegLoc r]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              {[(w `+Z` <span class="mi">1</span>, 
                 spec.Flag s1 C, 
                 spec.Flag s1 V)]}
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk145"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r (spec.Reg s1 r `+Z` <span class="mi">1</span>);
  Flag := setNZ s1 (spec.Reg s1 r `+Z` <span class="mi">1</span>);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc r)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        {[(w `+Z` <span class="mi">1</span>, spec.Flag s1 C, spec.Flag s1 V)]}
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc r <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
                  RAM :=
                    <span class="kr">match</span> RegLoc r <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk146"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r (spec.Reg s1 r `+Z` <span class="mi">1</span>);
  Flag := setNZ s1 (spec.Reg s1 r `+Z` <span class="mi">1</span>);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà {[(spec.Reg s1 r `+Z` <span class="mi">1</span>, 
     spec.Flag s1 C, spec.Flag s1 V)]}
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb r r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk147"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r (spec.Reg s1 r `+Z` <span class="mi">1</span>);
  Flag := setNZ s1 (spec.Reg s1 r `+Z` <span class="mi">1</span>);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà (<span class="kr">let</span>
   &#39;(w, c, v) :=
    (spec.Reg s1 r `+Z` <span class="mi">1</span>, 
     spec.Flag s1 C, spec.Flag s1 V) <span class="kr">in</span>
    {[{|
        Reg :=
          <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
            <span class="kr">if</span> reg_eqb r r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | V =&gt; v
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; c
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>;
        PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
        RAM := spec.RAM s1
      |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk148">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r (spec.Reg s1 r `+Z` <span class="mi">1</span>);
  Flag := setNZ s1 (spec.Reg s1 r `+Z` <span class="mi">1</span>);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|} =
{|
  Reg :=
    <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
      <span class="kr">if</span> reg_eqb r r&#39;
      <span class="kr">then</span> spec.Reg s1 r `+Z` <span class="mi">1</span>
      <span class="kr">else</span> spec.Reg s1 r&#39;;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (spec.Reg s1 r `+Z` <span class="mi">1</span>)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb (spec.Reg s1 r `+Z` <span class="mi">1</span>) <span class="mi">0</span>
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk149"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 (spec.Reg s1 r `+Z` <span class="mi">1</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned (spec.Reg s1 r `+Z` <span class="mi">1</span>) <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb (spec.Reg s1 r `+Z` <span class="mi">1</span>) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk14a"><span class="kn">Lemma</span> <span class="nf">run_Dec_mode</span> <span class="nv">s1</span> <span class="nv">s2</span>
    (<span class="nv">mode</span> : spec.mem_addressing_mode) (<span class="nv">mode&#39;</span> : mem_mode) <span class="nv">len</span> :
    len = Z.of_nat (S (mode_len mode&#39;)) -&gt;
    spec.DEC_mode s1 s2 mode len -&gt;
    (<span class="kr">forall</span> <span class="nv">addr</span>, mode s1 addr -&gt; MemLoc addr ‚àà mode_loc s1 mode&#39;) -&gt;
    s2 ‚àà run_instr (Typical mode&#39; Dec true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí DEC_mode s1 s2 mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2 ‚àà run_instr (Typical mode&#39; Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk14b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">len = Z.of_nat (S (mode_len mode&#39;))
‚Üí DEC_mode s1 s2 mode len
  ‚Üí (<span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
       mode s1 addr ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;)
    ‚Üí s2 ‚àà run_instr (Typical mode&#39; Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk14c"><span class="nb">move</span>=&gt; -&gt; H mode_spec; <span class="nb">move</span>: H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DEC_mode s1 s2 mode (Z.of_nat (S (mode_len mode&#39;)))
‚Üí s2 ‚àà run_instr (Typical mode&#39; Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk14d"><span class="nb">rewrite</span> /DEC_mode.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC s2 =
       PC s1 `+Z` Z.of_nat (S (mode_len mode&#39;))
       ‚àß Reg s2 = Reg s1
         ‚àß Flag s2 = setNZ s1 (w `-Z` <span class="mi">1</span>)
           ‚àß RAM s2 = write addr (w `-Z` <span class="mi">1</span>) (RAM s1))
‚Üí s2 ‚àà run_instr (Typical mode&#39; Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk14e"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> (<span class="nv">addr</span> : bv <span class="mi">16</span>) (<span class="nv">w</span> : bv <span class="mi">8</span>),
   mode s1 addr
   ‚àß spec.fetch s1 addr w
     ‚àß PC =
       spec.PC s1
       `+Z` Z.of_nat
              (S
                 (<span class="kr">match</span>
                    mode&#39; <span class="kr">as</span> m
                    <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                  <span class="kr">with</span>
                  | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                  | Abs wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                  | Zpg wildcard&#39; =&gt;
                      <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                  | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                  | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                  | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                  <span class="kr">end</span> eq_refl))
       ‚àß Reg = spec.Reg s1
         ‚àß Flag = setNZ s1 (w `-Z` <span class="mi">1</span>)
           ‚àß RAM = write addr (w `-Z` <span class="mi">1</span>) (spec.RAM s1))
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                {[(w `-Z` <span class="mi">1</span>, 
                   spec.Flag s1 C, 
                   spec.Flag s1 V)]}
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (... ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : ... = mode&#39;, <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk14f"><span class="nb">move</span>=&gt; [addr&#39; [w [/mode_spec m [fetch_w [-&gt; [-&gt; [-&gt; -&gt;]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := setNZ s1 (w `-Z` <span class="mi">1</span>);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; (w `-Z` <span class="mi">1</span>) (spec.RAM s1)
|}
‚àà (MemLoc &lt;$&gt; mem_mode_addr s1 mode&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              {[(w `-Z` <span class="mi">1</span>, 
                 spec.Flag s1 C, 
                 spec.Flag s1 V)]}
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1
                        `+Z` 
                        Z.of_nat
                        (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk150"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := setNZ s1 (w `-Z` <span class="mi">1</span>);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; (w `-Z` <span class="mi">1</span>) (spec.RAM s1)
|}
‚àà read s1 (MemLoc addr&#39;)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        {[(w `-Z` <span class="mi">1</span>, spec.Flag s1 C, spec.Flag s1 V)]}
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> MemLoc addr&#39; <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC :=
                    spec.PC s1
                    `+Z` 
                    Z.of_nat
                      (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
                  RAM :=
                    <span class="kr">match</span> MemLoc addr&#39; <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk151"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := setNZ s1 (w `-Z` <span class="mi">1</span>);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; (w `-Z` <span class="mi">1</span>) (spec.RAM s1)
|}
‚àà {[(w `-Z` <span class="mi">1</span>, spec.Flag s1 C, spec.Flag s1 V)]}
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg := spec.Reg s1;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC :=
              spec.PC s1
              `+Z` Z.of_nat
                     (S
                        (<span class="kr">match</span>
                        mode&#39; <span class="kr">as</span> m
                        <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                        <span class="kr">with</span>
                        | Imm =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                        | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                        | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                        | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                        | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                        | Rel =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                        <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
            RAM := write addr&#39; w (spec.RAM s1)
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk152"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  mode s1 addr
  ‚Üí MemLoc addr ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>MemLoc addr&#39; ‚àà mode_loc s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := setNZ s1 (w `-Z` <span class="mi">1</span>);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; (w `-Z` <span class="mi">1</span>) (spec.RAM s1)
|}
‚àà (<span class="kr">let</span>
   &#39;(w, c, v) :=
    (w `-Z` <span class="mi">1</span>, spec.Flag s1 C, spec.Flag s1 V) <span class="kr">in</span>
    {[{|
        Reg := spec.Reg s1;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | V =&gt; v
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; c
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>;
        PC :=
          spec.PC s1
          `+Z` Z.of_nat
                 (S
                    (<span class="kr">match</span>
                       mode&#39; <span class="kr">as</span> m
                       <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
                     <span class="kr">with</span>
                     | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
                     | Abs wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;,
                        <span class="mi">2</span>%nat
                     | Zpg wildcard&#39; =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;,
                        <span class="mi">1</span>%nat
                     | XInd =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
                     | IndY =&gt;
                        <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
                     | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
                     <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
        RAM := write addr&#39; w (spec.RAM s1)
      |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk153">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := setNZ s1 (w `-Z` <span class="mi">1</span>);
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl));
  RAM := write addr&#39; (w `-Z` <span class="mi">1</span>) (spec.RAM s1)
|} =
{|
  Reg := spec.Reg s1;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span> bv_unsigned (w `-Z` <span class="mi">1</span>) <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb (w `-Z` <span class="mi">1</span>) <span class="mi">0</span>
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC :=
    spec.PC s1
    `+Z` Z.of_nat
           (S
              (<span class="kr">match</span>
                 mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
               <span class="kr">with</span>
               | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
               | Abs wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
               | Zpg wildcard&#39; =&gt;
                   <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
               | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
               | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
               | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
               <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>));
  RAM := write addr&#39; (w `-Z` <span class="mi">1</span>) (spec.RAM s1)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk154"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 (w `-Z` <span class="mi">1</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned (w `-Z` <span class="mi">1</span>) <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb (w `-Z` <span class="mi">1</span>) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk155" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk155"><hr></label><div class="goal-conclusion">spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl)) =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk156">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 (w `-Z` <span class="mi">1</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned (w `-Z` <span class="mi">1</span>) <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb (w `-Z` <span class="mi">1</span>) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk157">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>mode</var><span class="hyp-type"><b>: </b><span>mem_addressing_mode</span></span></span><br><span><var>mode'</var><span class="hyp-type"><b>: </b><span>mem_mode</span></span></span><br><span><var>len</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>addr'</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>w</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>mode_spec</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÄ</span> <span class="nv">x</span> : bv <span class="mi">16</span>,
  mode s1 x
  ‚Üí <span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
      MemLoc x = MemLoc y
      ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  MemLoc addr&#39; = MemLoc y
  ‚àß y ‚àà mem_mode_addr s1 mode&#39;</span></span></span><br><span><var>fetch_w</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 addr&#39; w</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl)) =
spec.PC s1
`+Z` Z.of_nat
       (S
          (<span class="kr">match</span>
             mode&#39; <span class="kr">as</span> m <span class="kr">return</span> (m = mode&#39; ‚Üí nat)
           <span class="kr">with</span>
           | Imm =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Imm = mode&#39;, <span class="mi">1</span>%nat
           | Abs wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Abs wildcard&#39; = mode&#39;, <span class="mi">2</span>%nat
           | Zpg wildcard&#39; =&gt;
               <span class="kr">Œª</span> <span class="nv">_</span> : Zpg wildcard&#39; = mode&#39;, <span class="mi">1</span>%nat
           | XInd =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : XInd = mode&#39;, <span class="mi">1</span>%nat
           | IndY =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : IndY = mode&#39;, <span class="mi">1</span>%nat
           | Rel =&gt; <span class="kr">Œª</span> <span class="nv">_</span> : Rel = mode&#39;, <span class="mi">1</span>%nat
           <span class="kr">end</span> eq_refl `max` <span class="mi">0</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span> mode&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk158"><span class="kn">Lemma</span> <span class="nf">run_Dec_reg</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">r</span> :
    spec.DEC_reg s1 s2 r -&gt;
    s2 ‚àà run_instr (Typical (RegMode r) Dec true) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DEC_reg s1 s2 r
‚Üí s2 ‚àà run_instr (Typical (RegMode r) Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk159"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">DEC_reg s1 s2 r
‚Üí s2 ‚àà run_instr (Typical (RegMode r) Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk15a"><span class="nb">rewrite</span> /DEC_reg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC s2 = PC s1 `+Z` <span class="mi">1</span>
‚àß Reg s2 = setReg s1 r (Reg s1 r `-Z` <span class="mi">1</span>)
  ‚àß Flag s2 = setNZ s1 (Reg s1 r `-Z` <span class="mi">1</span>)
    ‚àß RAM s2 = RAM s1
‚Üí s2 ‚àà run_instr (Typical (RegMode r) Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk15b"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">PC = spec.PC s1 `+Z` <span class="mi">1</span>
‚àß Reg = setReg s1 r (spec.Reg s1 r `-Z` <span class="mi">1</span>)
  ‚àß Flag = setNZ s1 (spec.Reg s1 r `-Z` <span class="mi">1</span>)
    ‚àß RAM = spec.RAM s1
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà {[RegLoc r]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
          read s1 l
          ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
                {[(w `-Z` <span class="mi">1</span>, spec.Flag s1 C,
                   spec.Flag s1 V)]}
                ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                      {[{|
                          Reg :=
                            <span class="kr">match</span> l <span class="kr">with</span>
                            | RegLoc r =&gt;
                                <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                                  <span class="kr">if</span> reg_eqb r r&#39;
                                  <span class="kr">then</span> w0
                                  <span class="kr">else</span> spec.Reg s1 r&#39;
                            | MemLoc _ =&gt; spec.Reg s1
                            <span class="kr">end</span>;
                          Flag :=
                            <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                              <span class="kr">match</span> f <span class="kr">with</span>
                              | spec.N =&gt;
                                  <span class="kr">match</span>
                                    bv_unsigned w0
                                  <span class="kr">with</span>
                                  | <span class="mi">0</span>%Z =&gt; false
                                  | Z.pos a =&gt;
                                      Pos.testbit a <span class="mi">7</span>
                                  | Z.neg a =&gt;
                                      negb
                                        (N.testbit
                                           (Pos.pred_N
                                              a) <span class="mi">7</span>)
                                  <span class="kr">end</span>
                              | V =&gt; v
                              | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                              | C =&gt; c
                              | _ =&gt; spec.Flag s1 f
                              <span class="kr">end</span>;
                          PC :=
                            spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
                          RAM :=
                            <span class="kr">match</span> l <span class="kr">with</span>
                            | RegLoc _ =&gt; spec.RAM s1
                            | MemLoc a =&gt;
                                write a w0
                                  (spec.RAM s1)
                            <span class="kr">end</span>
                        |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk15c"><span class="nb">move</span>=&gt; [-&gt; [-&gt; [-&gt; -&gt;]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r (spec.Reg s1 r `-Z` <span class="mi">1</span>);
  Flag := setNZ s1 (spec.Reg s1 r `-Z` <span class="mi">1</span>);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà {[RegLoc r]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">l</span> : loc,
        read s1 l
        ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
              {[(w `-Z` <span class="mi">1</span>, 
                 spec.Flag s1 C, 
                 spec.Flag s1 V)]}
              ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
                    {[{|
                        Reg :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                        | MemLoc _ =&gt; spec.Reg s1
                        <span class="kr">end</span>;
                        Flag :=
                        <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                        <span class="kr">match</span> f <span class="kr">with</span>
                        | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                        | V =&gt; v
                        | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                        | C =&gt; c
                        | _ =&gt; spec.Flag s1 f
                        <span class="kr">end</span>;
                        PC :=
                        spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
                        RAM :=
                        <span class="kr">match</span> l <span class="kr">with</span>
                        | RegLoc _ =&gt; spec.RAM s1
                        | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                        <span class="kr">end</span>
                      |}]})))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk15d"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r (spec.Reg s1 r `-Z` <span class="mi">1</span>);
  Flag := setNZ s1 (spec.Reg s1 r `-Z` <span class="mi">1</span>);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà read s1 (RegLoc r)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        {[(w `-Z` <span class="mi">1</span>, spec.Flag s1 C, spec.Flag s1 V)]}
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              {[{|
                  Reg :=
                    <span class="kr">match</span> RegLoc r <span class="kr">with</span>
                    | RegLoc r =&gt;
                        <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                        <span class="kr">if</span> reg_eqb r r&#39;
                        <span class="kr">then</span> w0
                        <span class="kr">else</span> spec.Reg s1 r&#39;
                    | MemLoc _ =&gt; spec.Reg s1
                    <span class="kr">end</span>;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | spec.N =&gt;
                        <span class="kr">match</span> bv_unsigned w0 <span class="kr">with</span>
                        | <span class="mi">0</span>%Z =&gt; false
                        | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                        | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                        <span class="kr">end</span>
                      | V =&gt; v
                      | spec.Z =&gt; bv_eqb w0 <span class="mi">0</span>
                      | C =&gt; c
                      | _ =&gt; spec.Flag s1 f
                      <span class="kr">end</span>;
                  PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
                  RAM :=
                    <span class="kr">match</span> RegLoc r <span class="kr">with</span>
                    | RegLoc _ =&gt; spec.RAM s1
                    | MemLoc a =&gt;
                        write a w0 (spec.RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk15e"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r (spec.Reg s1 r `-Z` <span class="mi">1</span>);
  Flag := setNZ s1 (spec.Reg s1 r `-Z` <span class="mi">1</span>);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà {[(spec.Reg s1 r `-Z` <span class="mi">1</span>, 
     spec.Flag s1 C, spec.Flag s1 V)]}
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        {[{|
            Reg :=
              <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                <span class="kr">if</span> reg_eqb r r&#39;
                <span class="kr">then</span> w
                <span class="kr">else</span> spec.Reg s1 r&#39;;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | spec.N =&gt;
                    <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                    | <span class="mi">0</span>%Z =&gt; false
                    | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                    | Z.neg a =&gt;
                        negb
                        (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                    <span class="kr">end</span>
                | V =&gt; v
                | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
                | C =&gt; c
                | _ =&gt; spec.Flag s1 f
                <span class="kr">end</span>;
            PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk15f"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r (spec.Reg s1 r `-Z` <span class="mi">1</span>);
  Flag := setNZ s1 (spec.Reg s1 r `-Z` <span class="mi">1</span>);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|}
‚àà (<span class="kr">let</span>
   &#39;(w, c, v) :=
    (spec.Reg s1 r `-Z` <span class="mi">1</span>, 
     spec.Flag s1 C, spec.Flag s1 V) <span class="kr">in</span>
    {[{|
        Reg :=
          <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
            <span class="kr">if</span> reg_eqb r r&#39; <span class="kr">then</span> w <span class="kr">else</span> spec.Reg s1 r&#39;;
        Flag :=
          <span class="kr">Œª</span> <span class="nv">f</span> : flag,
            <span class="kr">match</span> f <span class="kr">with</span>
            | spec.N =&gt;
                <span class="kr">match</span> bv_unsigned w <span class="kr">with</span>
                | <span class="mi">0</span>%Z =&gt; false
                | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
                | Z.neg a =&gt;
                    negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
                <span class="kr">end</span>
            | V =&gt; v
            | spec.Z =&gt; bv_eqb w <span class="mi">0</span>
            | C =&gt; c
            | _ =&gt; spec.Flag s1 f
            <span class="kr">end</span>;
        PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
        RAM := spec.RAM s1
      |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk160">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 r (spec.Reg s1 r `-Z` <span class="mi">1</span>);
  Flag := setNZ s1 (spec.Reg s1 r `-Z` <span class="mi">1</span>);
  PC := spec.PC s1 `+Z` <span class="mi">1</span>;
  RAM := spec.RAM s1
|} =
{|
  Reg :=
    <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
      <span class="kr">if</span> reg_eqb r r&#39;
      <span class="kr">then</span> spec.Reg s1 r `-Z` <span class="mi">1</span>
      <span class="kr">else</span> spec.Reg s1 r&#39;;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | spec.N =&gt;
          <span class="kr">match</span>
            bv_unsigned (spec.Reg s1 r `-Z` <span class="mi">1</span>)
          <span class="kr">with</span>
          | <span class="mi">0</span>%Z =&gt; false
          | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
          | Z.neg a =&gt;
              negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
          <span class="kr">end</span>
      | V =&gt; spec.Flag s1 V
      | spec.Z =&gt; bv_eqb (spec.Reg s1 r `-Z` <span class="mi">1</span>) <span class="mi">0</span>
      | C =&gt; spec.Flag s1 C
      | _ =&gt; spec.Flag s1 f
      <span class="kr">end</span>;
  PC := spec.PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk161"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>r</var><span class="hyp-type"><b>: </b><span>reg</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setNZ s1 (spec.Reg s1 r `-Z` <span class="mi">1</span>) =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | spec.N =&gt;
       <span class="kr">match</span> bv_unsigned (spec.Reg s1 r `-Z` <span class="mi">1</span>) <span class="kr">with</span>
       | <span class="mi">0</span>%Z =&gt; false
       | Z.pos a =&gt; Pos.testbit a <span class="mi">7</span>
       | Z.neg a =&gt; negb (N.testbit (Pos.pred_N a) <span class="mi">7</span>)
       <span class="kr">end</span>
   | V =&gt; spec.Flag s1 V
   | spec.Z =&gt; bv_eqb (spec.Reg s1 r `-Z` <span class="mi">1</span>) <span class="mi">0</span>
   | C =&gt; spec.Flag s1 C
   | _ =&gt; spec.Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk162"><span class="kn">Lemma</span> <span class="nf">run_Branch</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">f</span> (<span class="nv">val</span> : bool) :
    spec.branch_instr s1 s2
        (<span class="kr">if</span> val
        <span class="kr">then</span> (<span class="kr">fun</span> <span class="nv">s</span> =&gt; Flag s f)
        <span class="kr">else</span> (<span class="kr">fun</span> <span class="nv">s</span> =&gt; negb (Flag s f))) -&gt;
    s2 ‚àà run_instr (Control (Branch f val)) s1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">branch_instr s1 s2
  (<span class="kr">if</span> val
   <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, Flag s f
   <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (Flag s f))
‚Üí s2 ‚àà run_instr (Control (Branch f val)) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk163"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">branch_instr s1 s2
  (<span class="kr">if</span> val
   <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, Flag s f
   <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (Flag s f))
‚Üí s2 ‚àà run_instr (Control (Branch f val)) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk164"><span class="nb">rewrite</span> /branch_instr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">dist</span> : bv <span class="mi">8</span>,
   spec.fetch s1 (PC s1 `+Z` <span class="mi">1</span>) dist
   ‚àß PC s2 =
     (<span class="kr">if</span>
       (<span class="kr">if</span> val
        <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, Flag s f
        <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (Flag s f)) s1
      <span class="kr">then</span> PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
      <span class="kr">else</span> PC s1 `+Z` <span class="mi">2</span>)
     ‚àß Reg s2 = Reg s1
       ‚àß Flag s2 = Flag s1 ‚àß RAM s2 = RAM s1)
‚Üí s2 ‚àà run_instr (Control (Branch f val)) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk165"><span class="nb">destruct</span> s2; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">‚àÉ</span> <span class="nv">dist</span> : bv <span class="mi">8</span>,
   spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist
   ‚àß PC =
     (<span class="kr">if</span>
       (<span class="kr">if</span> val
        <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
        <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
      <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
      <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>)
     ‚àß Reg = spec.Reg s1
       ‚àß Flag = spec.Flag s1 ‚àß RAM = spec.RAM s1)
‚Üí {| Reg := Reg; Flag := Flag; PC := PC; RAM := RAM |}
  ‚àà (<span class="kr">if</span> decide (spec.Flag s1 f = val)
     <span class="kr">then</span>
      propset_bind (bv <span class="mi">8</span>) (bv <span class="mi">16</span>)
        (<span class="kr">Œª</span> <span class="nv">a</span> : bv <span class="mi">8</span>,
           {[spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> a]})
        {[ w | spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) w ]}
      ‚â´= (<span class="kr">Œª</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
            {[{|
                Reg := spec.Reg s1;
                Flag := spec.Flag s1;
                PC := addr;
                RAM := spec.RAM s1
              |}]})
     <span class="kr">else</span>
      {[{|
          Reg := spec.Reg s1;
          Flag := spec.Flag s1;
          PC := spec.PC s1 `+Z` <span class="mi">2</span>;
          RAM := spec.RAM s1
        |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk166"><span class="nb">move</span>=&gt; [dist [fetch_dist [-&gt; [-&gt; [-&gt; -&gt;]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>dist</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_dist</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    <span class="kr">if</span>
     (<span class="kr">if</span> val
      <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
      <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
    <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
    <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>;
  RAM := spec.RAM s1
|}
‚àà (<span class="kr">if</span> decide (spec.Flag s1 f = val)
   <span class="kr">then</span>
    propset_bind (bv <span class="mi">8</span>) (bv <span class="mi">16</span>)
      (<span class="kr">Œª</span> <span class="nv">a</span> : bv <span class="mi">8</span>,
         {[spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> a]})
      {[ w | spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) w ]}
    ‚â´= (<span class="kr">Œª</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
          {[{|
              Reg := spec.Reg s1;
              Flag := spec.Flag s1;
              PC := addr;
              RAM := spec.RAM s1
            |}]})
   <span class="kr">else</span>
    {[{|
        Reg := spec.Reg s1;
        Flag := spec.Flag s1;
        PC := spec.PC s1 `+Z` <span class="mi">2</span>;
        RAM := spec.RAM s1
      |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk167"><span class="nb">case</span> (decide (spec.Flag s1 f = val)) <span class="kr">as</span> [eq|neq].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>dist</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_dist</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>spec.Flag s1 f = val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    <span class="kr">if</span>
     (<span class="kr">if</span> val
      <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
      <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
    <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
    <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>;
  RAM := spec.RAM s1
|}
‚àà propset_bind (bv <span class="mi">8</span>) (bv <span class="mi">16</span>)
    (<span class="kr">Œª</span> <span class="nv">a</span> : bv <span class="mi">8</span>,
       {[spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> a]})
    {[ w | spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) w ]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
        {[{|
            Reg := spec.Reg s1;
            Flag := spec.Flag s1;
            PC := addr;
            RAM := spec.RAM s1
          |}]})</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk168" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>dist</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_dist</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist</span></span></span><br><span><var>neq</var><span class="hyp-type"><b>: </b><span>spec.Flag s1 f ‚â† val</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk168"><hr></label><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    <span class="kr">if</span>
     (<span class="kr">if</span> val
      <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
      <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
    <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
    <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>;
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg := spec.Reg s1;
      Flag := spec.Flag s1;
      PC := spec.PC s1 `+Z` <span class="mi">2</span>;
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk169">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>dist</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_dist</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>spec.Flag s1 f = val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    <span class="kr">if</span>
     (<span class="kr">if</span> val
      <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
      <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
    <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
    <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>;
  RAM := spec.RAM s1
|}
‚àà propset_bind (bv <span class="mi">8</span>) (bv <span class="mi">16</span>)
    (<span class="kr">Œª</span> <span class="nv">a</span> : bv <span class="mi">8</span>,
       {[spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> a]})
    {[ w | spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) w ]}
  ‚â´= (<span class="kr">Œª</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
        {[{|
            Reg := spec.Reg s1;
            Flag := spec.Flag s1;
            PC := addr;
            RAM := spec.RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk16a"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="kp">first</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>dist</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_dist</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>spec.Flag s1 f = val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span>
  (<span class="kr">if</span> val
   <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
   <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
 <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
 <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>)
‚àà propset_bind (bv <span class="mi">8</span>) (bv <span class="mi">16</span>)
    (<span class="kr">Œª</span> <span class="nv">a</span> : bv <span class="mi">8</span>,
       {[spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> a]})
    {[ w | spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) w ]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk16b"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_dist.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>dist</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_dist</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist</span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>spec.Flag s1 f = val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span>
  (<span class="kr">if</span> val
   <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
   <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
 <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
 <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>)
‚àà {[spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">move</span>: eq; <span class="nb">case</span> val; <span class="nb">move</span>=&gt; -&gt;; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk16c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>dist</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_dist</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist</span></span></span><br><span><var>neq</var><span class="hyp-type"><b>: </b><span>spec.Flag s1 f ‚â† val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    <span class="kr">if</span>
     (<span class="kr">if</span> val
      <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
      <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
    <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
    <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>;
  RAM := spec.RAM s1
|}
‚àà {[{|
      Reg := spec.Reg s1;
      Flag := spec.Flag s1;
      PC := spec.PC s1 `+Z` <span class="mi">2</span>;
      RAM := spec.RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk16d">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>dist</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_dist</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist</span></span></span><br><span><var>neq</var><span class="hyp-type"><b>: </b><span>spec.Flag s1 f ‚â† val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC :=
    <span class="kr">if</span>
     (<span class="kr">if</span> val
      <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
      <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
    <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
    <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>;
  RAM := spec.RAM s1
|} =
{|
  Reg := spec.Reg s1;
  Flag := spec.Flag s1;
  PC := spec.PC s1 `+Z` <span class="mi">2</span>;
  RAM := spec.RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk16e"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>dist</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_dist</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist</span></span></span><br><span><var>neq</var><span class="hyp-type"><b>: </b><span>spec.Flag s1 f ‚â† val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span>
  (<span class="kr">if</span> val
   <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
   <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
 <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
 <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>) = 
spec.PC s1 `+Z` <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk16f"><span class="nb">move</span>: neq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>Reg</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>Flag</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>PC</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>RAM</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>flag</span></span></span><br><span><var>val</var><span class="hyp-type"><b>: </b><span>bool</span></span></span><br><span><var>dist</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_dist</var><span class="hyp-type"><b>: </b><span>spec.fetch s1 (spec.PC s1 `+Z` <span class="mi">1</span>) dist</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">spec.Flag s1 f ‚â† val
‚Üí (<span class="kr">if</span>
    (<span class="kr">if</span> val
     <span class="kr">then</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, spec.Flag s f
     <span class="kr">else</span> <span class="kr">Œª</span> <span class="nv">s</span> : state, negb (spec.Flag s f)) s1
   <span class="kr">then</span> spec.PC s1 `+Z` <span class="mi">2</span> + bv_sign_extend <span class="mi">16</span> dist
   <span class="kr">else</span> spec.PC s1 `+Z` <span class="mi">2</span>) = 
  spec.PC s1 `+Z` <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">case</span> val; <span class="nb">case</span>: (spec.Flag s1 f).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
<div class="section" id="main-theorem">
<h2>Main Theorem</h2>
<p>With all that done, we prove the main theorem.</p>
<p>This is basically a 256-way case split.
* For invalid instructions, there's nothing to do.
* For most valid instructions, we simply apply a few of the above lemmas.
* For the last few instructions, we just prove it manually.</p>
<div class="section" id="a-note-about-the-case-split">
<h3>A note about the case split</h3>
<p>I don't know of a nice way to case-split on a <tt class="docutils literal">bv 8</tt>.
However, the Coq standard library provides a <tt class="docutils literal">byte</tt> type,
which is defined by listing out the 256 possible values.
This makes case-splitting trivial.</p>
<p>In <tt class="docutils literal">utils.v</tt>, I prove the equivalence of <tt class="docutils literal">bv 8</tt> and <tt class="docutils literal">byte</tt>.
So I use that here, as a method of case-splitting over a <tt class="docutils literal">bv 8</tt>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> theories <span class="kn">Require Import</span> utils.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk170"><span class="kn">Theorem</span> <span class="nf">run_instr_spec</span> : run_instr_claim.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">run_instr_claim</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk171"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">run_instr_claim</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk172"><span class="nb">move</span>=&gt; opcode.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> parse_instr opcode <span class="kr">with</span>
| Some i =&gt;
    <span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
      instruction s1 s2 opcode ‚Üí s2 ‚àà run_instr i s1
| None =&gt; <span class="kt">True</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk173"><span class="nb">rewrite</span> -(bv_of_byte_of_bv opcode) bv_of_byte_speedup.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  parse_instr (fast_bv_of_byte (byte_of_bv opcode))
<span class="kr">with</span>
| Some i =&gt;
    <span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
      instruction s1 s2
        (fast_bv_of_byte (byte_of_bv opcode))
      ‚Üí s2 ‚àà run_instr i s1
| None =&gt; <span class="kt">True</span>
<span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk174"><span class="nb">case</span> (byte_of_bv opcode);
        <span class="nb">set</span> tmp := (parse_instr _);
        <span class="nb">simpl</span> <span class="kr">in</span> tmp;
        <span class="nb">rewrite</span> /tmp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk175" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk175"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;001&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or XInd) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk176" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk176"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk177" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk177"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk178" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk178"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk179" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk179"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;005&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or Zpg0) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk17a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (ShiftL false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk17a"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;006&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (ShiftL false) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk17b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk17b"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk17c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk17c"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk17d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk17d"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;009&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk17e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (ShiftL false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk17e"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;010&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (ShiftL false) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk17f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk17f"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk180" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk180"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk181" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk181"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;013&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or Abs0) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk182" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (ShiftL false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk182"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;014&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (ShiftL false) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk183" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk183"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk184" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch spec.N false))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk184"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;016&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch spec.N false)) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk185" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk185"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;017&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or IndY) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk186" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk186"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk187" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk187"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk188" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk188"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk189" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk189"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;021&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or ZpgX) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk18a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (ShiftL false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk18a"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;022&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (ShiftL false) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk18b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk18b"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk18c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag C false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk18c"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;024&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag C false) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk18d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk18d"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;025&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or AbsY) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk18e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk18e"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk18f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk18f"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk190" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk190"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk191" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk191"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;029&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or AbsX) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk192" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX (ShiftL false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk192"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;030&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsX (ShiftL false) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk193" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk193"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk194" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jsr)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk194"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot; &quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control Jsr) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk195" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk195"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;!&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And XInd) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk196" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk196"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk197" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk197"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk198" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Bit Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk198"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;$&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Bit Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk199" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk199"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;%&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk19a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (ShiftL true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk19a"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;&amp;&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (ShiftL true) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk19b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk19b"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk19c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk19c"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk19d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk19d"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;)&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk19e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (ShiftL true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk19e"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;*&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (ShiftL true) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk19f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk19f"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1a0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Bit Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1a0"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;,&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Bit Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1a1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1a1"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;-&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (ShiftL true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1a2"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;.&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (ShiftL true) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1a3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1a3"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1a4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch spec.N true))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1a4"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;0&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch spec.N true)) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1a5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1a5"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;1&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And IndY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1a6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1a6"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1a7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1a7"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1a8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1a8"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1a9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1a9"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;5&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And ZpgX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1aa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (ShiftL true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1aa"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;6&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (ShiftL true) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ab" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ab"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag C true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ac"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;8&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag C true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ad" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ad"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;9&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And AbsY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ae"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1af" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1af"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1b0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1b0"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1b1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1b1"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;=&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And AbsX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1b2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX (ShiftL true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1b2"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;&gt;&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsX (ShiftL true) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1b3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1b3"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1b4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1b4"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1b5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1b5"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;A&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor XInd) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1b6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1b6"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1b7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1b7"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1b8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1b8"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1b9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1b9"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;E&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (ShiftR false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ba"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;F&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (ShiftR false) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1bb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1bb"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1bc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1bc"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1bd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1bd"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;I&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1be" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (ShiftR false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1be"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;J&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (ShiftR false) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1bf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1bf"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1c0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jmp)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1c0"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;L&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control Jmp) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1c1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1c1"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;M&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1c2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (ShiftR false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1c2"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;N&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (ShiftR false) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1c3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1c3"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1c4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch V false))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1c4"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;P&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch V false)) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1c5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1c5"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;Q&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor IndY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1c6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1c6"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1c7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1c7"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1c8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1c8"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1c9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1c9"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;U&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor ZpgX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ca" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (ShiftR false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ca"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;V&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (ShiftR false) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1cb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1cb"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1cc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag I false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1cc"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;X&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag I false) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1cd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1cd"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;Y&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor AbsY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ce"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1cf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1cf"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1d0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1d0"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1d1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1d1"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;]&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor AbsX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1d2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX (ShiftR false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1d2"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;^&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsX (ShiftR false) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1d3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1d3"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1d4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1d4"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;`&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control Rts) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1d5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1d5"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;a&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc XInd) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1d6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1d6"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1d7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1d7"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1d8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1d8"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1d9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1d9"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;e&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1da" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (ShiftR true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1da"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;f&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (ShiftR true) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1db" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1db"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1dc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1dc"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1dd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1dd"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;i&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1de" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (ShiftR true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1de"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;j&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (ShiftR true) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1df" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1df"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1e0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1e0"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1e1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1e1"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;m&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1e2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (ShiftR true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1e2"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;n&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (ShiftR true) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1e3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1e3"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch V true))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1e4"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;p&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch V true)) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1e5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1e5"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;q&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc IndY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1e6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1e6"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1e7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1e7"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1e8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1e8"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1e9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1e9"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;u&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc ZpgX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ea" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (ShiftR true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ea"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;v&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (ShiftR true) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1eb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1eb"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ec" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag I true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ec"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;x&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag I true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ed" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ed"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;y&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc AbsY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ee"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ef" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ef"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1f0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1f0"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1f1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1f1"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;}&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc AbsX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1f2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX (ShiftR true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1f2"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;~&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsX (ShiftR true) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1f3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1f3"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1f4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1f4"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1f5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical XInd (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1f5"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;129&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical XInd (Binop Mov RegA) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1f6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1f6"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1f7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1f7"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1f8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (Binop Mov RegY) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1f8"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;132&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (Binop Mov RegY) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1f9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1f9"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;133&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (Binop Mov RegA) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1fa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1fa"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;134&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (Binop Mov RegX) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1fb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1fb"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1fc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1fc"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;136&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical RegY Dec true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1fd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1fd"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1fe" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov RegX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1fe"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;138&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov RegX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk1ff" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk1ff"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk200" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (Binop Mov RegY) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk200"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;140&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (Binop Mov RegY) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk201" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk201"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;141&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (Binop Mov RegA) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk202" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk202"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;142&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (Binop Mov RegX) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk203" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk203"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk204" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch C false))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk204"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;144&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch C false)) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk205" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical IndY (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk205"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;145&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical IndY (Binop Mov RegA) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk206" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk206"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk207" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk207"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk208" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (Binop Mov RegY) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk208"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;148&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (Binop Mov RegY) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk209" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk209"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;149&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (Binop Mov RegA) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk20a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgY (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk20a"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;150&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgY (Binop Mov RegX) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk20b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk20b"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk20c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov RegY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk20c"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;152&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov RegY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk20d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsY (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk20d"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;153&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsY (Binop Mov RegA) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk20e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk20e"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;154&quot;</span>)
  ‚Üí s2
    ‚àà run_instr
        (Typical (RegMode SP) (Binop Mov RegX) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk20f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk20f"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk210" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk210"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk211" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk211"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;157&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsX (Binop Mov RegA) false)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk212" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk212"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk213" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk213"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk214" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk214"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;160&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk215" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk215"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;161&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov XInd) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk216" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk216"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;162&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk217" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk217"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk218" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk218"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;164&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk219" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk219"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;165&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk21a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk21a"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;166&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk21b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk21b"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk21c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov RegA) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk21c"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;168&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov RegA) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk21d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk21d"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;169&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk21e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov RegA) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk21e"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;170&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov RegA) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk21f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk21f"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk220" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk220"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;172&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk221" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk221"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;173&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk222" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk222"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;174&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk223" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk223"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk224" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch C true))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk224"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;176&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch C true)) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk225" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk225"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;177&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov IndY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk226" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk226"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk227" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk227"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk228" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk228"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;180&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov ZpgX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk229" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk229"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;181&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov ZpgX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk22a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov ZpgY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk22a"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;182&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov ZpgY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk22b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk22b"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk22c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag V false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk22c"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;184&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag V false) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk22d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk22d"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;185&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov AbsY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk22e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov (RegMode SP)) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk22e"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;186&quot;</span>)
  ‚Üí s2
    ‚àà run_instr
        (Typical RegX (Binop Mov (RegMode SP)) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk22f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk22f"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk230" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk230"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;188&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov AbsX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk231" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk231"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;189&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov AbsX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk232" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk232"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;190&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov AbsY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk233" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk233"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk234" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Cmp Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk234"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;192&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Cmp Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk235" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk235"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;193&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp XInd) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk236" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk236"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk237" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk237"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk238" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Cmp Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk238"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;196&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Cmp Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk239" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk239"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;197&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk23a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk23a"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;198&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical Zpg0 Dec true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk23b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk23b"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk23c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk23c"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;200&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical RegY Inc true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk23d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk23d"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;201&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk23e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk23e"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;202&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical RegX Dec true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk23f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk23f"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk240" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Cmp Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk240"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;204&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Cmp Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk241" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk241"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;205&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk242" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk242"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;206&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical Abs0 Dec true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk243" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk243"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk244" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch spec.Z false))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk244"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;208&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch spec.Z false)) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk245" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk245"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;209&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp IndY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk246" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk246"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk247" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk247"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk248" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk248"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk249" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk249"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;213&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp ZpgX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk24a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk24a"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;214&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical ZpgX Dec true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk24b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk24b"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk24c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag D false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk24c"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;216&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag D false) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk24d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk24d"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;217&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp AbsY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk24e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk24e"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk24f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk24f"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk250" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk250"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk251" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk251"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;221&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp AbsX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk252" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk252"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;222&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical AbsX Dec true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk253" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk253"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk254" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Cmp Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk254"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;224&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Cmp Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk255" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk255"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;225&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc XInd) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk256" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk256"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk257" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk257"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk258" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Cmp Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk258"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;228&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Cmp Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk259" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk259"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;229&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc Zpg0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk25a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk25a"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;230&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical Zpg0 Inc true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk25b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk25b"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk25c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk25c"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;232&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical RegX Inc true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk25d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk25d"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;233&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc Imm) true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk25e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some Nop</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk25e"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;234&quot;</span>)
  ‚Üí s2 ‚àà run_instr Nop s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk25f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk25f"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk260" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Cmp Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk260"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;236&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Cmp Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk261" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk261"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;237&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc Abs0) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk262" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk262"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;238&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical Abs0 Inc true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk263" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk263"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk264" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch spec.Z true))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk264"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;240&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch spec.Z true)) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk265" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk265"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;241&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc IndY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk266" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk266"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk267" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk267"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk268" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk268"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk269" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk269"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;245&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc ZpgX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk26a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk26a"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;246&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical ZpgX Inc true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk26b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk26b"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk26c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag D true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk26c"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;248&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag D true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk26d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk26d"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;249&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc AbsY) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk26e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk26e"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk26f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk26f"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk270" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk270"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk271" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk271"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;253&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc AbsX) true)
        s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk272" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk272"><hr></label><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;254&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical AbsX Inc true) s1</div></blockquote><input class="alectryon-extra-goal-toggle" id="instruction-v-chk273" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk273"><hr></label><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* 0 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk274">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk275">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;001&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or XInd) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Or;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ORA_indirect_x | <span class="nb">apply</span> indirect_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk276">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk277" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk277">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk278" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk278">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk279" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk279">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;005&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or Zpg0) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Or;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ORA_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk27a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk27a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (ShiftL false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;006&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (ShiftL false) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift false false);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ASL_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk27b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk27b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk27c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk27c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk27d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk27d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;009&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Or;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ORA_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk27e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk27e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (ShiftL false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;010&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (ShiftL false) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift_A false false); <span class="nb">eapply</span> ASL_A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk27f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk27f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk280" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk280">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk281" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk281">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;013&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or Abs0) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Or;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ORA_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk282" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk282">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (ShiftL false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;014&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (ShiftL false) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift false false);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ASL_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk283" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk283">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* 1 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk284">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch spec.N false))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;016&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch spec.N false)) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Branch; <span class="nb">eapply</span> BPL.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk285">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;017&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or IndY) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Or;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ORA_indirect_y | <span class="nb">apply</span> indirect_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk286">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk287">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk288" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk288">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk289">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;021&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or ZpgX) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Or;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ORA_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk28a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk28a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (ShiftL false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;022&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (ShiftL false) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift false false);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ASL_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk28b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk28c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk28c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag C false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;024&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag C false) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_SetFlag; <span class="nb">eapply</span> CLC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk28d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;025&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or AbsY) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Or;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ORA_absolute_y | <span class="nb">apply</span> absolute_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk28e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk28e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk28f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk28f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk290" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk290">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk291" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk291">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Or AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;029&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Or AbsX) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Or;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ORA_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk292">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX (ShiftL false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;030&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsX (ShiftL false) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift false false);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ASL_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk293" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk293">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* 2 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk294" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk294">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jsr)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot; &quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control Jsr) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk295" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk295"><span class="nb">move</span>=&gt; s1 [? ? ? ?] /JSR H; <span class="nb">specialize</span> (H eq_refl); <span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jsr)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  absolute s1 addr
  ‚àß _PC_ = addr
    ‚àß _Reg_ = setReg s1 SP (Reg s1 SP `-Z` <span class="mi">2</span>)
      ‚àß _Flag_ = Flag s1
        ‚àß _RAM_ =
          write
            (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `-Z` <span class="mi">1</span>))
            (bv_extract <span class="mi">0</span> <span class="mi">8</span> (PC s1 `-Z` <span class="mi">1</span>))
            (write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP))
               (bv_extract <span class="mi">0</span> <span class="mi">8</span> (PC s1 `-Z` <span class="mi">1</span>))
               (RAM s1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := _Reg_;
  Flag := _Flag_;
  PC := _PC_;
  RAM := _RAM_
|} ‚àà run_instr (Control Jsr) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk296"><span class="nb">move</span>: H =&gt; [pc [/absolute_mode [? [eq m]] [-&gt; [-&gt; [-&gt; -&gt;]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jsr)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>pc, _x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>MemLoc pc = MemLoc _x_</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà mem_mode_addr s1 Abs0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 SP `-Z` <span class="mi">2</span>);
  Flag := Flag s1;
  PC := pc;
  RAM :=
    write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `-Z` <span class="mi">1</span>))
      (bv_extract <span class="mi">0</span> <span class="mi">8</span> (PC s1 `-Z` <span class="mi">1</span>))
      (write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP))
         (bv_extract <span class="mi">0</span> <span class="mi">8</span> (PC s1 `-Z` <span class="mi">1</span>)) 
         (RAM s1))
|} ‚àà run_instr (Control Jsr) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk297" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk297"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jsr)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>pc, _x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>MemLoc pc = MemLoc _x_</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà mem_mode_addr s1 Abs0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 SP `-Z` <span class="mi">2</span>);
  Flag := Flag s1;
  PC := pc;
  RAM :=
    write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `-Z` <span class="mi">1</span>))
      (bv_extract <span class="mi">0</span> <span class="mi">8</span> (PC s1 `-Z` <span class="mi">1</span>))
      (write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP))
         (bv_extract <span class="mi">0</span> <span class="mi">8</span> (PC s1 `-Z` <span class="mi">1</span>)) 
         (RAM s1))
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r</span> : reg,
          <span class="kr">if</span> reg_eqb r SP
          <span class="kr">then</span> Reg s1 SP `-Z` <span class="mi">2</span>
          <span class="kr">else</span> Reg s1 r;
      Flag := Flag s1;
      PC := _x_;
      RAM :=
        <span class="kr">let</span> <span class="nv">pc</span> := PC s1 `-Z` <span class="mi">1</span> <span class="kr">in</span>
        write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `-Z` <span class="mi">1</span>))
          (bv_extract <span class="mi">0</span> <span class="mi">8</span> pc)
          (write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP))
             (bv_extract <span class="mi">0</span> <span class="mi">8</span> pc) 
             (RAM s1))
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk298" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk298">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jsr)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>pc, _x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>MemLoc pc = MemLoc _x_</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  _x_ = y
  ‚àß (<span class="kr">‚àÉ</span> <span class="nv">y0</span> : bv <span class="mi">8</span>,
       (<span class="kr">‚àÉ</span> <span class="nv">y1</span> : bv <span class="mi">8</span>,
          y = spec.bv_concat <span class="mi">16</span> y0 y1
          ‚àß spec.fetch s1 (PC s1 `+Z` <span class="mi">2</span>) y1)
       ‚àß spec.fetch s1 (PC s1 `+Z` <span class="mi">1</span>) y0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 SP `-Z` <span class="mi">2</span>);
  Flag := Flag s1;
  PC := pc;
  RAM :=
    write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `-Z` <span class="mi">1</span>))
      (bv_extract <span class="mi">0</span> <span class="mi">8</span> (PC s1 `-Z` <span class="mi">1</span>))
      (write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP))
         (bv_extract <span class="mi">0</span> <span class="mi">8</span> (PC s1 `-Z` <span class="mi">1</span>)) 
         (RAM s1))
|} =
{|
  Reg :=
    <span class="kr">Œª</span> <span class="nv">r</span> : reg,
      <span class="kr">if</span> reg_eqb r SP
      <span class="kr">then</span> Reg s1 SP `-Z` <span class="mi">2</span>
      <span class="kr">else</span> Reg s1 r;
  Flag := Flag s1;
  PC := _x_;
  RAM :=
    write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `-Z` <span class="mi">1</span>))
      (bv_extract <span class="mi">0</span> <span class="mi">8</span> (PC s1 `-Z` <span class="mi">1</span>))
      (write (bv_zero_extend <span class="mi">16</span> (Reg s1 SP))
         (bv_extract <span class="mi">0</span> <span class="mi">8</span> (PC s1 `-Z` <span class="mi">1</span>)) 
         (RAM s1))
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk299" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk299"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jsr)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>pc, _x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>MemLoc pc = MemLoc _x_</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  _x_ = y
  ‚àß (<span class="kr">‚àÉ</span> <span class="nv">y0</span> : bv <span class="mi">8</span>,
       (<span class="kr">‚àÉ</span> <span class="nv">y1</span> : bv <span class="mi">8</span>,
          y = spec.bv_concat <span class="mi">16</span> y0 y1
          ‚àß spec.fetch s1 (PC s1 `+Z` <span class="mi">2</span>) y1)
       ‚àß spec.fetch s1 (PC s1 `+Z` <span class="mi">1</span>) y0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setReg s1 SP (Reg s1 SP `-Z` <span class="mi">2</span>) =
(<span class="kr">Œª</span> <span class="nv">r</span> : reg,
   <span class="kr">if</span> reg_eqb r SP <span class="kr">then</span> Reg s1 SP `-Z` <span class="mi">2</span> <span class="kr">else</span> Reg s1 r)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk29a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jsr)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>pc, _x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>MemLoc pc = MemLoc _x_</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  _x_ = y
  ‚àß (<span class="kr">‚àÉ</span> <span class="nv">y0</span> : bv <span class="mi">8</span>,
       (<span class="kr">‚àÉ</span> <span class="nv">y1</span> : bv <span class="mi">8</span>,
          y = spec.bv_concat <span class="mi">16</span> y0 y1
          ‚àß spec.fetch s1 (PC s1 `+Z` <span class="mi">2</span>) y1)
       ‚àß spec.fetch s1 (PC s1 `+Z` <span class="mi">1</span>) y0)</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk29a"><hr></label><div class="goal-conclusion">pc = _x_</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk29b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk29b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jsr)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>pc, _x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>MemLoc pc = MemLoc _x_</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  _x_ = y
  ‚àß (<span class="kr">‚àÉ</span> <span class="nv">y0</span> : bv <span class="mi">8</span>,
       (<span class="kr">‚àÉ</span> <span class="nv">y1</span> : bv <span class="mi">8</span>,
          y = spec.bv_concat <span class="mi">16</span> y0 y1
          ‚àß spec.fetch s1 (PC s1 `+Z` <span class="mi">2</span>) y1)
       ‚àß spec.fetch s1 (PC s1 `+Z` <span class="mi">1</span>) y0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setReg s1 SP (Reg s1 SP `-Z` <span class="mi">2</span>) =
(<span class="kr">Œª</span> <span class="nv">r</span> : reg,
   <span class="kr">if</span> reg_eqb r SP <span class="kr">then</span> Reg s1 SP `-Z` <span class="mi">2</span> <span class="kr">else</span> Reg s1 r)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk29c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jsr)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>pc, _x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>MemLoc pc = MemLoc _x_</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">y</span> : bv <span class="mi">16</span>,
  _x_ = y
  ‚àß (<span class="kr">‚àÉ</span> <span class="nv">y0</span> : bv <span class="mi">8</span>,
       (<span class="kr">‚àÉ</span> <span class="nv">y1</span> : bv <span class="mi">8</span>,
          y = spec.bv_concat <span class="mi">16</span> y0 y1
          ‚àß spec.fetch s1 (PC s1 `+Z` <span class="mi">2</span>) y1)
       ‚àß spec.fetch s1 (PC s1 `+Z` <span class="mi">1</span>) y0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pc = _x_</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">inversion</span> eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk29d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk29d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;!&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And XInd) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_And;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> AND_indirect_x | <span class="nb">apply</span> indirect_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk29e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk29e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk29f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk29f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Bit Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;$&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Bit Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Bit;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> BIT_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;%&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_And;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> AND_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (ShiftL true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;&amp;&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (ShiftL true) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift false true);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ROL_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a4" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;)&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_And;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> AND_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (ShiftL true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;*&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (ShiftL true) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift_A false true); <span class="nb">eapply</span> ROL_A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Bit Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;,&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Bit Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Bit;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> BIT_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2a9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2a9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;-&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_And;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> AND_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2aa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (ShiftL true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;.&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (ShiftL true) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift false true);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ROL_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ab">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* 3 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ac" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ac">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch spec.N true))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;0&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch spec.N true)) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Branch; <span class="nb">eapply</span> BMI.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ad">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;1&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And IndY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_And;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> AND_indirect_y | <span class="nb">apply</span> indirect_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ae">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2af">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;5&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And ZpgX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_And;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> AND_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (ShiftL true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;6&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (ShiftL true) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift false true);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ROL_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b4" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag C true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;8&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag C true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_SetFlag; <span class="nb">eapply</span> SEC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;9&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And AbsY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_And;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> AND_absolute_y | <span class="nb">apply</span> absolute_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2b9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2b9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop And AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;=&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop And AbsX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_And;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> AND_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ba" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ba">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX (ShiftL true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;&gt;&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsX (ShiftL true) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift false true);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ROL_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2bb" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2bb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* 4 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2bc" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2bc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2bd" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2bd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;A&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor XInd) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Xor;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> EOR_indirect_x | <span class="nb">apply</span> indirect_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2be" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2be">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2bf" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2bf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;E&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Xor;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> EOR_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (ShiftR false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;F&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (ShiftR false) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift true false);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LSR_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c4" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;I&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Xor;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> EOR_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (ShiftR false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;J&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (ShiftR false) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift_A true false); <span class="nb">eapply</span> LSR_A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jmp)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;L&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control Jmp) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2c9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2c9"><span class="nb">move</span>=&gt; s1 [? ? ? ?] /JMP H; <span class="nb">specialize</span> (H eq_refl); <span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jmp)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">addr</span> : bv <span class="mi">16</span>,
  absolute s1 addr
  ‚àß _PC_ = addr
    ‚àß _Reg_ = Reg s1
      ‚àß _Flag_ = Flag s1 ‚àß _RAM_ = RAM s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := _Reg_;
  Flag := _Flag_;
  PC := _PC_;
  RAM := _RAM_
|} ‚àà run_instr (Control Jmp) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ca" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ca"><span class="nb">move</span>: H =&gt; [pc [/absolute_mode [? [eq m]] [-&gt; [-&gt; [-&gt; -&gt;]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jmp)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>pc, _x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>MemLoc pc = MemLoc _x_</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà mem_mode_addr s1 Abs0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := Reg s1;
  Flag := Flag s1;
  PC := pc;
  RAM := RAM s1
|} ‚àà run_instr (Control Jmp) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2cb" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2cb"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jmp)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>pc, _x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>MemLoc pc = MemLoc _x_</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà mem_mode_addr s1 Abs0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := Reg s1;
  Flag := Flag s1;
  PC := pc;
  RAM := RAM s1
|}
‚àà {[{|
      Reg := Reg s1;
      Flag := Flag s1;
      PC := _x_;
      RAM := RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2cc" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2cc"><span class="nb">inversion</span> eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Jmp)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>pc, _x_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>eq</var><span class="hyp-type"><b>: </b><span>MemLoc pc = MemLoc _x_</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>_x_ ‚àà mem_mode_addr s1 Abs0</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>pc = _x_</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := Reg s1;
  Flag := Flag s1;
  PC := _x_;
  RAM := RAM s1
|}
‚àà {[{|
      Reg := Reg s1;
      Flag := Flag s1;
      PC := _x_;
      RAM := RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2cd" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2cd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;M&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Xor;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> EOR_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ce" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ce">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (ShiftR false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;N&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (ShiftR false) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift true false);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LSR_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2cf" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2cf">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* 5 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch V false))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;P&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch V false)) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Branch; <span class="nb">eapply</span> BVC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;Q&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor IndY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Xor;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> EOR_indirect_y | <span class="nb">apply</span> indirect_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d4" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;U&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor ZpgX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Xor;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> EOR_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (ShiftR false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;V&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (ShiftR false) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift true false);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LSR_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag I false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;X&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag I false) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_SetFlag; <span class="nb">eapply</span> CLI.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2d9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2d9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;Y&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor AbsY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Xor;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> EOR_absolute_y | <span class="nb">apply</span> absolute_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2da" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2da">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2db" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2db">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2dc" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2dc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2dd" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2dd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Xor AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;]&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Xor AbsX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Xor;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> EOR_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2de" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2de">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX (ShiftR false) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;^&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsX (ShiftR false) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift true false);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LSR_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2df" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2df">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* 6 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2e0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2e0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;`&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control Rts) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2e1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2e1"><span class="nb">move</span>=&gt; s1 [? ? ? ?] /RTS H; <span class="nb">specialize</span> (H eq_refl); <span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">‚àÉ</span> <span class="nv">w1</span> <span class="nv">w2</span> : bv <span class="mi">8</span>,
  spec.fetch s1
    (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>)) w1
  ‚àß spec.fetch s1
      (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>)) w2
    ‚àß _PC_ = spec.bv_concat <span class="mi">16</span> w1 w2 `+Z` <span class="mi">1</span>
      ‚àß _Reg_ = setReg s1 SP (Reg s1 SP `+Z` <span class="mi">2</span>)
        ‚àß _Flag_ = Flag s1 ‚àß _RAM_ = RAM s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := _Reg_;
  Flag := _Flag_;
  PC := _PC_;
  RAM := _RAM_
|} ‚àà run_instr (Control Rts) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2e2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2e2"><span class="nb">move</span>: H =&gt; [w1 [w2 [fetch_w1 [fetch_w2 [-&gt; [-&gt; [-&gt; -&gt;]]]]]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>)) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 SP `+Z` <span class="mi">2</span>);
  Flag := Flag s1;
  PC := spec.bv_concat <span class="mi">16</span> w1 w2 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|} ‚àà run_instr (Control Rts) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2e3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2e3"><span class="nb">eexists</span>; <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>)) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 SP `+Z` <span class="mi">2</span>);
  Flag := Flag s1;
  PC := spec.bv_concat <span class="mi">16</span> w1 w2 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r</span> : reg,
          <span class="kr">if</span> reg_eqb r SP
          <span class="kr">then</span> Reg s1 SP `+Z` <span class="mi">2</span>
          <span class="kr">else</span> Reg s1 r;
      Flag := Flag s1;
      PC := <span class="nl">?a</span> `+Z` <span class="mi">1</span>;
      RAM := RAM s1
    |}]}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk2e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>)) w2</span></span></span><br></div><label class="goal-separator" for="instruction-v-chk2e4"><hr></label><div class="goal-conclusion"><span class="nl">?a</span>
‚àà fetch16 s1 (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>))
    (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2e5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2e5"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>)) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà fetch16 s1 (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>))
    (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2e6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2e6"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>)) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span>
‚àà fetch s1 (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>))
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>, {[spec.bv_concat <span class="mi">16</span> w1 w2]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2e7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2e7"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">exact</span> fetch_w2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>)) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nl">?a</span> ‚àà {[spec.bv_concat <span class="mi">16</span> w1 w2]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2e8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2e8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>)) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 SP `+Z` <span class="mi">2</span>);
  Flag := Flag s1;
  PC := spec.bv_concat <span class="mi">16</span> w1 w2 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|}
‚àà {[{|
      Reg :=
        <span class="kr">Œª</span> <span class="nv">r</span> : reg,
          <span class="kr">if</span> reg_eqb r SP
          <span class="kr">then</span> Reg s1 SP `+Z` <span class="mi">2</span>
          <span class="kr">else</span> Reg s1 r;
      Flag := Flag s1;
      PC := spec.bv_concat <span class="mi">16</span> w1 w2 `+Z` <span class="mi">1</span>;
      RAM := RAM s1
    |}]}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2e9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2e9">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>)) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 SP `+Z` <span class="mi">2</span>);
  Flag := Flag s1;
  PC := spec.bv_concat <span class="mi">16</span> w1 w2 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|} =
{|
  Reg :=
    <span class="kr">Œª</span> <span class="nv">r</span> : reg,
      <span class="kr">if</span> reg_eqb r SP
      <span class="kr">then</span> Reg s1 SP `+Z` <span class="mi">2</span>
      <span class="kr">else</span> Reg s1 r;
  Flag := Flag s1;
  PC := spec.bv_concat <span class="mi">16</span> w1 w2 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ea" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ea"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control Rts)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>w1, w2</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>fetch_w1</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">1</span>)) w1</span></span></span><br><span><var>fetch_w2</var><span class="hyp-type"><b>: </b><span>spec.fetch s1
  (bv_zero_extend <span class="mi">16</span> (Reg s1 SP `+Z` <span class="mi">2</span>)) w2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">setReg s1 SP (Reg s1 SP `+Z` <span class="mi">2</span>) =
(<span class="kr">Œª</span> <span class="nv">r</span> : reg,
   <span class="kr">if</span> reg_eqb r SP <span class="kr">then</span> Reg s1 SP `+Z` <span class="mi">2</span> <span class="kr">else</span> Reg s1 r)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2eb" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2eb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;a&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc XInd) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Adc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ADC_indirect_x | <span class="nb">apply</span> indirect_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ec" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ec">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ed" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ed">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ee" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ee">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ef" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ef">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;e&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Adc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ADC_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f0" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f0">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (ShiftR true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;f&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (ShiftR true) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift true true);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ROR_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f1" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f1">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f2" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f2">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f3" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f3">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;i&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Adc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ADC_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f4" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f4">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (ShiftR true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;j&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (ShiftR true) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift_A true true); <span class="nb">eapply</span> ROR_A.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f5" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f6" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f6">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f7" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f7">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;m&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Adc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ADC_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f8" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (ShiftR true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;n&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (ShiftR true) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift true true);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ROR_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2f9" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2f9">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* 7 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2fa" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2fa">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch V true))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;p&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch V true)) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Branch; <span class="nb">eapply</span> BVS.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2fb" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2fb">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;q&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc IndY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Adc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ADC_indirect_y | <span class="nb">apply</span> indirect_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2fc" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2fc">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2fd" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2fd">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2fe" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2fe">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk2ff" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk2ff">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;u&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc ZpgX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Adc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ADC_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk300" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk300">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (ShiftR true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;v&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (ShiftR true) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift true true);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ROR_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk301" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk301">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk302" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk302">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag I true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;x&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag I true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_SetFlag; <span class="nb">eapply</span> SEI.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk303" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk303">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;y&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc AbsY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Adc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ADC_absolute_y | <span class="nb">apply</span> absolute_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk304" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk304">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk305" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk305">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk306" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk306">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk307" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk307">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Adc AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;}&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Adc AbsX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Adc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ADC_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk308" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk308">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX (ShiftR true) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;~&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsX (ShiftR true) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> (run_Shift true true);
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> ROR_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk309" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk309">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* 8 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk30a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk30a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk30b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk30b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical XInd (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;129&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical XInd (Binop Mov RegA) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STA_indirect_x | <span class="nb">apply</span> indirect_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk30c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk30c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk30d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk30d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk30e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk30e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (Binop Mov RegY) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;132&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (Binop Mov RegY) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STY_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk30f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk30f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;133&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (Binop Mov RegA) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STA_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk310" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk310">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;134&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Zpg0 (Binop Mov RegX) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STX_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk311" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk311">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk312" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk312">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;136&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical RegY Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Dec_reg; <span class="nb">eapply</span> DEY.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk313" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk313">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk314" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk314">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov RegX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;138&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov RegX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_transfer; <span class="nb">eapply</span> TXA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk315" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk315">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk316" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk316">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (Binop Mov RegY) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;140&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (Binop Mov RegY) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STY_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk317" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk317">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;141&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (Binop Mov RegA) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STA_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk318" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk318">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;142&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical Abs0 (Binop Mov RegX) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STX_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk319" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk319">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* 9 *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk31a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk31a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch C false))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;144&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch C false)) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Branch; <span class="nb">eapply</span> BCC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk31b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk31b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical IndY (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;145&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical IndY (Binop Mov RegA) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STA_indirect_y | <span class="nb">apply</span> indirect_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk31c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk31c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk31d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk31d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk31e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk31e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (Binop Mov RegY) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;148&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (Binop Mov RegY) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STY_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk31f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk31f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;149&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgX (Binop Mov RegA) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STA_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk320" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk320">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgY (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;150&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical ZpgY (Binop Mov RegX) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STX_zero_page_y | <span class="nb">apply</span> zero_page_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk321" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk321">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk322" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk322">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov RegY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;152&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov RegY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_transfer; <span class="nb">eapply</span> TYA.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk323" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk323">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsY (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;153&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsY (Binop Mov RegA) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STA_absolute_y | <span class="nb">apply</span> absolute_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk324" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk324">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;154&quot;</span>)
  ‚Üí s2
    ‚àà run_instr
        (Typical (RegMode SP) (Binop Mov RegX) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk325" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk325"><span class="nb">move</span>=&gt; s1 [? ? ? ?] /TXS H; <span class="nb">specialize</span> (H eq_refl); <span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>_PC_ = PC s1 `+Z` <span class="mi">1</span>
‚àß _Reg_ = setReg s1 SP (Reg s1 X)
  ‚àß _Flag_ = Flag s1 ‚àß _RAM_ = RAM s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := _Reg_;
  Flag := _Flag_;
  PC := _PC_;
  RAM := _RAM_
|}
‚àà run_instr
    (Typical (RegMode SP) (Binop Mov RegX) false) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk326" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk326"><span class="nb">move</span>: H =&gt; [-&gt; [-&gt; [-&gt; -&gt;]]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 X);
  Flag := Flag s1;
  PC := PC s1 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|}
‚àà run_instr
    (Typical (RegMode SP) (Binop Mov RegX) false) s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk327" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk327"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 X);
  Flag := Flag s1;
  PC := PC s1 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|}
‚àà read s1 (RegLoc SP)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w</span> : bv <span class="mi">8</span>,
        run_operation (Binop Mov RegX) s1 w
        ‚â´= (<span class="kr">Œª</span> &#39;(w0, c, v),
              <span class="kr">let</span> <span class="nv">len</span> :=
                Z.of_nat
                  (S
                     (mode_len (RegMode SP)
                      `max` 
                      mode_len RegX)) <span class="kr">in</span>
              <span class="kr">let</span> <span class="nv">write_back</span> := true <span class="kr">in</span>
              {[{|
                  Reg :=
                    <span class="kr">if</span> write_back
                    <span class="kr">then</span>
                     <span class="kr">match</span> RegLoc SP <span class="kr">with</span>
                     | RegLoc r =&gt;
                       <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                       <span class="kr">if</span> reg_eqb r r&#39;
                       <span class="kr">then</span> w0
                       <span class="kr">else</span> Reg s1 r&#39;
                     | MemLoc _ =&gt; Reg s1
                     <span class="kr">end</span>
                    <span class="kr">else</span> Reg s1;
                  Flag :=
                    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                      <span class="kr">match</span> f <span class="kr">with</span>
                      | V =&gt; v
                      | C =&gt; c
                      | _ =&gt; Flag s1 f
                      <span class="kr">end</span>;
                  PC := PC s1 `+Z` len;
                  RAM :=
                    <span class="kr">match</span> RegLoc SP <span class="kr">with</span>
                    | RegLoc _ =&gt; RAM s1
                    | MemLoc a =&gt; write a w0 (RAM s1)
                    <span class="kr">end</span>
                |}]}))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk328" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk328"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 X);
  Flag := Flag s1;
  PC := PC s1 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|}
‚àà run_operation (Binop Mov RegX) s1 (Reg s1 SP)
  ‚â´= (<span class="kr">Œª</span> &#39;(w, c, v),
        <span class="kr">let</span> <span class="nv">len</span> :=
          Z.of_nat
            (S
               (mode_len (RegMode SP)
                `max` mode_len RegX)) <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">write_back</span> := true <span class="kr">in</span>
        {[{|
            Reg :=
              <span class="kr">if</span> write_back
              <span class="kr">then</span>
               <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
                 <span class="kr">if</span> reg_eqb SP r&#39;
                 <span class="kr">then</span> w
                 <span class="kr">else</span> Reg s1 r&#39;
              <span class="kr">else</span> Reg s1;
            Flag :=
              <span class="kr">Œª</span> <span class="nv">f</span> : flag,
                <span class="kr">match</span> f <span class="kr">with</span>
                | V =&gt; v
                | C =&gt; c
                | _ =&gt; Flag s1 f
                <span class="kr">end</span>;
            PC := PC s1 `+Z` len;
            RAM := RAM s1
          |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk329" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk329"><span class="nb">eexists</span> (_,_,_); <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 X);
  Flag := Flag s1;
  PC := PC s1 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|}
‚àà (<span class="kr">let</span> <span class="nv">len</span> :=
     Z.of_nat
       (S (mode_len (RegMode SP) `max` mode_len RegX))
     <span class="kr">in</span>
   <span class="kr">let</span> <span class="nv">write_back</span> := true <span class="kr">in</span>
   {[{|
       Reg :=
         <span class="kr">if</span> write_back
         <span class="kr">then</span>
          <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
            <span class="kr">if</span> reg_eqb SP r&#39;
            <span class="kr">then</span> <span class="nl">?Goal100</span>
            <span class="kr">else</span> Reg s1 r&#39;
         <span class="kr">else</span> Reg s1;
       Flag :=
         <span class="kr">Œª</span> <span class="nv">f</span> : flag,
           <span class="kr">match</span> f <span class="kr">with</span>
           | V =&gt; <span class="nl">?Goal102</span>
           | C =&gt; <span class="nl">?Goal101</span>
           | _ =&gt; Flag s1 f
           <span class="kr">end</span>;
       PC := PC s1 `+Z` len;
       RAM := RAM s1
     |}]})</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="instruction-v-chk32a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><label class="goal-separator" for="instruction-v-chk32a"><hr></label><div class="goal-conclusion">(<span class="nl">?Goal100</span>, <span class="nl">?Goal101</span>, <span class="nl">?Goal102</span>)
‚àà run_operation (Binop Mov RegX) s1 (Reg s1 SP)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk32b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk32b"><span class="mi">2</span>: {</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal100</span>, <span class="nl">?Goal101</span>, <span class="nl">?Goal102</span>)
‚àà run_operation (Binop Mov RegX) s1 (Reg s1 SP)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk32c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk32c"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal100</span>, <span class="nl">?Goal101</span>, <span class="nl">?Goal102</span>)
‚àà read s1 (RegLoc X)
  ‚â´= (<span class="kr">Œª</span> <span class="nv">w2</span> : bv <span class="mi">8</span>, run_binop Mov s1 (Reg s1 SP) w2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk32d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk32d"><span class="nb">eexists</span>; <span class="nb">split</span>; <span class="nb">last</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="nl">?Goal100</span>, <span class="nl">?Goal101</span>, <span class="nl">?Goal102</span>)
‚àà run_binop Mov s1 (Reg s1 SP) (Reg s1 X)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk32e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk32e">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 X);
  Flag := Flag s1;
  PC := PC s1 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|}
‚àà (<span class="kr">let</span> <span class="nv">len</span> :=
     Z.of_nat
       (S (mode_len (RegMode SP) `max` mode_len RegX))
     <span class="kr">in</span>
   <span class="kr">let</span> <span class="nv">write_back</span> := true <span class="kr">in</span>
   {[{|
       Reg :=
         <span class="kr">if</span> write_back
         <span class="kr">then</span>
          <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
            <span class="kr">if</span> reg_eqb SP r&#39;
            <span class="kr">then</span> Reg s1 X
            <span class="kr">else</span> Reg s1 r&#39;
         <span class="kr">else</span> Reg s1;
       Flag :=
         <span class="kr">Œª</span> <span class="nv">f</span> : flag,
           <span class="kr">match</span> f <span class="kr">with</span>
           | V =&gt; Flag s1 V
           | C =&gt; Flag s1 C
           | _ =&gt; Flag s1 f
           <span class="kr">end</span>;
       PC := PC s1 `+Z` len;
       RAM := RAM s1
     |}]})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk32f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk32f">set_unfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := setReg s1 SP (Reg s1 X);
  Flag := Flag s1;
  PC := PC s1 `+Z` <span class="mi">1</span>;
  RAM := RAM s1
|} =
{|
  Reg :=
    <span class="kr">Œª</span> <span class="nv">r&#39;</span> : reg,
      <span class="kr">if</span> reg_eqb SP r&#39; <span class="kr">then</span> Reg s1 X <span class="kr">else</span> Reg s1 r&#39;;
  Flag :=
    <span class="kr">Œª</span> <span class="nv">f</span> : flag,
      <span class="kr">match</span> f <span class="kr">with</span>
      | V =&gt; Flag s1 V
      | C =&gt; Flag s1 C
      | _ =&gt; Flag s1 f
      <span class="kr">end</span>;
  PC := PC s1 `+Z` Z.of_nat <span class="mi">1</span>;
  RAM := RAM s1
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk330" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk330"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some
  (Typical (RegMode SP) (Binop Mov RegX) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Flag s1 =
(<span class="kr">Œª</span> <span class="nv">f</span> : flag,
   <span class="kr">match</span> f <span class="kr">with</span>
   | V =&gt; Flag s1 V
   | C =&gt; Flag s1 C
   | _ =&gt; Flag s1 f
   <span class="kr">end</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">apply</span> functional_extensionality; <span class="nb">case</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk331" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk331">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk332" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk332">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk333" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk333">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX (Binop Mov RegA) false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;157&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical AbsX (Binop Mov RegA) false)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_store;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> STA_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk334" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk334">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk335" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk335">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* A *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk336" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk336">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;160&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDY_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk337" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk337">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;161&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov XInd) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDA_indirect_x | <span class="nb">apply</span> indirect_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk338" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk338">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;162&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDX_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk339" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk339">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk33a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk33a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;164&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDY_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk33b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk33b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;165&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDA_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk33c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk33c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;166&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDX_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk33d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk33d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk33e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk33e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov RegA) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;168&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov RegA) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_transfer; <span class="nb">eapply</span> TAY.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk33f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk33f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;169&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDA_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk340" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk340">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov RegA) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;170&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov RegA) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_transfer; <span class="nb">eapply</span> TAX.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk341" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk341">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk342" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk342">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;172&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDY_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk343" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk343">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;173&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDA_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk344" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk344">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;174&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDX_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk345" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk345">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* B *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk346" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk346">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch C true))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;176&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch C true)) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Branch; <span class="nb">eapply</span> BCS.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk347" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk347">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;177&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov IndY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDA_indirect_y | <span class="nb">apply</span> indirect_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk348" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk348">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk349" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk349">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk34a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk34a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;180&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov ZpgX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDY_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk34b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk34b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;181&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov ZpgX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDA_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk34c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk34c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov ZpgY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;182&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov ZpgY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDX_zero_page_y | <span class="nb">apply</span> zero_page_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk34d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk34d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk34e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk34e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag V false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;184&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag V false) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_SetFlag; <span class="nb">eapply</span> CLV.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk34f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk34f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;185&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov AbsY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDA_absolute_y | <span class="nb">apply</span> absolute_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk350" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk350">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov (RegMode SP)) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;186&quot;</span>)
  ‚Üí s2
    ‚àà run_instr
        (Typical RegX (Binop Mov (RegMode SP)) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_transfer; <span class="nb">eapply</span> TSX.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk351" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk351">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk352" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk352">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Mov AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;188&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Mov AbsX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDY_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk353" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk353">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Mov AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;189&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Mov AbsX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDA_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk354" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk354">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Mov AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;190&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Mov AbsY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_load;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> LDX_absolute_y | <span class="nb">apply</span> absolute_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk355" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk355">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* C *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk356" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk356">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Cmp Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;192&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Cmp Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CPY_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk357" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk357">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;193&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp XInd) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CMP_indirect_x | <span class="nb">apply</span> indirect_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk358" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk358">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk359" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk359">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk35a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk35a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Cmp Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;196&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Cmp Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CPY_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk35b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk35b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;197&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CMP_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk35c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk35c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;198&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical Zpg0 Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Dec_mode;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> DEC_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk35d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk35d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk35e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk35e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;200&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical RegY Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Inc_reg; <span class="nb">eapply</span> INY.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk35f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk35f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;201&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CMP_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk360" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk360">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;202&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical RegX Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Dec_reg; <span class="nb">eapply</span> DEX.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk361" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk361">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk362" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk362">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegY (Binop Cmp Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;204&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegY (Binop Cmp Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CPY_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk363" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk363">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;205&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CMP_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk364" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk364">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;206&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical Abs0 Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Dec_mode;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> DEC_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk365" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk365">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* D *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk366" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk366">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch spec.Z false))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;208&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch spec.Z false)) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Branch; <span class="nb">eapply</span> BNE.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk367" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk367">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;209&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp IndY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CMP_indirect_y | <span class="nb">apply</span> indirect_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk368" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk368">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk369" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk369">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk36a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk36a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk36b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk36b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;213&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp ZpgX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CMP_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk36c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk36c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;214&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical ZpgX Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Dec_mode;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> DEC_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk36d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk36d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk36e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk36e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag D false)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;216&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag D false) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_SetFlag; <span class="nb">eapply</span> CLD.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk36f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk36f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;217&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp AbsY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CMP_absolute_y | <span class="nb">apply</span> absolute_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk370" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk370">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk371" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk371">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk372" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk372">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk373" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk373">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Cmp AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;221&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Cmp AbsX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CMP_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk374" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk374">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX Dec true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;222&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical AbsX Dec true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Dec_mode;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> DEC_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk375" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk375">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* E *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk376" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk376">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Cmp Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;224&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Cmp Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CPX_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk377" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk377">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc XInd) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;225&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc XInd) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Sbc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> SBC_indirect_x | <span class="nb">apply</span> indirect_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk378" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk378">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk379" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk379">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk37a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk37a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Cmp Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;228&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Cmp Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CPX_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk37b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk37b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc Zpg0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;229&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc Zpg0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Sbc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> SBC_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk37c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk37c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Zpg0 Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;230&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical Zpg0 Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Inc_mode;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> INC_zero_page | <span class="nb">apply</span> zero_page_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk37d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk37d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk37e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk37e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;232&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical RegX Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Inc_reg; <span class="nb">eapply</span> INX.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk37f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk37f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc Imm) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;233&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc Imm) true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Sbc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> SBC_immediate | <span class="nb">apply</span> immediate_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk380" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk380">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some Nop</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;234&quot;</span>)
  ‚Üí s2 ‚àà run_instr Nop s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk381" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk381"><span class="nb">move</span>=&gt; s1 [? ? ? ?] /NOP =&gt; H; <span class="nb">specialize</span> (H eq_refl); <span class="nb">simpl</span> <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some Nop</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>state</span></span></span><br><span><var>_Reg_</var><span class="hyp-type"><b>: </b><span>reg ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>_Flag_</var><span class="hyp-type"><b>: </b><span>flag ‚Üí bool</span></span></span><br><span><var>_PC_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">16</span></span></span></span><br><span><var>_RAM_</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">7</span> ‚Üí bv <span class="mi">8</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>_PC_ = PC s1 `+Z` <span class="mi">1</span>
‚àß _Reg_ = Reg s1
  ‚àß _Flag_ = Flag s1 ‚àß _RAM_ = RAM s1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  Reg := _Reg_;
  Flag := _Flag_;
  PC := _PC_;
  RAM := _RAM_
|} ‚àà run_instr Nop s1</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">move</span>: H =&gt; [-&gt; [-&gt; [-&gt; -&gt;]]].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk382" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk382">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk383" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk383">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegX (Binop Cmp Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;236&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegX (Binop Cmp Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Cmp;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> CPX_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk384" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk384">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc Abs0) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;237&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc Abs0) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Sbc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> SBC_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk385" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk385">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical Abs0 Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;238&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical Abs0 Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Inc_mode;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> INC_absolute | <span class="nb">apply</span> absolute_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk386" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk386">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* F *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk387" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk387">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Control (Branch spec.Z true))</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;240&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Control (Branch spec.Z true)) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Branch; <span class="nb">eapply</span> BEQ.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk388" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk388">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc IndY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;241&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc IndY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Sbc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> SBC_indirect_y | <span class="nb">apply</span> indirect_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk389" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk389">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk38a" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk38a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk38b" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk38b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk38c" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk38c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc ZpgX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;245&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc ZpgX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Sbc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> SBC_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk38d" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk38d">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical ZpgX Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;246&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical ZpgX Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Inc_mode;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> INC_zero_page_x | <span class="nb">apply</span> zero_page_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk38e" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk38e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk38f" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk38f">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (SetFlag D true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;248&quot;</span>)
  ‚Üí s2 ‚àà run_instr (SetFlag D true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_SetFlag; <span class="nb">eapply</span> SED.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk390" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk390">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc AbsY) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;249&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc AbsY) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Sbc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> SBC_absolute_y | <span class="nb">apply</span> absolute_y_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk391" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk391">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk392" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk392">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk393" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk393">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk394" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk394">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical RegA (Binop Sbc AbsX) true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;253&quot;</span>)
  ‚Üí s2
    ‚àà run_instr (Typical RegA (Binop Sbc AbsX) true)
        s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Sbc;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> SBC_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk395" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk395">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>Some (Typical AbsX Inc true)</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">‚àÄ</span> <span class="nv">s1</span> <span class="nv">s2</span> : state,
  instruction s1 s2 (fast_bv_of_byte <span class="s2">&quot;254&quot;</span>)
  ‚Üí s2 ‚àà run_instr (Typical AbsX Inc true) s1</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">by</span> <span class="nb">intros</span>; <span class="nb">eapply</span> run_Inc_mode;
        [<span class="bp">reflexivity</span> | <span class="nb">eapply</span> INC_absolute_x | <span class="nb">apply</span> absolute_x_mode].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="instruction-v-chk396" style="display: none" type="checkbox"><label class="alectryon-input" for="instruction-v-chk396">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>opcode</var><span class="hyp-type"><b>: </b><span>bv <span class="mi">8</span></span></span></span><br><span><var>tmp</var><span><span class="hyp-body"><b>:= </b><span>None</span></span><span class="hyp-type"><b>: </b><span>option instr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></div>
</div>
</div>
<div class="section" id="conclusion">
<h1>Conclusion</h1>
<p>This concludes the proof. So what does this gain us?</p>
<p>To recap:</p>
<ul>
<li><p class="first"><tt class="docutils literal">spec.v</tt> defines the behavior of the Atari.
However, it does so by individually stating the behavior of each valid opcode.
This is clunky and hard to work with.</p>
</li>
<li><p class="first">This file, on the other hand, gives a higher level explanation of that same behavior.
It explains which opcodes correspond to valid instructions, then explains the meaning of those instructions in a more modular way.
This should be significantly easier to work with than the original spec.</p>
<p>In particular, it is no longer necessary to poke through the details
of an instruction's execution to figure out where the next instruction is!</p>
</li>
<li><p class="first">We end by proving that the higher level description faithfully models the low-level spec.
This means all future proofs can be written at this higher level.</p>
</li>
</ul>
</div>
</div>
</div></body>
</html>
